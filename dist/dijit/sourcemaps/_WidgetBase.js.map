{"version":3,"sources":["_WidgetBase.js"],"names":["define","require","array","aspect","config","connect","declare","dom","domAttr","domClass","domConstruct","domGeometry","domStyle","has","kernel","lang","on","ready","Stateful","topic","win","Destroyable","_BidiMixin","registry","add","isAsync","tagAttrs","nonEmptyAttrToDom","attr","val","this","domNode","_set","_WidgetBase","id","_setIdAttr","_setLangAttr","dir","_setDirAttr","class","_setClassAttr","node","type","_setTypeAttr","style","title","tooltip","baseClass","srcNodeRef","containerNode","ownerDocument","_setOwnerDocumentAttr","attributeMap","_blankGif","blankGif","toUrl","_introspect","ctor","constructor","_setterAttrs","proto","prototype","attrs","onMap","_onMap","name","push","test","substring","toLowerCase","charAt","substr","length","postscript","params","create","deleteSrcNodeRef","byId","_connects","_supportingWidgets","mixin","postMixInProperties","getUniqueId","declaredClass","replace","document","ownerDocumentBody","body","buildRendering","_applyAttributes","source","parentNode","replaceChild","setAttribute","postCreate","_created","key","_get","forEach","set","createElement","classes","split","isLeftToRight","concat","map","startup","_started","getChildren","obj","_destroyed","isFunction","destroyRecursive","preserveDom","_beingDestroyed","destroyDescendants","destroy","w","uninitialize","hitch","findWidgets","destroyRendering","remove","bgIframe","widget","_setStyleAttr","value","mapNode","isObject","cssText","_attrToDom","commands","arguments","isArray","command","attrName","attribute","tagName","innerHTML","appendChild","createTextNode","get","names","_getAttrNames","g","x","setter","s","result","apply","Array","slice","call","defaultNode","focusNode","tag","attrsForTag","ret","getAttrs","l","_attrPairNames","apn","uc","c","toUpperCase","n","a","b","oldValue","_watchCallbacks","emit","detail","prevValue","newValue","eventObj","callbackArgs","undefined","bubbles","cancelable","callback","func","widgetMethod","after","own","toString","getParent","getEnclosingWidget","event","method","disconnect","handle","subscribe","t","unsubscribe","isBodyLtr","isFocusable","focus","placeAt","reference","position","refWidget","addChild","ref","place","defer","fcn","delay","timer","setTimeout","clearTimeout","extend"],"mappings":";;;;;;;AAAAA,QACC,UACA,mBACA,cACA,oBACA,qBACA,qBACA,WACA,gBACA,iBACA,qBACA,oBACA,iBACA,WACA,oBACA,kBACA,UACA,aACA,gBACA,aACA,oBACA,gBACA,kCACA,cACE,SAASC,QAASC,EAAOC,EAAQC,EAAQC,EAASC,EAClDC,EAAKC,EAASC,EAAUC,EAAcC,EAAaC,EAAUC,EAAKC,EAClEC,EAAMC,EAAIC,EAAOC,EAAUC,EAAOC,EAAKC,EAAaC,EAAYC,GAMlEV,EAAIW,IAAI,yBAA0BV,EAAOW,SAGzCZ,EAAIW,IAAI,aAAa,GAIlBX,EAAI,0BACNI,EAAM,EAAG,WAERhB,SADgB,0BAOlB,IAAIyB,KAUJ,SAASC,EAAkBC,GAK1B,OAAO,SAASC,GACfrB,EAAQqB,EAAM,MAAQ,UAAUC,KAAKC,QAASH,EAAMC,GACpDC,KAAKE,KAAKJ,EAAMC,IAalB,IAAII,EAAc3B,EAAQ,qBAAsBY,EAAUG,IAiDzDa,GAAI,GACJC,WAAY,UAOZpB,KAAM,GAENqB,aAAcT,EAAkB,QAMhCU,IAAK,GAELC,YAAaX,EAAkB,OAI/BY,MAAS,GACTC,eAAiBC,KAAM,UAAWC,KAAM,SAIxCC,aAAc,KAIdC,MAAO,GAWPC,MAAO,GAKPC,QAAS,GAKTC,UAAW,GAIXC,WAAY,KAOZjB,QAAS,KAyBTkB,cAAe,KAKfC,cAAe,KACfC,sBAAuB,SAAStB,GAE/BC,KAAKE,KAAK,gBAAiBH,IAmD5BuB,gBAKAC,UAAWjD,EAAOkD,UAAYrD,QAAQsD,MAAM,4BAqB5CC,YAAa,WAOZ,IAAIC,EAAO3B,KAAK4B,YAChB,IAAID,EAAKE,aAAa,CACrB,IAAIC,EAAQH,EAAKI,UAChBC,EAAQL,EAAKE,gBACbI,EAASN,EAAKO,UAGf,IAAI,IAAIC,KAAQL,EAAMR,aACrBU,EAAMI,KAAKD,GAIZ,IAAIA,KAAQL,EACR,MAAMO,KAAKF,KACbF,EAAME,EAAKG,UAAU,GAAGC,eAAiBJ,GAGvC,sBAAsBE,KAAKF,KAC7BA,EAAOA,EAAKK,OAAO,GAAGD,cAAgBJ,EAAKM,OAAO,EAAGN,EAAKO,OAAS,GAC/DZ,EAAMR,cAAkBa,KAAQL,EAAMR,cACzCU,EAAMI,KAAKD,MAUhBQ,WAAY,SAAoBC,EAA0B1B,GASzDlB,KAAK6C,OAAOD,EAAQ1B,IAGrB2B,OAAQ,SAASD,EAAQ1B,GA+DxB,IAAI4B,EAEJ,GAzCA9C,KAAK0B,cAGL1B,KAAKkB,WAAazC,EAAIsE,KAAK7B,GAG3BlB,KAAKgD,aACLhD,KAAKiD,sBAGFjD,KAAKkB,YAA4C,iBAAtBlB,KAAKkB,WAAWd,KAC7CJ,KAAKI,GAAKJ,KAAKkB,WAAWd,IAIxBwC,IACF5C,KAAK4C,OAASA,EACd3D,EAAKiE,MAAMlD,KAAM4C,IAElB5C,KAAKmD,sBAIDnD,KAAKI,KACRJ,KAAKI,GAAKX,EAAS2D,YAAYpD,KAAKqD,cAAcC,QAAQ,MAAO,MAC9DtD,KAAK4C,eAEA5C,KAAK4C,OAAOxC,IAKrBJ,KAAKoB,cAAgBpB,KAAKoB,gBAAkBpB,KAAKkB,WAAalB,KAAKkB,WAAWE,cAAgBmC,UAC9FvD,KAAKwD,kBAAoBlE,EAAImE,KAAKzD,KAAKoB,eAEvC3B,EAASC,IAAIM,MAEbA,KAAK0D,iBAIF1D,KAAKC,QAAQ,CAGfD,KAAK2D,mBAML,IAAIC,EAAS5D,KAAKkB,WACf0C,GAAUA,EAAOC,YAAc7D,KAAKC,UAAY2D,IAClDA,EAAOC,WAAWC,aAAa9D,KAAKC,QAAS2D,GAC7Cd,GAAmB,GAKpB9C,KAAKC,QAAQ8D,aAAa,WAAY/D,KAAKI,IAE5CJ,KAAKgE,aAIFlB,UACK9C,KAAKkB,WAGblB,KAAKiE,UAAW,GAGjBN,iBAAkB,WAuBjB,IAAIf,KACJ,IAAI,IAAIsB,KAAOlE,KAAK4C,WACnBA,EAAOsB,GAAOlE,KAAKmE,KAAKD,GAezB,IAAIA,KAXJ9F,EAAMgG,QAAQpE,KAAK4B,YAAYC,aAAc,SAASqC,GACrD,KAAKA,KAAOtB,GAAQ,CACnB,IAAI7C,EAAMC,KAAKmE,KAAKD,GACjBnE,GACFC,KAAKqE,IAAIH,EAAKnE,KAGdC,MAIQ4C,EACV5C,KAAKqE,IAAIH,EAAKtB,EAAOsB,KAIvBf,oBAAqB,aAUrBO,eAAgB,WAef,GARI1D,KAAKC,UAERD,KAAKC,QAAUD,KAAKkB,YAAclB,KAAKoB,cAAckD,cAAc,QAMjEtE,KAAKiB,UAAU,CACjB,IAAIsD,EAAUvE,KAAKiB,UAAUuD,MAAM,KAC/BxE,KAAKyE,kBACRF,EAAUA,EAAQG,OAAOtG,EAAMuG,IAAIJ,EAAS,SAASpC,GACpD,OAAOA,EAAO,UAGhBxD,EAASe,IAAIM,KAAKC,QAASsE,KAI7BP,WAAY,aAWZY,QAAS,WAWL5E,KAAK6E,WAGR7E,KAAK6E,UAAW,EAChBzG,EAAMgG,QAAQpE,KAAK8E,cAAe,SAASC,GACtCA,EAAIF,UAAaE,EAAIC,aAAc/F,EAAKgG,WAAWF,EAAIH,WAC1DG,EAAIH,UACJG,EAAIF,UAAW,OAOlBK,iBAAkB,SAAsBC,GAYvCnF,KAAKoF,iBAAkB,EACvBpF,KAAKqF,mBAAmBF,GACxBnF,KAAKsF,QAAQH,IAGdG,QAAS,SAAqBH,GAkB7B,SAASG,EAAQC,GACbA,EAAEL,iBACJK,EAAEL,iBAAiBC,GACXI,EAAED,SACVC,EAAED,QAAQH,GAPZnF,KAAKoF,iBAAkB,EACvBpF,KAAKwF,eAWLpH,EAAMgG,QAAQpE,KAAKgD,UAAW/D,EAAKwG,MAAMzF,KAAM,eAC/C5B,EAAMgG,QAAQpE,KAAKiD,mBAAoBqC,GAIpCtF,KAAKC,SACP7B,EAAMgG,QAAQ3E,EAASiG,YAAY1F,KAAKC,QAASD,KAAKmB,eAAgBmE,GAGvEtF,KAAK2F,iBAAiBR,GACtB1F,EAASmG,OAAO5F,KAAKI,IACrBJ,KAAKgF,YAAa,GAGnBW,iBAAkB,SAAsBR,GAUpCnF,KAAK6F,WACP7F,KAAK6F,SAASP,QAAQH,UACfnF,KAAK6F,UAGV7F,KAAKC,UACJkF,EACFzG,EAAQkH,OAAO5F,KAAKC,QAAS,YAE7BrB,EAAa0G,QAAQtF,KAAKC,gBAEpBD,KAAKC,SAGVD,KAAKkB,aACHiE,GACHvG,EAAa0G,QAAQtF,KAAKkB,mBAEpBlB,KAAKkB,aAIdmE,mBAAoB,SAAsBF,GAUzC/G,EAAMgG,QAAQpE,KAAK8E,cAAe,SAASgB,GACvCA,EAAOZ,kBACTY,EAAOZ,iBAAiBC,MAK3BK,aAAc,WAMb,OAAO,GAKRO,cAAe,SAA4BC,GAW1C,IAAIC,EAAUjG,KAAKC,QAKhBhB,EAAKiH,SAASF,GAChBlH,EAASuF,IAAI4B,EAASD,GAEnBC,EAAQnF,MAAMqF,QAChBF,EAAQnF,MAAMqF,SAAW,KAAOH,EAEhCC,EAAQnF,MAAMqF,QAAUH,EAI1BhG,KAAKE,KAAK,QAAS8F,IAGpBI,WAAY,SAAoBtG,EAAiBkG,EAAmBK,GAanEA,EAAWC,UAAU5D,QAAU,EAAI2D,EAAWrG,KAAKsB,aAAaxB,GAEhE1B,EAAMgG,QAAQnF,EAAKsH,QAAQF,GAAYA,GAAYA,GAAW,SAASG,GAGtE,IAAIP,EAAUjG,KAAKwG,EAAQ7F,MAAQ6F,GAAW,WAG9C,OAFWA,EAAQ5F,MAAQ,aAG1B,IAAK,YACD3B,EAAKgG,WAAWe,KAClBA,EAAQ/G,EAAKwG,MAAMzF,KAAMgG,IAM1B,IAAIS,EAAWD,EAAQE,UAAYF,EAAQE,UACzC,qBAAqBrE,KAAKvC,GAAQA,EAAKyC,cAAgBzC,EAEtDmG,EAAQU,QAGVjI,EAAQ2F,IAAI4B,EAASQ,EAAUT,GAG/BC,EAAQ5B,IAAIoC,EAAUT,GAEvB,MACD,IAAK,YACJC,EAAQW,UAAY,GACpBX,EAAQY,YAAY7G,KAAKoB,cAAc0F,eAAed,IACtD,MACD,IAAK,YACJC,EAAQW,UAAYZ,EACpB,MACD,IAAK,QACJrH,EAAS2E,QAAQ2C,EAASD,EAAOhG,KAAKF,MAGtCE,OAGJ+G,IAAK,SAAS5E,GAgBb,IAAI6E,EAAQhH,KAAKiH,cAAc9E,GAC/B,OAAOnC,KAAKgH,EAAME,GAAKlH,KAAKgH,EAAME,KAAOlH,KAAKmE,KAAKhC,IAGpDkC,IAAK,SAASlC,EAAM6D,GA0BnB,GAAmB,iBAAT7D,EAAkB,CAC3B,IAAI,IAAIgF,KAAKhF,EACZnC,KAAKqE,IAAI8C,EAAGhF,EAAKgF,IAElB,OAAOnH,KAER,IAAIgH,EAAQhH,KAAKiH,cAAc9E,GAC9BiF,EAASpH,KAAKgH,EAAMK,GACrB,GAAGpI,EAAKgG,WAAWmC,GAElB,IAAIE,EAASF,EAAOG,MAAMvH,KAAMwH,MAAMzF,UAAU0F,MAAMC,KAAKpB,UAAW,QAClE,CASJ,IAAIqB,EAAc3H,KAAK4H,YAAc3I,EAAKgG,WAAWjF,KAAK4H,WAAa,YAAc,UACpFC,EAAM7H,KAAK2H,IAAgB3H,KAAK2H,GAAahB,QAC7CmB,EAAcD,IAAQjI,EAASiI,KAASjI,EAASiI,GA9wBrD,SAAkB9C,GACjB,IAAIgD,KACJ,IAAI,IAAIjI,KAAQiF,EACfgD,EAAIjI,EAAKyC,gBAAiB,EAE3B,OAAOwF,EAywBoDC,CAAShI,KAAK2H,MACtEhD,EAAMxC,KAAQnC,KAAKsB,aAAetB,KAAKsB,aAAaa,GACnD6E,EAAMK,KAAKrH,KAAOA,KAAKgH,EAAMK,GAC1BS,GAAed,EAAMiB,KAAKH,GAA+B,mBAAT9B,GACjD,uBAAuB3D,KAAKF,GAASwF,EAAc,KAC7C,MAAPhD,GACF3E,KAAKoG,WAAWjE,EAAM6D,EAAOrB,GAE9B3E,KAAKE,KAAKiC,EAAM6D,GAEjB,OAAOsB,GAAUtH,MAGlBkI,kBACAjB,cAAe,SAAS9E,GAOvB,IAAIgG,EAAMnI,KAAKkI,eACf,GAAGC,EAAIhG,GACN,OAAOgG,EAAIhG,GAEZ,IAAIiG,EAAKjG,EAAKmB,QAAQ,oBAAqB,SAAS+E,GACnD,OAAOA,EAAE7F,OAAO6F,EAAE3F,OAAS,GAAG4F,gBAE/B,OAAQH,EAAIhG,IACXoG,EAAGpG,EAAO,OACVkF,EAAG,OAASe,EAAK,OACjBlB,EAAG,OAASkB,EAAK,OACjBH,EAAGG,EAAG7F,gBAIRrC,KAAM,SAAoBiC,EAAmB6D,GAI5C,IAnyBewC,EAAGC,EAmyBdC,EAAW1I,KAAKmC,GACpBnC,KAAKmC,GAAQ6D,GACVhG,KAAKiE,YAryBOuE,EAqyBcE,MAryBXD,EAqyBqBzC,IA/xBNwC,GAAMA,GAAoBC,GAAMA,KAgyB7DzI,KAAK2I,iBACP3I,KAAK2I,gBAAgBxG,EAAMuG,EAAU1C,GAEtChG,KAAK4I,KAAK,gBAAkBzG,GAC3B0G,QACCC,UAAWJ,EACXK,SAAU/C,OAMd7B,KAAM,SAAoBhC,GAQzB,OAAOnC,KAAKmC,IAGbyG,KAAM,SAAoBhI,EAAkBoI,EAAqBC,QAgBxCC,KADxBF,EAAWA,OACCG,UACXH,EAASG,SAAU,QAEOD,IAAxBF,EAASI,aACXJ,EAASI,YAAa,GAEnBJ,EAASH,SACZG,EAASH,WAEVG,EAASH,OAAO/C,OAAS9F,KAEzB,IAAI+H,EAAKsB,EAAWrJ,KAAK,KAAOY,GAUhC,OATGyI,IACFtB,EAAMsB,EAAS9B,MAAMvH,KAAMiJ,IAA+BD,KAIxDhJ,KAAK6E,WAAa7E,KAAKoF,iBACzBlG,EAAG0J,KAAK5I,KAAKC,QAASW,EAAK2B,cAAeyG,GAGpCjB,GAGR7I,GAAI,SAA6B0B,EAAmB0I,GAYnD,IAAIC,EAAevJ,KAAKkC,OAAOtB,GAC/B,OAAG2I,EACKlL,EAAOmL,MAAMxJ,KAAMuJ,EAAcD,GAAM,GAIxCtJ,KAAKyJ,IAAIvK,EAAGc,KAAKC,QAASW,EAAM0I,IAAO,IAG/CpH,OAAQ,SAA6BtB,GAIpC,IAAIe,EAAO3B,KAAK4B,YAAa+C,EAAMhD,EAAKO,OACxC,IAAIyC,EAEH,IAAI,IAAI7E,KADR6E,EAAOhD,EAAKO,UACIP,EAAKI,UACjB,MAAMM,KAAKvC,KACb6E,EAAI7E,EAAKwD,QAAQ,MAAO,IAAIf,eAAiBzC,GAIhD,OAAO6E,EAAmB,iBAAR/D,GAAoBA,EAAK2B,gBAG5CmH,SAAU,WAOT,MAAO,WAAa1J,KAAKqD,cAAgB,MAAQrD,KAAKI,IAAM,SAAW,KAGxE0E,YAAa,WAaZ,OAAO9E,KAAKmB,cAAgB1B,EAASiG,YAAY1F,KAAKmB,mBAGvDwI,UAAW,WAIV,OAAOlK,EAASmK,mBAAmB5J,KAAKC,QAAQ4D,aAGjDtF,QAAS,SAAyBwG,EAAyB8E,EAA2BC,GAwBrF,OAAO9J,KAAKyJ,IAAIlL,EAAQA,QAAQwG,EAAK8E,EAAO7J,KAAM8J,IAAS,IAG5DC,WAAY,SAASC,GAQpBA,EAAOpE,UAGRqE,UAAW,SAASC,EAAGJ,GAsBtB,OAAO9J,KAAKyJ,IAAIpK,EAAM4K,UAAUC,EAAGjL,EAAKwG,MAAMzF,KAAM8J,KAAU,IAG/DK,YAAa,SAAoBH,GAShCA,EAAOpE,UAGRnB,cAAe,WAKd,OAAOzE,KAAKO,IAAiC,OAA1BP,KAAKO,IAAIgC,cAA0B1D,EAAYuL,UAAUpK,KAAKoB,gBAGlFiJ,YAAa,WAIZ,OAAOrK,KAAKsK,OAAmD,QAAzCxL,EAASiI,IAAI/G,KAAKC,QAAS,YAGlDsK,QAAS,SAA+DC,EAA2BC,GAsClG,IAAIC,GAAaF,EAAU7D,SAAWlH,EAASsD,KAAKyH,GACpD,IAAGE,IAAaA,EAAUC,UAAcF,GAAgC,iBAAbA,EAGtD,CAIJ,IAAIG,EAAMF,GAAc,YAAaA,EACnCA,EAAUvJ,gBAAkB,uBAAuBkB,KAAKoI,GAAY,IACpEC,EAAUvJ,cAAgBuJ,EAAUzK,QAAWxB,EAAIsE,KAAKyH,EAAWxK,KAAKoB,eAC1ExC,EAAaiM,MAAM7K,KAAKC,QAAS2K,EAAKH,IAIlCzK,KAAK6E,WAAa7E,KAAK2J,iBAAmB9E,UAC7C7E,KAAK4E,eAbN8F,EAAUC,SAAS3K,KAAMyK,GAgB1B,OAAOzK,MAGR8K,MAAO,SAASC,EAAKC,GAYpB,IAAIC,EAAQC,WAAWjM,EAAKwG,MAAMzF,KACjC,WACKiL,IAGJA,EAAQ,KACJjL,KAAKgF,YACR/F,EAAKwG,MAAMzF,KAAM+K,EAAjB9L,MAGF+L,GAAS,GAEV,OACCpF,OAAQ,WAKP,OAJGqF,IACFE,aAAaF,GACbA,EAAQ,MAEF,UAUX,OAJGlM,EAAI,cACNoB,EAAYiL,OAAO5L,GAGbW","file":"../_WidgetBase.js","sourcesContent":["define([\r\n\t\"require\", // require.toUrl\r\n\t\"dojo/_base/array\", // array.forEach array.map\r\n\t\"dojo/aspect\",\r\n\t\"dojo/_base/config\", // config.blankGif\r\n\t\"dojo/_base/connect\", // connect.connect\r\n\t\"dojo/_base/declare\", // declare\r\n\t\"dojo/dom\", // dom.byId\r\n\t\"dojo/dom-attr\", // domAttr.set domAttr.remove\r\n\t\"dojo/dom-class\", // domClass.add domClass.replace\r\n\t\"dojo/dom-construct\", // domConstruct.destroy domConstruct.place\r\n\t\"dojo/dom-geometry\", // isBodyLtr\r\n\t\"dojo/dom-style\", // domStyle.set, domStyle.get\r\n\t\"dojo/has\",\r\n\t\"dojo/_base/kernel\",\r\n\t\"dojo/_base/lang\", // mixin(), isArray(), etc.\r\n\t\"dojo/on\",\r\n\t\"dojo/ready\",\r\n\t\"dojo/Stateful\", // Stateful\r\n\t\"dojo/topic\",\r\n\t\"dojo/_base/window\", // win.body()\r\n\t\"./Destroyable\",\r\n\t\"dojo/has!dojo-bidi?./_BidiMixin\",\r\n\t\"./registry\"    // registry.getUniqueId(), registry.findWidgets()\r\n], function(require, array, aspect, config, connect, declare,\r\n\t\t\tdom, domAttr, domClass, domConstruct, domGeometry, domStyle, has, kernel,\r\n\t\t\tlang, on, ready, Stateful, topic, win, Destroyable, _BidiMixin, registry){\r\n\r\n\t// module:\r\n\t//\t\tdijit/_WidgetBase\r\n\r\n\t// Flag to make dijit load modules the app didn't explicitly request, for backwards compatibility\r\n\thas.add(\"dijit-legacy-requires\", !kernel.isAsync);\r\n\r\n\t// Flag to enable support for textdir attribute\r\n\thas.add(\"dojo-bidi\", false);\r\n\r\n\r\n\t// For back-compat, remove in 2.0.\r\n\tif(has(\"dijit-legacy-requires\")){\r\n\t\tready(0, function(){\r\n\t\t\tvar requires = [\"dijit/_base/manager\"];\r\n\t\t\trequire(requires);\t// use indirection so modules not rolled into a build\r\n\t\t});\r\n\t}\r\n\r\n\t// Nested hash listing attributes for each tag, all strings in lowercase.\r\n\t// ex: {\"div\": {\"style\": true, \"tabindex\" true}, \"form\": { ...\r\n\tvar tagAttrs = {};\r\n\r\n\tfunction getAttrs(obj){\r\n\t\tvar ret = {};\r\n\t\tfor(var attr in obj){\r\n\t\t\tret[attr.toLowerCase()] = true;\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\r\n\tfunction nonEmptyAttrToDom(attr){\r\n\t\t// summary:\r\n\t\t//\t\tReturns a setter function that copies the attribute to this.domNode,\r\n\t\t//\t\tor removes the attribute from this.domNode, depending on whether the\r\n\t\t//\t\tvalue is defined or not.\r\n\t\treturn function(val){\r\n\t\t\tdomAttr[val ? \"set\" : \"remove\"](this.domNode, attr, val);\r\n\t\t\tthis._set(attr, val);\r\n\t\t};\r\n\t}\r\n\r\n\tfunction isEqual(a, b){\r\n\t\t//\tsummary:\r\n\t\t//\t\tFunction that determines whether two values are identical,\r\n\t\t//\t\ttaking into account that NaN is not normally equal to itself\r\n\t\t//\t\tin JS.\r\n\r\n\t\treturn a === b || (/* a is NaN */ a !== a && /* b is NaN */ b !== b);\r\n\t}\r\n\r\n\tvar _WidgetBase = declare(\"dijit._WidgetBase\", [Stateful, Destroyable], {\r\n\t\t// summary:\r\n\t\t//\t\tFuture base class for all Dijit widgets.\r\n\t\t// description:\r\n\t\t//\t\tFuture base class for all Dijit widgets.\r\n\t\t//\t\t_Widget extends this class adding support for various features needed by desktop.\r\n\t\t//\r\n\t\t//\t\tProvides stubs for widget lifecycle methods for subclasses to extend, like postMixInProperties(), buildRendering(),\r\n\t\t//\t\tpostCreate(), startup(), and destroy(), and also public API methods like set(), get(), and watch().\r\n\t\t//\r\n\t\t//\t\tWidgets can provide custom setters/getters for widget attributes, which are called automatically by set(name, value).\r\n\t\t//\t\tFor an attribute XXX, define methods _setXXXAttr() and/or _getXXXAttr().\r\n\t\t//\r\n\t\t//\t\t_setXXXAttr can also be a string/hash/array mapping from a widget attribute XXX to the widget's DOMNodes:\r\n\t\t//\r\n\t\t//\t\t- DOM node attribute\r\n\t\t// |\t\t_setFocusAttr: {node: \"focusNode\", type: \"attribute\"}\r\n\t\t// |\t\t_setFocusAttr: \"focusNode\"\t(shorthand)\r\n\t\t// |\t\t_setFocusAttr: \"\"\t\t(shorthand, maps to this.domNode)\r\n\t\t//\t\tMaps this.focus to this.focusNode.focus, or (last example) this.domNode.focus\r\n\t\t//\r\n\t\t//\t\t- DOM node innerHTML\r\n\t\t//\t|\t\t_setTitleAttr: { node: \"titleNode\", type: \"innerHTML\" }\r\n\t\t//\t\tMaps this.title to this.titleNode.innerHTML\r\n\t\t//\r\n\t\t//\t\t- DOM node innerText\r\n\t\t//\t|\t\t_setTitleAttr: { node: \"titleNode\", type: \"innerText\" }\r\n\t\t//\t\tMaps this.title to this.titleNode.innerText\r\n\t\t//\r\n\t\t//\t\t- DOM node CSS class\r\n\t\t// |\t\t_setMyClassAttr: { node: \"domNode\", type: \"class\" }\r\n\t\t//\t\tMaps this.myClass to this.domNode.className\r\n\t\t//\r\n\t\t//\t\tIf the value of _setXXXAttr is an array, then each element in the array matches one of the\r\n\t\t//\t\tformats of the above list.\r\n\t\t//\r\n\t\t//\t\tIf the custom setter is null, no action is performed other than saving the new value\r\n\t\t//\t\tin the widget (in this).\r\n\t\t//\r\n\t\t//\t\tIf no custom setter is defined for an attribute, then it will be copied\r\n\t\t//\t\tto this.focusNode (if the widget defines a focusNode), or this.domNode otherwise.\r\n\t\t//\t\tThat's only done though for attributes that match DOMNode attributes (title,\r\n\t\t//\t\talt, aria-labelledby, etc.)\r\n\r\n\t\t// id: [const] String\r\n\t\t//\t\tA unique, opaque ID string that can be assigned by users or by the\r\n\t\t//\t\tsystem. If the developer passes an ID which is known not to be\r\n\t\t//\t\tunique, the specified ID is ignored and the system-generated ID is\r\n\t\t//\t\tused instead.\r\n\t\tid: \"\",\r\n\t\t_setIdAttr: \"domNode\", // to copy to this.domNode even for auto-generated id's\r\n\r\n\t\t// lang: [const] String\r\n\t\t//\t\tRarely used.  Overrides the default Dojo locale used to render this widget,\r\n\t\t//\t\tas defined by the [HTML LANG](http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang) attribute.\r\n\t\t//\t\tValue must be among the list of locales specified during by the Dojo bootstrap,\r\n\t\t//\t\tformatted according to [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt) (like en-us).\r\n\t\tlang: \"\",\r\n\t\t// set on domNode even when there's a focus node.\tbut don't set lang=\"\", since that's invalid.\r\n\t\t_setLangAttr: nonEmptyAttrToDom(\"lang\"),\r\n\r\n\t\t// dir: [const] String\r\n\t\t//\t\tBi-directional support, as defined by the [HTML DIR](http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir)\r\n\t\t//\t\tattribute. Either left-to-right \"ltr\" or right-to-left \"rtl\".  If undefined, widgets renders in page's\r\n\t\t//\t\tdefault direction.\r\n\t\tdir: \"\",\r\n\t\t// set on domNode even when there's a focus node.\tbut don't set dir=\"\", since that's invalid.\r\n\t\t_setDirAttr: nonEmptyAttrToDom(\"dir\"), // to set on domNode even when there's a focus node\r\n\r\n\t\t// class: String\r\n\t\t//\t\tHTML class attribute\r\n\t\t\"class\": \"\",\r\n\t\t_setClassAttr: { node: \"domNode\", type: \"class\" },\r\n\r\n\t\t// Override automatic assigning type --> focusNode, it causes exception on IE6-8.\r\n\t\t// Instead, type must be specified as ${type} in the template, as part of the original DOM.\r\n\t\t_setTypeAttr: null,\r\n\r\n\t\t// style: String||Object\r\n\t\t//\t\tHTML style attributes as cssText string or name/value hash\r\n\t\tstyle: \"\",\r\n\r\n\t\t// title: String\r\n\t\t//\t\tHTML title attribute.\r\n\t\t//\r\n\t\t//\t\tFor form widgets this specifies a tooltip to display when hovering over\r\n\t\t//\t\tthe widget (just like the native HTML title attribute).\r\n\t\t//\r\n\t\t//\t\tFor TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\r\n\t\t//\t\tetc., it's used to specify the tab label, accordion pane title, etc.  In this case it's\r\n\t\t//\t\tinterpreted as HTML.\r\n\t\ttitle: \"\",\r\n\r\n\t\t// tooltip: String\r\n\t\t//\t\tWhen this widget's title attribute is used to for a tab label, accordion pane title, etc.,\r\n\t\t//\t\tthis specifies the tooltip to appear when the mouse is hovered over that text.\r\n\t\ttooltip: \"\",\r\n\r\n\t\t// baseClass: [protected] String\r\n\t\t//\t\tRoot CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\r\n\t\t//\t\twidget state.\r\n\t\tbaseClass: \"\",\r\n\r\n\t\t// srcNodeRef: [readonly] DomNode\r\n\t\t//\t\tpointer to original DOM node\r\n\t\tsrcNodeRef: null,\r\n\r\n\t\t// domNode: [readonly] DomNode\r\n\t\t//\t\tThis is our visible representation of the widget! Other DOM\r\n\t\t//\t\tNodes may by assigned to other properties, usually through the\r\n\t\t//\t\ttemplate system's data-dojo-attach-point syntax, but the domNode\r\n\t\t//\t\tproperty is the canonical \"top level\" node in widget UI.\r\n\t\tdomNode: null,\r\n\r\n\t\t// containerNode: [readonly] DomNode\r\n\t\t//\t\tDesignates where children of the source DOM node will be placed.\r\n\t\t//\t\t\"Children\" in this case refers to both DOM nodes and widgets.\r\n\t\t//\t\tFor example, for myWidget:\r\n\t\t//\r\n\t\t//\t\t|\t<div data-dojo-type=myWidget>\r\n\t\t//\t\t|\t\t<b> here's a plain DOM node\r\n\t\t//\t\t|\t\t<span data-dojo-type=subWidget>and a widget</span>\r\n\t\t//\t\t|\t\t<i> and another plain DOM node </i>\r\n\t\t//\t\t|\t</div>\r\n\t\t//\r\n\t\t//\t\tcontainerNode would point to:\r\n\t\t//\r\n\t\t//\t\t|\t\t<b> here's a plain DOM node\r\n\t\t//\t\t|\t\t<span data-dojo-type=subWidget>and a widget</span>\r\n\t\t//\t\t|\t\t<i> and another plain DOM node </i>\r\n\t\t//\r\n\t\t//\t\tIn templated widgets, \"containerNode\" is set via a\r\n\t\t//\t\tdata-dojo-attach-point assignment.\r\n\t\t//\r\n\t\t//\t\tcontainerNode must be defined for any widget that accepts innerHTML\r\n\t\t//\t\t(like ContentPane or BorderContainer or even Button), and conversely\r\n\t\t//\t\tis null for widgets that don't, like TextBox.\r\n\t\tcontainerNode: null,\r\n\r\n\t\t// ownerDocument: [const] Document?\r\n\t\t//\t\tThe document this widget belongs to.  If not specified to constructor, will default to\r\n\t\t//\t\tsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global\r\n\t\townerDocument: null,\r\n\t\t_setOwnerDocumentAttr: function(val){\r\n\t\t\t// this setter is merely to avoid automatically trying to set this.domNode.ownerDocument\r\n\t\t\tthis._set(\"ownerDocument\", val);\r\n\t\t},\r\n\r\n\t\t/*=====\r\n\t\t// _started: [readonly] Boolean\r\n\t\t//\t\tstartup() has completed.\r\n\t\t_started: false,\r\n\t\t=====*/\r\n\r\n\t\t// attributeMap: [protected] Object\r\n\t\t//\t\tDeprecated.\tInstead of attributeMap, widget should have a _setXXXAttr attribute\r\n\t\t//\t\tfor each XXX attribute to be mapped to the DOM.\r\n\t\t//\r\n\t\t//\t\tattributeMap sets up a \"binding\" between attributes (aka properties)\r\n\t\t//\t\tof the widget and the widget's DOM.\r\n\t\t//\t\tChanges to widget attributes listed in attributeMap will be\r\n\t\t//\t\treflected into the DOM.\r\n\t\t//\r\n\t\t//\t\tFor example, calling set('title', 'hello')\r\n\t\t//\t\ton a TitlePane will automatically cause the TitlePane's DOM to update\r\n\t\t//\t\twith the new title.\r\n\t\t//\r\n\t\t//\t\tattributeMap is a hash where the key is an attribute of the widget,\r\n\t\t//\t\tand the value reflects a binding to a:\r\n\t\t//\r\n\t\t//\t\t- DOM node attribute\r\n\t\t// |\t\tfocus: {node: \"focusNode\", type: \"attribute\"}\r\n\t\t//\t\tMaps this.focus to this.focusNode.focus\r\n\t\t//\r\n\t\t//\t\t- DOM node innerHTML\r\n\t\t//\t|\t\ttitle: { node: \"titleNode\", type: \"innerHTML\" }\r\n\t\t//\t\tMaps this.title to this.titleNode.innerHTML\r\n\t\t//\r\n\t\t//\t\t- DOM node innerText\r\n\t\t//\t|\t\ttitle: { node: \"titleNode\", type: \"innerText\" }\r\n\t\t//\t\tMaps this.title to this.titleNode.innerText\r\n\t\t//\r\n\t\t//\t\t- DOM node CSS class\r\n\t\t// |\t\tmyClass: { node: \"domNode\", type: \"class\" }\r\n\t\t//\t\tMaps this.myClass to this.domNode.className\r\n\t\t//\r\n\t\t//\t\tIf the value is an array, then each element in the array matches one of the\r\n\t\t//\t\tformats of the above list.\r\n\t\t//\r\n\t\t//\t\tThere are also some shorthands for backwards compatibility:\r\n\t\t//\r\n\t\t//\t\t- string --> { node: string, type: \"attribute\" }, for example:\r\n\t\t//\r\n\t\t//\t|\t\"focusNode\" ---> { node: \"focusNode\", type: \"attribute\" }\r\n\t\t//\r\n\t\t//\t\t- \"\" --> { node: \"domNode\", type: \"attribute\" }\r\n\t\tattributeMap: {},\r\n\r\n\t\t// _blankGif: [protected] String\r\n\t\t//\t\tPath to a blank 1x1 image.\r\n\t\t//\t\tUsed by `<img>` nodes in templates that really get their image via CSS background-image.\r\n\t\t_blankGif: config.blankGif || require.toUrl(\"dojo/resources/blank.gif\"),\r\n\r\n\t\t//////////// INITIALIZATION METHODS ///////////////////////////////////////\r\n\r\n\t\t/*=====\r\n\t\tconstructor: function(params, srcNodeRef){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCreate the widget.\r\n\t\t\t// params: Object|null\r\n\t\t\t//\t\tHash of initialization parameters for widget, including scalar values (like title, duration etc.)\r\n\t\t\t//\t\tand functions, typically callbacks like onClick.\r\n\t\t\t//\t\tThe hash can contain any of the widget's properties, excluding read-only properties.\r\n\t\t\t// srcNodeRef: DOMNode|String?\r\n\t\t\t//\t\tIf a srcNodeRef (DOM node) is specified:\r\n\t\t\t//\r\n\t\t\t//\t\t- use srcNodeRef.innerHTML as my contents\r\n\t\t\t//\t\t- if this is a behavioral widget then apply behavior to that srcNodeRef\r\n\t\t\t//\t\t- otherwise, replace srcNodeRef with my generated DOM tree\r\n\t\t},\r\n\t\t=====*/\r\n\r\n\t\t_introspect: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCollect metadata about this widget (only once per class, not once per instance):\r\n\t\t\t//\r\n\t\t\t//\t\t\t- list of attributes with custom setters, storing in this.constructor._setterAttrs\r\n\t\t\t//\t\t\t- generate this.constructor._onMap, mapping names like \"mousedown\" to functions like onMouseDown\r\n\r\n\t\t\tvar ctor = this.constructor;\r\n\t\t\tif(!ctor._setterAttrs){\r\n\t\t\t\tvar proto = ctor.prototype,\r\n\t\t\t\t\tattrs = ctor._setterAttrs = [], // attributes with custom setters\r\n\t\t\t\t\tonMap = (ctor._onMap = {});\r\n\r\n\t\t\t\t// Items in this.attributeMap are like custom setters.  For back-compat, remove for 2.0.\r\n\t\t\t\tfor(var name in proto.attributeMap){\r\n\t\t\t\t\tattrs.push(name);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Loop over widget properties, collecting properties with custom setters and filling in ctor._onMap.\r\n\t\t\t\tfor(name in proto){\r\n\t\t\t\t\tif(/^on/.test(name)){\r\n\t\t\t\t\t\tonMap[name.substring(2).toLowerCase()] = name;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif(/^_set[A-Z](.*)Attr$/.test(name)){\r\n\t\t\t\t\t\tname = name.charAt(4).toLowerCase() + name.substr(5, name.length - 9);\r\n\t\t\t\t\t\tif(!proto.attributeMap || !(name in proto.attributeMap)){\r\n\t\t\t\t\t\t\tattrs.push(name);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Note: this isn't picking up info on properties like aria-label and role, that don't have custom setters\r\n\t\t\t\t// but that set() maps to attributes on this.domNode or this.focusNode\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tpostscript: function(/*Object?*/params, /*DomNode|String*/srcNodeRef){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tKicks off widget instantiation.  See create() for details.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\r\n\t\t\t// Note that we skip calling this.inherited(), i.e. dojo/Stateful::postscript(), because 1.x widgets don't\r\n\t\t\t// expect their custom setters to get called until after buildRendering().  Consider changing for 2.0.\r\n\r\n\t\t\tthis.create(params, srcNodeRef);\r\n\t\t},\r\n\r\n\t\tcreate: function(params, srcNodeRef){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tKick off the life-cycle of a widget\r\n\t\t\t// description:\r\n\t\t\t//\t\tCreate calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\r\n\t\t\t//\t\tetc.), some of which of you'll want to override. See http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\r\n\t\t\t//\t\tfor a discussion of the widget creation lifecycle.\r\n\t\t\t//\r\n\t\t\t//\t\tOf course, adventurous developers could override create entirely, but this should\r\n\t\t\t//\t\tonly be done as a last resort.\r\n\t\t\t// params: Object|null\r\n\t\t\t//\t\tHash of initialization parameters for widget, including scalar values (like title, duration etc.)\r\n\t\t\t//\t\tand functions, typically callbacks like onClick.\r\n\t\t\t//\t\tThe hash can contain any of the widget's properties, excluding read-only properties.\r\n\t\t\t// srcNodeRef: DOMNode|String?\r\n\t\t\t//\t\tIf a srcNodeRef (DOM node) is specified:\r\n\t\t\t//\r\n\t\t\t//\t\t- use srcNodeRef.innerHTML as my contents\r\n\t\t\t//\t\t- if this is a behavioral widget then apply behavior to that srcNodeRef\r\n\t\t\t//\t\t- otherwise, replace srcNodeRef with my generated DOM tree\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\r\n\t\t\t// First time widget is instantiated, scan prototype to figure out info about custom setters etc.\r\n\t\t\tthis._introspect();\r\n\r\n\t\t\t// store pointer to original DOM tree\r\n\t\t\tthis.srcNodeRef = dom.byId(srcNodeRef);\r\n\r\n\t\t\t// No longer used, remove for 2.0.\r\n\t\t\tthis._connects = [];\r\n\t\t\tthis._supportingWidgets = [];\r\n\r\n\t\t\t// this is here for back-compat, remove in 2.0 (but check NodeList-instantiate.html test)\r\n\t\t\tif(this.srcNodeRef && (typeof this.srcNodeRef.id == \"string\")){\r\n\t\t\t\tthis.id = this.srcNodeRef.id;\r\n\t\t\t}\r\n\r\n\t\t\t// mix in our passed parameters\r\n\t\t\tif(params){\r\n\t\t\t\tthis.params = params;\r\n\t\t\t\tlang.mixin(this, params);\r\n\t\t\t}\r\n\t\t\tthis.postMixInProperties();\r\n\r\n\t\t\t// Generate an id for the widget if one wasn't specified, or it was specified as id: undefined.\r\n\t\t\t// Do this before buildRendering() because it might expect the id to be there.\r\n\t\t\tif(!this.id){\r\n\t\t\t\tthis.id = registry.getUniqueId(this.declaredClass.replace(/\\./g, \"_\"));\r\n\t\t\t\tif(this.params){\r\n\t\t\t\t\t// if params contains {id: undefined}, prevent _applyAttributes() from processing it\r\n\t\t\t\t\tdelete this.params.id;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// The document and <body> node this widget is associated with\r\n\t\t\tthis.ownerDocument = this.ownerDocument || (this.srcNodeRef ? this.srcNodeRef.ownerDocument : document);\r\n\t\t\tthis.ownerDocumentBody = win.body(this.ownerDocument);\r\n\r\n\t\t\tregistry.add(this);\r\n\r\n\t\t\tthis.buildRendering();\r\n\r\n\t\t\tvar deleteSrcNodeRef;\r\n\r\n\t\t\tif(this.domNode){\r\n\t\t\t\t// Copy attributes listed in attributeMap into the [newly created] DOM for the widget.\r\n\t\t\t\t// Also calls custom setters for all attributes with custom setters.\r\n\t\t\t\tthis._applyAttributes();\r\n\r\n\t\t\t\t// If srcNodeRef was specified, then swap out original srcNode for this widget's DOM tree.\r\n\t\t\t\t// For 2.0, move this after postCreate().  postCreate() shouldn't depend on the\r\n\t\t\t\t// widget being attached to the DOM since it isn't when a widget is created programmatically like\r\n\t\t\t\t// new MyWidget({}).\tSee #11635.\r\n\t\t\t\tvar source = this.srcNodeRef;\r\n\t\t\t\tif(source && source.parentNode && this.domNode !== source){\r\n\t\t\t\t\tsource.parentNode.replaceChild(this.domNode, source);\r\n\t\t\t\t\tdeleteSrcNodeRef = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Note: for 2.0 may want to rename widgetId to dojo._scopeName + \"_widgetId\",\r\n\t\t\t\t// assuming that dojo._scopeName even exists in 2.0\r\n\t\t\t\tthis.domNode.setAttribute(\"widgetId\", this.id);\r\n\t\t\t}\r\n\t\t\tthis.postCreate();\r\n\r\n\t\t\t// If srcNodeRef has been processed and removed from the DOM (e.g. TemplatedWidget) then delete it to allow GC.\r\n\t\t\t// I think for back-compatibility it isn't deleting srcNodeRef until after postCreate() has run.\r\n\t\t\tif(deleteSrcNodeRef){\r\n\t\t\t\tdelete this.srcNodeRef;\r\n\t\t\t}\r\n\r\n\t\t\tthis._created = true;\r\n\t\t},\r\n\r\n\t\t_applyAttributes: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tStep during widget creation to copy  widget attributes to the\r\n\t\t\t//\t\tDOM according to attributeMap and _setXXXAttr objects, and also to call\r\n\t\t\t//\t\tcustom _setXXXAttr() methods.\r\n\t\t\t//\r\n\t\t\t//\t\tSkips over blank/false attribute values, unless they were explicitly specified\r\n\t\t\t//\t\tas parameters to the widget, since those are the default anyway,\r\n\t\t\t//\t\tand setting tabIndex=\"\" is different than not setting tabIndex at all.\r\n\t\t\t//\r\n\t\t\t//\t\tFor backwards-compatibility reasons attributeMap overrides _setXXXAttr when\r\n\t\t\t//\t\t_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\r\n\t\t\t// Call this.set() for each property that was either specified as parameter to constructor,\r\n\t\t\t// or is in the list found above.\tFor correlated properties like value and displayedValue, the one\r\n\t\t\t// specified as a parameter should take precedence.\r\n\t\t\t// Particularly important for new DateTextBox({displayedValue: ...}) since DateTextBox's default value is\r\n\t\t\t// NaN and thus is not ignored like a default value of \"\".\r\n\r\n\t\t\t// Step 1: Save the current values of the widget properties that were specified as parameters to the constructor.\r\n\t\t\t// Generally this.foo == this.params.foo, except if postMixInProperties() changed the value of this.foo.\r\n\t\t\tvar params = {};\r\n\t\t\tfor(var key in this.params || {}){\r\n\t\t\t\tparams[key] = this._get(key);\r\n\t\t\t}\r\n\r\n\t\t\t// Step 2: Call set() for each property with a non-falsy value that wasn't passed as a parameter to the constructor\r\n\t\t\tarray.forEach(this.constructor._setterAttrs, function(key){\r\n\t\t\t\tif(!(key in params)){\r\n\t\t\t\t\tvar val = this._get(key);\r\n\t\t\t\t\tif(val){\r\n\t\t\t\t\t\tthis.set(key, val);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}, this);\r\n\r\n\t\t\t// Step 3: Call set() for each property that was specified as parameter to constructor.\r\n\t\t\t// Use params hash created above to ignore side effects from step #2 above.\r\n\t\t\tfor(key in params){\r\n\t\t\t\tthis.set(key, params[key]);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tpostMixInProperties: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCalled after the parameters to the widget have been read-in,\r\n\t\t\t//\t\tbut before the widget template is instantiated. Especially\r\n\t\t\t//\t\tuseful to set properties that are referenced in the widget\r\n\t\t\t//\t\ttemplate.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\t\t},\r\n\r\n\t\tbuildRendering: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tConstruct the UI for this widget, setting this.domNode.\r\n\t\t\t//\t\tMost widgets will mixin `dijit._TemplatedMixin`, which implements this method.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\r\n\t\t\tif(!this.domNode){\r\n\t\t\t\t// Create root node if it wasn't created by _TemplatedMixin\r\n\t\t\t\tthis.domNode = this.srcNodeRef || this.ownerDocument.createElement(\"div\");\r\n\t\t\t}\r\n\r\n\t\t\t// baseClass is a single class name or occasionally a space-separated list of names.\r\n\t\t\t// Add those classes to the DOMNode.  If RTL mode then also add with Rtl suffix.\r\n\t\t\t// TODO: make baseClass custom setter\r\n\t\t\tif(this.baseClass){\r\n\t\t\t\tvar classes = this.baseClass.split(\" \");\r\n\t\t\t\tif(!this.isLeftToRight()){\r\n\t\t\t\t\tclasses = classes.concat(array.map(classes, function(name){\r\n\t\t\t\t\t\treturn name + \"Rtl\";\r\n\t\t\t\t\t}));\r\n\t\t\t\t}\r\n\t\t\t\tdomClass.add(this.domNode, classes);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tpostCreate: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tProcessing after the DOM fragment is created\r\n\t\t\t// description:\r\n\t\t\t//\t\tCalled after the DOM fragment has been created, but not necessarily\r\n\t\t\t//\t\tadded to the document.  Do not include any operations which rely on\r\n\t\t\t//\t\tnode dimensions or placement.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\t\t},\r\n\r\n\t\tstartup: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tProcessing after the DOM fragment is added to the document\r\n\t\t\t// description:\r\n\t\t\t//\t\tCalled after a widget and its children have been created and added to the page,\r\n\t\t\t//\t\tand all related widgets have finished their create() cycle, up through postCreate().\r\n\t\t\t//\r\n\t\t\t//\t\tNote that startup() may be called while the widget is still hidden, for example if the widget is\r\n\t\t\t//\t\tinside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.\r\n\t\t\t//\t\tFor widgets that need to do layout, it's best to put that layout code inside resize(), and then\r\n\t\t\t//\t\textend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.\r\n\t\t\tif(this._started){\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tthis._started = true;\r\n\t\t\tarray.forEach(this.getChildren(), function(obj){\r\n\t\t\t\tif(!obj._started && !obj._destroyed && lang.isFunction(obj.startup)){\r\n\t\t\t\t\tobj.startup();\r\n\t\t\t\t\tobj._started = true;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t//////////// DESTROY FUNCTIONS ////////////////////////////////\r\n\r\n\t\tdestroyRecursive: function(/*Boolean?*/ preserveDom){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tDestroy this widget and its descendants\r\n\t\t\t// description:\r\n\t\t\t//\t\tThis is the generic \"destructor\" function that all widget users\r\n\t\t\t//\t\tshould call to cleanly discard with a widget. Once a widget is\r\n\t\t\t//\t\tdestroyed, it is removed from the manager object.\r\n\t\t\t// preserveDom:\r\n\t\t\t//\t\tIf true, this method will leave the original DOM structure\r\n\t\t\t//\t\talone of descendant Widgets. Note: This will NOT work with\r\n\t\t\t//\t\tdijit._TemplatedMixin widgets.\r\n\r\n\t\t\tthis._beingDestroyed = true;\r\n\t\t\tthis.destroyDescendants(preserveDom);\r\n\t\t\tthis.destroy(preserveDom);\r\n\t\t},\r\n\r\n\t\tdestroy: function(/*Boolean*/ preserveDom){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tDestroy this widget, but not its descendants.  Descendants means widgets inside of\r\n\t\t\t//\t\tthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\r\n\t\t\t//\r\n\t\t\t//\t\tThis method will also destroy internal widgets such as those created from a template,\r\n\t\t\t//\t\tassuming those widgets exist inside of this.domNode but outside of this.containerNode.\r\n\t\t\t//\r\n\t\t\t//\t\tFor 2.0 it's planned that this method will also destroy descendant widgets, so apps should not\r\n\t\t\t//\t\tdepend on the current ability to destroy a widget without destroying its descendants.   Generally\r\n\t\t\t//\t\tthey should use destroyRecursive() for widgets with children.\r\n\t\t\t// preserveDom: Boolean\r\n\t\t\t//\t\tIf true, this method will leave the original DOM structure alone.\r\n\t\t\t//\t\tNote: This will not yet work with _TemplatedMixin widgets\r\n\r\n\t\t\tthis._beingDestroyed = true;\r\n\t\t\tthis.uninitialize();\r\n\r\n\t\t\tfunction destroy(w){\r\n\t\t\t\tif(w.destroyRecursive){\r\n\t\t\t\t\tw.destroyRecursive(preserveDom);\r\n\t\t\t\t}else if(w.destroy){\r\n\t\t\t\t\tw.destroy(preserveDom);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Back-compat, remove for 2.0\r\n\t\t\tarray.forEach(this._connects, lang.hitch(this, \"disconnect\"));\r\n\t\t\tarray.forEach(this._supportingWidgets, destroy);\r\n\r\n\t\t\t// Destroy supporting widgets, but not child widgets under this.containerNode (for 2.0, destroy child widgets\r\n\t\t\t// here too).   if() statement is to guard against exception if destroy() called multiple times (see #15815).\r\n\t\t\tif(this.domNode){\r\n\t\t\t\tarray.forEach(registry.findWidgets(this.domNode, this.containerNode), destroy);\r\n\t\t\t}\r\n\r\n\t\t\tthis.destroyRendering(preserveDom);\r\n\t\t\tregistry.remove(this.id);\r\n\t\t\tthis._destroyed = true;\r\n\t\t},\r\n\r\n\t\tdestroyRendering: function(/*Boolean?*/ preserveDom){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tDestroys the DOM nodes associated with this widget.\r\n\t\t\t// preserveDom:\r\n\t\t\t//\t\tIf true, this method will leave the original DOM structure alone\r\n\t\t\t//\t\tduring tear-down. Note: this will not work with _Templated\r\n\t\t\t//\t\twidgets yet.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\r\n\t\t\tif(this.bgIframe){\r\n\t\t\t\tthis.bgIframe.destroy(preserveDom);\r\n\t\t\t\tdelete this.bgIframe;\r\n\t\t\t}\r\n\r\n\t\t\tif(this.domNode){\r\n\t\t\t\tif(preserveDom){\r\n\t\t\t\t\tdomAttr.remove(this.domNode, \"widgetId\");\r\n\t\t\t\t}else{\r\n\t\t\t\t\tdomConstruct.destroy(this.domNode);\r\n\t\t\t\t}\r\n\t\t\t\tdelete this.domNode;\r\n\t\t\t}\r\n\r\n\t\t\tif(this.srcNodeRef){\r\n\t\t\t\tif(!preserveDom){\r\n\t\t\t\t\tdomConstruct.destroy(this.srcNodeRef);\r\n\t\t\t\t}\r\n\t\t\t\tdelete this.srcNodeRef;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tdestroyDescendants: function(/*Boolean?*/ preserveDom){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tRecursively destroy the children of this widget and their\r\n\t\t\t//\t\tdescendants.\r\n\t\t\t// preserveDom:\r\n\t\t\t//\t\tIf true, the preserveDom attribute is passed to all descendant\r\n\t\t\t//\t\twidget's .destroy() method. Not for use with _Templated\r\n\t\t\t//\t\twidgets.\r\n\r\n\t\t\t// get all direct descendants and destroy them recursively\r\n\t\t\tarray.forEach(this.getChildren(), function(widget){\r\n\t\t\t\tif(widget.destroyRecursive){\r\n\t\t\t\t\twidget.destroyRecursive(preserveDom);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\tuninitialize: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tDeprecated. Override destroy() instead to implement custom widget tear-down\r\n\t\t\t//\t\tbehavior.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\t////////////////// GET/SET, CUSTOM SETTERS, ETC. ///////////////////\r\n\r\n\t\t_setStyleAttr: function(/*String||Object*/ value){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSets the style attribute of the widget according to value,\r\n\t\t\t//\t\twhich is either a hash like {height: \"5px\", width: \"3px\"}\r\n\t\t\t//\t\tor a plain string\r\n\t\t\t// description:\r\n\t\t\t//\t\tDetermines which node to set the style on based on style setting\r\n\t\t\t//\t\tin attributeMap.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\r\n\t\t\tvar mapNode = this.domNode;\r\n\r\n\t\t\t// Note: technically we should revert any style setting made in a previous call\r\n\t\t\t// to his method, but that's difficult to keep track of.\r\n\r\n\t\t\tif(lang.isObject(value)){\r\n\t\t\t\tdomStyle.set(mapNode, value);\r\n\t\t\t}else{\r\n\t\t\t\tif(mapNode.style.cssText){\r\n\t\t\t\t\tmapNode.style.cssText += \"; \" + value;\r\n\t\t\t\t}else{\r\n\t\t\t\t\tmapNode.style.cssText = value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis._set(\"style\", value);\r\n\t\t},\r\n\r\n\t\t_attrToDom: function(/*String*/ attr, /*String*/ value, /*Object?*/ commands){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReflect a widget attribute (title, tabIndex, duration etc.) to\r\n\t\t\t//\t\tthe widget DOM, as specified by commands parameter.\r\n\t\t\t//\t\tIf commands isn't specified then it's looked up from attributeMap.\r\n\t\t\t//\t\tNote some attributes like \"type\"\r\n\t\t\t//\t\tcannot be processed this way as they are not mutable.\r\n\t\t\t// attr:\r\n\t\t\t//\t\tName of member variable (ex: \"focusNode\" maps to this.focusNode) pointing\r\n\t\t\t//\t\tto DOMNode inside the widget, or alternately pointing to a subwidget\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\r\n\t\t\tcommands = arguments.length >= 3 ? commands : this.attributeMap[attr];\r\n\r\n\t\t\tarray.forEach(lang.isArray(commands) ? commands : [commands], function(command){\r\n\r\n\t\t\t\t// Get target node and what we are doing to that node\r\n\t\t\t\tvar mapNode = this[command.node || command || \"domNode\"];\t// DOM node\r\n\t\t\t\tvar type = command.type || \"attribute\";\t// class, innerHTML, innerText, or attribute\r\n\r\n\t\t\t\tswitch(type){\r\n\t\t\t\t\tcase \"attribute\":\r\n\t\t\t\t\t\tif(lang.isFunction(value)){ // functions execute in the context of the widget\r\n\t\t\t\t\t\t\tvalue = lang.hitch(this, value);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Get the name of the DOM node attribute; usually it's the same\r\n\t\t\t\t\t\t// as the name of the attribute in the widget (attr), but can be overridden.\r\n\t\t\t\t\t\t// Also maps handler names to lowercase, like onSubmit --> onsubmit\r\n\t\t\t\t\t\tvar attrName = command.attribute ? command.attribute :\r\n\t\t\t\t\t\t\t(/^on[A-Z][a-zA-Z]*$/.test(attr) ? attr.toLowerCase() : attr);\r\n\r\n\t\t\t\t\t\tif(mapNode.tagName){\r\n\t\t\t\t\t\t\t// Normal case, mapping to a DOMNode.  Note that modern browsers will have a mapNode.set()\r\n\t\t\t\t\t\t\t// method, but for consistency we still call domAttr\r\n\t\t\t\t\t\t\tdomAttr.set(mapNode, attrName, value);\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t// mapping to a sub-widget\r\n\t\t\t\t\t\t\tmapNode.set(attrName, value);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"innerText\":\r\n\t\t\t\t\t\tmapNode.innerHTML = \"\";\r\n\t\t\t\t\t\tmapNode.appendChild(this.ownerDocument.createTextNode(value));\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"innerHTML\":\r\n\t\t\t\t\t\tmapNode.innerHTML = value;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"class\":\r\n\t\t\t\t\t\tdomClass.replace(mapNode, value, this[attr]);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}, this);\r\n\t\t},\r\n\r\n\t\tget: function(name){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tGet a property from a widget.\r\n\t\t\t// name:\r\n\t\t\t//\t\tThe property to get.\r\n\t\t\t// description:\r\n\t\t\t//\t\tGet a named property from a widget. The property may\r\n\t\t\t//\t\tpotentially be retrieved via a getter method. If no getter is defined, this\r\n\t\t\t//\t\tjust retrieves the object's property.\r\n\t\t\t//\r\n\t\t\t//\t\tFor example, if the widget has properties `foo` and `bar`\r\n\t\t\t//\t\tand a method named `_getFooAttr()`, calling:\r\n\t\t\t//\t\t`myWidget.get(\"foo\")` would be equivalent to calling\r\n\t\t\t//\t\t`widget._getFooAttr()` and `myWidget.get(\"bar\")`\r\n\t\t\t//\t\twould be equivalent to the expression\r\n\t\t\t//\t\t`widget.bar2`\r\n\t\t\tvar names = this._getAttrNames(name);\r\n\t\t\treturn this[names.g] ? this[names.g]() : this._get(name);\r\n\t\t},\r\n\r\n\t\tset: function(name, value){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSet a property on a widget\r\n\t\t\t// name:\r\n\t\t\t//\t\tThe property to set.\r\n\t\t\t// value:\r\n\t\t\t//\t\tThe value to set in the property.\r\n\t\t\t// description:\r\n\t\t\t//\t\tSets named properties on a widget which may potentially be handled by a\r\n\t\t\t//\t\tsetter in the widget.\r\n\t\t\t//\r\n\t\t\t//\t\tFor example, if the widget has properties `foo` and `bar`\r\n\t\t\t//\t\tand a method named `_setFooAttr()`, calling\r\n\t\t\t//\t\t`myWidget.set(\"foo\", \"Howdy!\")` would be equivalent to calling\r\n\t\t\t//\t\t`widget._setFooAttr(\"Howdy!\")` and `myWidget.set(\"bar\", 3)`\r\n\t\t\t//\t\twould be equivalent to the statement `widget.bar = 3;`\r\n\t\t\t//\r\n\t\t\t//\t\tset() may also be called with a hash of name/value pairs, ex:\r\n\t\t\t//\r\n\t\t\t//\t|\tmyWidget.set({\r\n\t\t\t//\t|\t\tfoo: \"Howdy\",\r\n\t\t\t//\t|\t\tbar: 3\r\n\t\t\t//\t|\t});\r\n\t\t\t//\r\n\t\t\t//\tThis is equivalent to calling `set(foo, \"Howdy\")` and `set(bar, 3)`\r\n\r\n\t\t\tif(typeof name === \"object\"){\r\n\t\t\t\tfor(var x in name){\r\n\t\t\t\t\tthis.set(x, name[x]);\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t}\r\n\t\t\tvar names = this._getAttrNames(name),\r\n\t\t\t\tsetter = this[names.s];\r\n\t\t\tif(lang.isFunction(setter)){\r\n\t\t\t\t// use the explicit setter\r\n\t\t\t\tvar result = setter.apply(this, Array.prototype.slice.call(arguments, 1));\r\n\t\t\t}else{\r\n\t\t\t\t// Mapping from widget attribute to DOMNode/subwidget attribute/value/etc.\r\n\t\t\t\t// Map according to:\r\n\t\t\t\t//\t\t1. attributeMap setting, if one exists (TODO: attributeMap deprecated, remove in 2.0)\r\n\t\t\t\t//\t\t2. _setFooAttr: {...} type attribute in the widget (if one exists)\r\n\t\t\t\t//\t\t3. apply to focusNode or domNode if standard attribute name, excluding funcs like onClick.\r\n\t\t\t\t// Checks if an attribute is a \"standard attribute\" by whether the DOMNode JS object has a similar\r\n\t\t\t\t// attribute name (ex: accept-charset attribute matches jsObject.acceptCharset).\r\n\t\t\t\t// Note also that Tree.focusNode() is a function not a DOMNode, so test for that.\r\n\t\t\t\tvar defaultNode = this.focusNode && !lang.isFunction(this.focusNode) ? \"focusNode\" : \"domNode\",\r\n\t\t\t\t\ttag = this[defaultNode] && this[defaultNode].tagName,\r\n\t\t\t\t\tattrsForTag = tag && (tagAttrs[tag] || (tagAttrs[tag] = getAttrs(this[defaultNode]))),\r\n\t\t\t\t\tmap = name in this.attributeMap ? this.attributeMap[name] :\r\n\t\t\t\t\t\tnames.s in this ? this[names.s] :\r\n\t\t\t\t\t\t\t((attrsForTag && names.l in attrsForTag && typeof value != \"function\") ||\r\n\t\t\t\t\t\t\t\t/^aria-|^data-|^role$/.test(name)) ? defaultNode : null;\r\n\t\t\t\tif(map != null){\r\n\t\t\t\t\tthis._attrToDom(name, value, map);\r\n\t\t\t\t}\r\n\t\t\t\tthis._set(name, value);\r\n\t\t\t}\r\n\t\t\treturn result || this;\r\n\t\t},\r\n\r\n\t\t_attrPairNames: {}, // shared between all widgets\r\n\t\t_getAttrNames: function(name){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tHelper function for get() and set().\r\n\t\t\t//\t\tCaches attribute name values so we don't do the string ops every time.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\r\n\t\t\tvar apn = this._attrPairNames;\r\n\t\t\tif(apn[name]){\r\n\t\t\t\treturn apn[name];\r\n\t\t\t}\r\n\t\t\tvar uc = name.replace(/^[a-z]|-[a-zA-Z]/g, function(c){\r\n\t\t\t\treturn c.charAt(c.length - 1).toUpperCase();\r\n\t\t\t});\r\n\t\t\treturn (apn[name] = {\r\n\t\t\t\tn: name + \"Node\",\r\n\t\t\t\ts: \"_set\" + uc + \"Attr\", // converts dashes to camel case, ex: accept-charset --> _setAcceptCharsetAttr\r\n\t\t\t\tg: \"_get\" + uc + \"Attr\",\r\n\t\t\t\tl: uc.toLowerCase()        // lowercase name w/out dashes, ex: acceptcharset\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t_set: function(/*String*/ name, /*anything*/ value){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tHelper function to set new value for specified property, and call handlers\r\n\t\t\t//\t\tregistered with watch() if the value has changed.\r\n\t\t\tvar oldValue = this[name];\r\n\t\t\tthis[name] = value;\r\n\t\t\tif(this._created && !isEqual(oldValue, value)){\r\n\t\t\t\tif(this._watchCallbacks){\r\n\t\t\t\t\tthis._watchCallbacks(name, oldValue, value);\r\n\t\t\t\t}\r\n\t\t\t\tthis.emit(\"attrmodified-\" + name, {\r\n\t\t\t\t\tdetail: {\r\n\t\t\t\t\t\tprevValue: oldValue,\r\n\t\t\t\t\t\tnewValue: value\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_get: function(/*String*/ name){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tHelper function to get value for specified property stored by this._set(),\r\n\t\t\t//\t\ti.e. for properties with custom setters.  Used mainly by custom getters.\r\n\t\t\t//\r\n\t\t\t//\t\tFor example, CheckBox._getValueAttr() calls this._get(\"value\").\r\n\r\n\t\t\t// future: return name in this.props ? this.props[name] : this[name];\r\n\t\t\treturn this[name];\r\n\t\t},\r\n\r\n\t\temit: function(/*String*/ type, /*Object?*/ eventObj, /*Array?*/ callbackArgs){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tUsed by widgets to signal that a synthetic event occurred, ex:\r\n\t\t\t//\t|\tmyWidget.emit(\"attrmodified-selectedChildWidget\", {}).\r\n\t\t\t//\r\n\t\t\t//\t\tEmits an event on this.domNode named type.toLowerCase(), based on eventObj.\r\n\t\t\t//\t\tAlso calls onType() method, if present, and returns value from that method.\r\n\t\t\t//\t\tBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\r\n\t\t\t//\t\tModifies eventObj by adding missing parameters (bubbles, cancelable, widget).\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\r\n\t\t\t// Specify fallback values for bubbles, cancelable in case they are not set in eventObj.\r\n\t\t\t// Also set pointer to widget, although since we can't add a pointer to the widget for native events\r\n\t\t\t// (see #14729), maybe we shouldn't do it here?\r\n\t\t\teventObj = eventObj || {};\r\n\t\t\tif(eventObj.bubbles === undefined){\r\n\t\t\t\teventObj.bubbles = true;\r\n\t\t\t}\r\n\t\t\tif(eventObj.cancelable === undefined){\r\n\t\t\t\teventObj.cancelable = true;\r\n\t\t\t}\r\n\t\t\tif(!eventObj.detail){\r\n\t\t\t\teventObj.detail = {};\r\n\t\t\t}\r\n\t\t\teventObj.detail.widget = this;\r\n\r\n\t\t\tvar ret, callback = this[\"on\" + type];\r\n\t\t\tif(callback){\r\n\t\t\t\tret = callback.apply(this, callbackArgs ? callbackArgs : [eventObj]);\r\n\t\t\t}\r\n\r\n\t\t\t// Emit event, but avoid spurious emit()'s as parent sets properties on child during startup/destroy\r\n\t\t\tif(this._started && !this._beingDestroyed){\r\n\t\t\t\ton.emit(this.domNode, type.toLowerCase(), eventObj);\r\n\t\t\t}\r\n\r\n\t\t\treturn ret;\r\n\t\t},\r\n\r\n\t\ton: function(/*String|Function*/ type, /*Function*/ func){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCall specified function when event occurs, ex: myWidget.on(\"click\", function(){ ... }).\r\n\t\t\t// type:\r\n\t\t\t//\t\tName of event (ex: \"click\") or extension event like touch.press.\r\n\t\t\t// description:\r\n\t\t\t//\t\tCall specified function when event `type` occurs, ex: `myWidget.on(\"click\", function(){ ... })`.\r\n\t\t\t//\t\tNote that the function is not run in any particular scope, so if (for example) you want it to run in the\r\n\t\t\t//\t\twidget's scope you must do `myWidget.on(\"click\", lang.hitch(myWidget, func))`.\r\n\r\n\t\t\t// For backwards compatibility, if there's an onType() method in the widget then connect to that.\r\n\t\t\t// Remove in 2.0.\r\n\t\t\tvar widgetMethod = this._onMap(type);\r\n\t\t\tif(widgetMethod){\r\n\t\t\t\treturn aspect.after(this, widgetMethod, func, true);\r\n\t\t\t}\r\n\r\n\t\t\t// Otherwise, just listen for the event on this.domNode.\r\n\t\t\treturn this.own(on(this.domNode, type, func))[0];\r\n\t\t},\r\n\r\n\t\t_onMap: function(/*String|Function*/ type){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tMaps on() type parameter (ex: \"mousemove\") to method name (ex: \"onMouseMove\").\r\n\t\t\t//\t\tIf type is a synthetic event like touch.press then returns undefined.\r\n\t\t\tvar ctor = this.constructor, map = ctor._onMap;\r\n\t\t\tif(!map){\r\n\t\t\t\tmap = (ctor._onMap = {});\r\n\t\t\t\tfor(var attr in ctor.prototype){\r\n\t\t\t\t\tif(/^on/.test(attr)){\r\n\t\t\t\t\t\tmap[attr.replace(/^on/, \"\").toLowerCase()] = attr;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn map[typeof type == \"string\" && type.toLowerCase()];\t// String\r\n\t\t},\r\n\r\n\t\ttoString: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns a string that represents the widget.\r\n\t\t\t// description:\r\n\t\t\t//\t\tWhen a widget is cast to a string, this method will be used to generate the\r\n\t\t\t//\t\toutput. Currently, it does not implement any sort of reversible\r\n\t\t\t//\t\tserialization.\r\n\t\t\treturn '[Widget ' + this.declaredClass + ', ' + (this.id || 'NO ID') + ']'; // String\r\n\t\t},\r\n\r\n\t\tgetChildren: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\r\n\t\t\t//\t\tis this widget.   Note that it does not return all descendants, but rather just direct children.\r\n\t\t\t//\t\tAnalogous to [Node.childNodes](https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes),\r\n\t\t\t//\t\texcept containing widgets rather than DOMNodes.\r\n\t\t\t//\r\n\t\t\t//\t\tThe result intentionally excludes internally created widgets (a.k.a. supporting widgets)\r\n\t\t\t//\t\toutside of this.containerNode.\r\n\t\t\t//\r\n\t\t\t//\t\tNote that the array returned is a simple array.  Application code should not assume\r\n\t\t\t//\t\texistence of methods like forEach().\r\n\r\n\t\t\treturn this.containerNode ? registry.findWidgets(this.containerNode) : []; // dijit/_WidgetBase[]\r\n\t\t},\r\n\r\n\t\tgetParent: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns the parent widget of this widget.\r\n\r\n\t\t\treturn registry.getEnclosingWidget(this.domNode.parentNode);\r\n\t\t},\r\n\r\n\t\tconnect: function(/*Object|null*/ obj, /*String|Function*/ event, /*String|Function*/ method){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tDeprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\r\n\t\t\t//\r\n\t\t\t//\t\tConnects specified obj/event to specified method of this object\r\n\t\t\t//\t\tand registers for disconnect() on widget destroy.\r\n\t\t\t//\r\n\t\t\t//\t\tProvide widget-specific analog to dojo.connect, except with the\r\n\t\t\t//\t\timplicit use of this widget as the target object.\r\n\t\t\t//\t\tEvents connected with `this.connect` are disconnected upon\r\n\t\t\t//\t\tdestruction.\r\n\t\t\t// returns:\r\n\t\t\t//\t\tA handle that can be passed to `disconnect` in order to disconnect before\r\n\t\t\t//\t\tthe widget is destroyed.\r\n\t\t\t// example:\r\n\t\t\t//\t|\tvar btn = new Button();\r\n\t\t\t//\t|\t// when foo.bar() is called, call the listener we're going to\r\n\t\t\t//\t|\t// provide in the scope of btn\r\n\t\t\t//\t|\tbtn.connect(foo, \"bar\", function(){\r\n\t\t\t//\t|\t\tconsole.debug(this.toString());\r\n\t\t\t//\t|\t});\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\r\n\t\t\treturn this.own(connect.connect(obj, event, this, method))[0];\t// handle\r\n\t\t},\r\n\r\n\t\tdisconnect: function(handle){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tDeprecated, will be removed in 2.0, use handle.remove() instead.\r\n\t\t\t//\r\n\t\t\t//\t\tDisconnects handle created by `connect`.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\r\n\t\t\thandle.remove();\r\n\t\t},\r\n\r\n\t\tsubscribe: function(t, method){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tDeprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\r\n\t\t\t//\r\n\t\t\t//\t\tSubscribes to the specified topic and calls the specified method\r\n\t\t\t//\t\tof this object and registers for unsubscribe() on widget destroy.\r\n\t\t\t//\r\n\t\t\t//\t\tProvide widget-specific analog to dojo.subscribe, except with the\r\n\t\t\t//\t\timplicit use of this widget as the target object.\r\n\t\t\t// t: String\r\n\t\t\t//\t\tThe topic\r\n\t\t\t// method: Function\r\n\t\t\t//\t\tThe callback\r\n\t\t\t// example:\r\n\t\t\t//\t|\tvar btn = new Button();\r\n\t\t\t//\t|\t// when /my/topic is published, this button changes its label to\r\n\t\t\t//\t|\t// be the parameter of the topic.\r\n\t\t\t//\t|\tbtn.subscribe(\"/my/topic\", function(v){\r\n\t\t\t//\t|\t\tthis.set(\"label\", v);\r\n\t\t\t//\t|\t});\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\t\t\treturn this.own(topic.subscribe(t, lang.hitch(this, method)))[0];\t// handle\r\n\t\t},\r\n\r\n\t\tunsubscribe: function(/*Object*/ handle){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tDeprecated, will be removed in 2.0, use handle.remove() instead.\r\n\t\t\t//\r\n\t\t\t//\t\tUnsubscribes handle created by this.subscribe.\r\n\t\t\t//\t\tAlso removes handle from this widget's list of subscriptions\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\r\n\t\t\thandle.remove();\r\n\t\t},\r\n\r\n\t\tisLeftToRight: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturn this widget's explicit or implicit orientation (true for LTR, false for RTL)\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\t\t\treturn this.dir ? (this.dir.toLowerCase() == \"ltr\") : domGeometry.isBodyLtr(this.ownerDocument); //Boolean\r\n\t\t},\r\n\r\n\t\tisFocusable: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturn true if this widget can currently be focused\r\n\t\t\t//\t\tand false if not\r\n\t\t\treturn this.focus && (domStyle.get(this.domNode, \"display\") != \"none\");\r\n\t\t},\r\n\r\n\t\tplaceAt: function(/*String|DomNode|DocumentFragment|dijit/_WidgetBase*/ reference, /*String|Int?*/ position){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tPlace this widget somewhere in the DOM based\r\n\t\t\t//\t\ton standard domConstruct.place() conventions.\r\n\t\t\t// description:\r\n\t\t\t//\t\tA convenience function provided in all _Widgets, providing a simple\r\n\t\t\t//\t\tshorthand mechanism to put an existing (or newly created) Widget\r\n\t\t\t//\t\tsomewhere in the dom, and allow chaining.\r\n\t\t\t// reference:\r\n\t\t\t//\t\tWidget, DOMNode, DocumentFragment, or id of widget or DOMNode\r\n\t\t\t// position:\r\n\t\t\t//\t\tIf reference is a widget (or id of widget), and that widget has an \".addChild\" method,\r\n\t\t\t//\t\tit will be called passing this widget instance into that method, supplying the optional\r\n\t\t\t//\t\tposition index passed.  In this case position (if specified) should be an integer.\r\n\t\t\t//\r\n\t\t\t//\t\tIf reference is a DOMNode (or id matching a DOMNode but not a widget),\r\n\t\t\t//\t\tthe position argument can be a numeric index or a string\r\n\t\t\t//\t\t\"first\", \"last\", \"before\", or \"after\", same as dojo/dom-construct::place().\r\n\t\t\t// returns: dijit/_WidgetBase\r\n\t\t\t//\t\tProvides a useful return of the newly created dijit._Widget instance so you\r\n\t\t\t//\t\tcan \"chain\" this function by instantiating, placing, then saving the return value\r\n\t\t\t//\t\tto a variable.\r\n\t\t\t// example:\r\n\t\t\t//\t|\t// create a Button with no srcNodeRef, and place it in the body:\r\n\t\t\t//\t|\tvar button = new Button({ label:\"click\" }).placeAt(win.body());\r\n\t\t\t//\t|\t// now, 'button' is still the widget reference to the newly created button\r\n\t\t\t//\t|\tbutton.on(\"click\", function(e){ console.log('click'); }));\r\n\t\t\t// example:\r\n\t\t\t//\t|\t// create a button out of a node with id=\"src\" and append it to id=\"wrapper\":\r\n\t\t\t//\t|\tvar button = new Button({},\"src\").placeAt(\"wrapper\");\r\n\t\t\t// example:\r\n\t\t\t//\t|\t// place a new button as the first element of some div\r\n\t\t\t//\t|\tvar button = new Button({ label:\"click\" }).placeAt(\"wrapper\",\"first\");\r\n\t\t\t// example:\r\n\t\t\t//\t|\t// create a contentpane and add it to a TabContainer\r\n\t\t\t//\t|\tvar tc = dijit.byId(\"myTabs\");\r\n\t\t\t//\t|\tnew ContentPane({ href:\"foo.html\", title:\"Wow!\" }).placeAt(tc)\r\n\r\n\t\t\tvar refWidget = !reference.tagName && registry.byId(reference);\r\n\t\t\tif(refWidget && refWidget.addChild && (!position || typeof position === \"number\")){\r\n\t\t\t\t// Adding this to refWidget and can use refWidget.addChild() to handle everything.\r\n\t\t\t\trefWidget.addChild(this, position);\r\n\t\t\t}else{\r\n\t\t\t\t// \"reference\" is a plain DOMNode, or we can't use refWidget.addChild().   Use domConstruct.place() and\r\n\t\t\t\t// target refWidget.containerNode for nested placement (position==number, \"first\", \"last\", \"only\"), and\r\n\t\t\t\t// refWidget.domNode otherwise (\"after\"/\"before\"/\"replace\").  (But not supported officially, see #14946.)\r\n\t\t\t\tvar ref = refWidget && (\"domNode\" in refWidget) ?\r\n\t\t\t\t\t(refWidget.containerNode && !/after|before|replace/.test(position || \"\") ?\r\n\t\t\t\t\t\trefWidget.containerNode : refWidget.domNode) : dom.byId(reference, this.ownerDocument);\r\n\t\t\t\tdomConstruct.place(this.domNode, ref, position);\r\n\r\n\t\t\t\t// Start this iff it has a parent widget that's already started.\r\n\t\t\t\t// TODO: for 2.0 maybe it should also start the widget when this.getParent() returns null??\r\n\t\t\t\tif(!this._started && (this.getParent() || {})._started){\r\n\t\t\t\t\tthis.startup();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\tdefer: function(fcn, delay){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tWrapper to setTimeout to avoid deferred functions executing\r\n\t\t\t//\t\tafter the originating widget has been destroyed.\r\n\t\t\t//\t\tReturns an object handle with a remove method (that returns null) (replaces clearTimeout).\r\n\t\t\t// fcn: Function\r\n\t\t\t//\t\tFunction reference.\r\n\t\t\t// delay: Number?\r\n\t\t\t//\t\tDelay, defaults to 0.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\r\n\t\t\tvar timer = setTimeout(lang.hitch(this,\r\n\t\t\t\tfunction(){\r\n\t\t\t\t\tif(!timer){\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttimer = null;\r\n\t\t\t\t\tif(!this._destroyed){\r\n\t\t\t\t\t\tlang.hitch(this, fcn)();\r\n\t\t\t\t\t}\r\n\t\t\t\t}),\r\n\t\t\t\tdelay || 0\r\n\t\t\t);\r\n\t\t\treturn {\r\n\t\t\t\tremove: function(){\r\n\t\t\t\t\tif(timer){\r\n\t\t\t\t\t\tclearTimeout(timer);\r\n\t\t\t\t\t\ttimer = null;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn null; // so this works well: handle = handle.remove();\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t}\r\n\t});\r\n\r\n\tif(has(\"dojo-bidi\")){\r\n\t\t_WidgetBase.extend(_BidiMixin);\r\n\t}\r\n\r\n\treturn _WidgetBase;\r\n});\r\n"]}