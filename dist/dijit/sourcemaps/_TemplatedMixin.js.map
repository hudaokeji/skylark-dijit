{"version":3,"sources":["_TemplatedMixin.js"],"names":["define","cache","declare","domConstruct","lang","on","has","string","_AttachMixin","_TemplatedMixin","templateString","templatePath","_skipNodeCache","searchContainerNode","_stringRepl","tmpl","className","this","declaredClass","_this","substitute","value","key","charAt","getObject","substr","Error","_escapeValue","val","replace","&","<",">","\"","'","buildRendering","_rendered","sanitize","node","cached","getCachedTemplate","ownerDocument","isString","toDom","nodeType","cloneNode","domNode","inherited","arguments","_fillContent","srcNodeRef","source","dest","containerNode","hasChildNodes","appendChild","firstChild","_templateCache","alwaysUseString","doc","tmplts","document","e","destroy","trim","match","window"],"mappings":";;;;;;;AAAAA,QACC,aACA,qBACA,qBACA,kBACA,UACA,aACA,cACA,kBACE,SAASC,EAAOC,EAASC,EAAcC,EAAMC,EAAIC,EAAKC,EAAQC,GAKhE,IAAIC,EAAkBP,EAAQ,wBAAyBM,GAOtDE,eAAgB,KAKhBC,aAAc,KAMdC,gBAAgB,EAYhBC,qBAAqB,EAErBC,YAAa,SAASC,GAKrB,IAAIC,EAAYC,KAAKC,cAAeC,EAAQF,KAG5C,OAAOV,EAAOa,WAAWL,EAAME,KAAM,SAASI,EAAOC,GAEpD,GADoB,KAAjBA,EAAIC,OAAO,KAAYF,EAAQjB,EAAKoB,UAAUF,EAAIG,OAAO,IAAI,EAAON,SACpD,IAATE,EAAuB,MAAM,IAAIK,MAAMV,EAAU,aAAaM,GACxE,OAAY,MAATD,EAAuB,GAIF,KAAjBC,EAAIC,OAAO,GAAYF,EAAQJ,KAAKU,aAAa,GAAKN,IAC3DJ,OAGJU,aAAc,SAAoBC,GAQjC,OAAOA,EAAIC,QAAQ,WAAY,SAASD,GACvC,OACCE,IAAK,QACLC,IAAK,OACLC,IAAK,OACLC,IAAM,SACNC,IAAK,UACJN,MAIJO,eAAgB,WAMf,IAAIlB,KAAKmB,UAAU,CACdnB,KAAKP,iBACRO,KAAKP,eAAiBT,EAAMgB,KAAKN,cAAe0B,UAAU,KAM3D,IAEIC,EAFAC,EAAS9B,EAAgB+B,kBAAkBvB,KAAKP,eAAgBO,KAAKL,eAAgBK,KAAKwB,eAG9F,GAAGrC,EAAKsC,SAASH,IAEhB,GAAoB,IADpBD,EAAOnC,EAAawC,MAAM1B,KAAKH,YAAYyB,GAAStB,KAAKwB,gBACjDG,SAEP,MAAM,IAAIlB,MAAM,qBAAuBa,QAIxCD,EAAOC,EAAOM,WAAU,GAGzB5B,KAAK6B,QAAUR,EAKhBrB,KAAK8B,UAAUC,WAEX/B,KAAKmB,WACRnB,KAAKgC,aAAahC,KAAKiC,YAGxBjC,KAAKmB,WAAY,GAGlBa,aAAc,SAAqBE,GAMlC,IAAIC,EAAOnC,KAAKoC,cAChB,GAAGF,GAAUC,EACZ,KAAMD,EAAOG,iBACZF,EAAKG,YAAYJ,EAAOK,eAoE5B,OA5DA/C,EAAgBgD,kBAEhBhD,EAAgB+B,kBAAoB,SAAS9B,EAAgBgD,EAAiBC,GAe7E,IAAIC,EAASnD,EAAgBgD,eACzBnC,EAAMZ,EACN6B,EAASqB,EAAOtC,GACpB,GAAGiB,EAAO,CACT,IAGC,IAAIA,EAAOE,eAAiBF,EAAOE,gBAAkBkB,GAAOE,UAE3D,OAAOtB,EAER,MAAMuB,IACP3D,EAAa4D,QAAQxB,GAKtB,GAFA7B,EAAiBH,EAAOyD,KAAKtD,GAE1BgD,GAAmBhD,EAAeuD,MAAM,mBAE1C,OAAQL,EAAOtC,GAAOZ,EAGtB,IAAI4B,EAAOnC,EAAawC,MAAMjC,EAAgBiD,GAC9C,GAAoB,GAAjBrB,EAAKM,SACP,MAAM,IAAIlB,MAAM,qBAAuBhB,GAExC,OAAQkD,EAAOtC,GAAOgB,GAIrBhC,EAAI,OACND,EAAG6D,OAAQ,SAAU,WACpB,IAAIjE,EAAQQ,EAAgBgD,eAC5B,IAAI,IAAInC,KAAOrB,EAAM,CACpB,IAAIoB,EAAQpB,EAAMqB,GACC,iBAATD,GACTlB,EAAa4D,QAAQ1C,UAEfpB,EAAMqB,MAKTb","file":"../_TemplatedMixin.js","sourcesContent":["define([\r\n\t\"dojo/cache\",\t// dojo.cache\r\n\t\"dojo/_base/declare\", // declare\r\n\t\"dojo/dom-construct\", // domConstruct.destroy, domConstruct.toDom\r\n\t\"dojo/_base/lang\", // lang.getObject\r\n\t\"dojo/on\",\r\n\t\"dojo/sniff\", // has(\"ie\")\r\n\t\"dojo/string\", // string.substitute string.trim\r\n\t\"./_AttachMixin\"\r\n], function(cache, declare, domConstruct, lang, on, has, string, _AttachMixin){\r\n\r\n\t// module:\r\n\t//\t\tdijit/_TemplatedMixin\r\n\r\n\tvar _TemplatedMixin = declare(\"dijit._TemplatedMixin\", _AttachMixin, {\r\n\t\t// summary:\r\n\t\t//\t\tMixin for widgets that are instantiated from a template\r\n\r\n\t\t// templateString: [protected] String\r\n\t\t//\t\tA string that represents the widget template.\r\n\t\t//\t\tUse in conjunction with dojo.cache() to load from a file.\r\n\t\ttemplateString: null,\r\n\r\n\t\t// templatePath: [protected deprecated] String\r\n\t\t//\t\tPath to template (HTML file) for this widget relative to dojo.baseUrl.\r\n\t\t//\t\tDeprecated: use templateString with require([... \"dojo/text!...\"], ...) instead\r\n\t\ttemplatePath: null,\r\n\r\n\t\t// skipNodeCache: [protected] Boolean\r\n\t\t//\t\tIf using a cached widget template nodes poses issues for a\r\n\t\t//\t\tparticular widget class, it can set this property to ensure\r\n\t\t//\t\tthat its template is always re-built from a string\r\n\t\t_skipNodeCache: false,\r\n\r\n/*=====\r\n\t\t// _rendered: Boolean\r\n\t\t//\t\tNot normally use, but this flag can be set by the app if the server has already rendered the template,\r\n\t\t//\t\ti.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\r\n\t\t//\t\tjust function like _AttachMixin.\r\n\t\t_rendered: false,\r\n=====*/\r\n\r\n\t\t// Set _AttachMixin.searchContainerNode to true for back-compat for widgets that have data-dojo-attach-point's\r\n\t\t// and events inside this.containerNode.   Remove for 2.0.\r\n\t\tsearchContainerNode: true,\r\n\r\n\t\t_stringRepl: function(tmpl){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tDoes substitution of ${foo} type properties in template string\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\tvar className = this.declaredClass, _this = this;\r\n\t\t\t// Cache contains a string because we need to do property replacement\r\n\t\t\t// do the property replacement\r\n\t\t\treturn string.substitute(tmpl, this, function(value, key){\r\n\t\t\t\tif(key.charAt(0) == '!'){ value = lang.getObject(key.substr(1), false, _this); }\r\n\t\t\t\tif(typeof value == \"undefined\"){ throw new Error(className+\" template:\"+key); } // a debugging aide\r\n\t\t\t\tif(value == null){ return \"\"; }\r\n\r\n\t\t\t\t// Substitution keys beginning with ! will skip the transform step,\r\n\t\t\t\t// in case a user wishes to insert unescaped markup, e.g. ${!foo}\r\n\t\t\t\treturn key.charAt(0) == \"!\" ? value : this._escapeValue(\"\" + value);\r\n\t\t\t}, this);\r\n\t\t},\r\n\r\n\t\t_escapeValue: function(/*String*/ val){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tEscape a value to be inserted into the template, either into an attribute value\r\n\t\t\t//\t\t(ex: foo=\"${bar}\") or as inner text of an element (ex: <span>${foo}</span>)\r\n\r\n\t\t\t// Safer substitution, see heading \"Attribute values\" in\r\n\t\t\t// http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.3.2\r\n\t\t\t// and also https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet#RULE_.231_-_HTML_Escape_Before_Inserting_Untrusted_Data_into_HTML_Element_Content\r\n\t\t\treturn val.replace(/[\"'<>&]/g, function(val){\r\n\t\t\t\treturn {\r\n\t\t\t\t\t\"&\": \"&amp;\",\r\n\t\t\t\t\t\"<\": \"&lt;\",\r\n\t\t\t\t\t\">\": \"&gt;\",\r\n\t\t\t\t\t\"\\\"\": \"&quot;\",\r\n\t\t\t\t\t\"'\": \"&#x27;\"\r\n\t\t\t\t}[val];\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\tbuildRendering: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tConstruct the UI for this widget from a template, setting this.domNode.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\r\n\t\t\tif(!this._rendered){\r\n\t\t\t\tif(!this.templateString){\r\n\t\t\t\t\tthis.templateString = cache(this.templatePath, {sanitize: true});\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Lookup cached version of template, and download to cache if it\r\n\t\t\t\t// isn't there already.  Returns either a DomNode or a string, depending on\r\n\t\t\t\t// whether or not the template contains ${foo} replacement parameters.\r\n\t\t\t\tvar cached = _TemplatedMixin.getCachedTemplate(this.templateString, this._skipNodeCache, this.ownerDocument);\r\n\r\n\t\t\t\tvar node;\r\n\t\t\t\tif(lang.isString(cached)){\r\n\t\t\t\t\tnode = domConstruct.toDom(this._stringRepl(cached), this.ownerDocument);\r\n\t\t\t\t\tif(node.nodeType != 1){\r\n\t\t\t\t\t\t// Flag common problems such as templates with multiple top level nodes (nodeType == 11)\r\n\t\t\t\t\t\tthrow new Error(\"Invalid template: \" + cached);\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\t// if it's a node, all we have to do is clone it\r\n\t\t\t\t\tnode = cached.cloneNode(true);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.domNode = node;\r\n\t\t\t}\r\n\r\n\t\t\t// Call down to _WidgetBase.buildRendering() to get base classes assigned\r\n\t\t\t// TODO: change the baseClass assignment to _setBaseClassAttr\r\n\t\t\tthis.inherited(arguments);\r\n\r\n\t\t\tif(!this._rendered){\r\n\t\t\t\tthis._fillContent(this.srcNodeRef);\r\n\t\t\t}\r\n\r\n\t\t\tthis._rendered = true;\r\n\t\t},\r\n\r\n\t\t_fillContent: function(/*DomNode*/ source){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tRelocate source contents to templated container node.\r\n\t\t\t//\t\tthis.containerNode must be able to receive children, or exceptions will be thrown.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\t\t\tvar dest = this.containerNode;\r\n\t\t\tif(source && dest){\r\n\t\t\t\twhile(source.hasChildNodes()){\r\n\t\t\t\t\tdest.appendChild(source.firstChild);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t});\r\n\r\n\t// key is templateString; object is either string or DOM tree\r\n\t_TemplatedMixin._templateCache = {};\r\n\r\n\t_TemplatedMixin.getCachedTemplate = function(templateString, alwaysUseString, doc){\r\n\t\t// summary:\r\n\t\t//\t\tStatic method to get a template based on the templatePath or\r\n\t\t//\t\ttemplateString key\r\n\t\t// templateString: String\r\n\t\t//\t\tThe template\r\n\t\t// alwaysUseString: Boolean\r\n\t\t//\t\tDon't cache the DOM tree for this template, even if it doesn't have any variables\r\n\t\t// doc: Document?\r\n\t\t//\t\tThe target document.   Defaults to document global if unspecified.\r\n\t\t// returns: Mixed\r\n\t\t//\t\tEither string (if there are ${} variables that need to be replaced) or just\r\n\t\t//\t\ta DOM tree (if the node can be cloned directly)\r\n\r\n\t\t// is it already cached?\r\n\t\tvar tmplts = _TemplatedMixin._templateCache;\r\n\t\tvar key = templateString;\r\n\t\tvar cached = tmplts[key];\r\n\t\tif(cached){\r\n\t\t\ttry{\r\n\t\t\t\t// if the cached value is an innerHTML string (no ownerDocument) or a DOM tree created within the\r\n\t\t\t\t// current document, then use the current cached value\r\n\t\t\t\tif(!cached.ownerDocument || cached.ownerDocument == (doc || document)){\r\n\t\t\t\t\t// string or node of the same document\r\n\t\t\t\t\treturn cached;\r\n\t\t\t\t}\r\n\t\t\t}catch(e){ /* squelch */ } // IE can throw an exception if cached.ownerDocument was reloaded\r\n\t\t\tdomConstruct.destroy(cached);\r\n\t\t}\r\n\r\n\t\ttemplateString = string.trim(templateString);\r\n\r\n\t\tif(alwaysUseString || templateString.match(/\\$\\{([^\\}]+)\\}/g)){\r\n\t\t\t// there are variables in the template so all we can do is cache the string\r\n\t\t\treturn (tmplts[key] = templateString); //String\r\n\t\t}else{\r\n\t\t\t// there are no variables in the template so we can cache the DOM tree\r\n\t\t\tvar node = domConstruct.toDom(templateString, doc);\r\n\t\t\tif(node.nodeType != 1){\r\n\t\t\t\tthrow new Error(\"Invalid template: \" + templateString);\r\n\t\t\t}\r\n\t\t\treturn (tmplts[key] = node); //Node\r\n\t\t}\r\n\t};\r\n\r\n\tif(has(\"ie\")){\r\n\t\ton(window, \"unload\", function(){\r\n\t\t\tvar cache = _TemplatedMixin._templateCache;\r\n\t\t\tfor(var key in cache){\r\n\t\t\t\tvar value = cache[key];\r\n\t\t\t\tif(typeof value == \"object\"){ // value is either a string or a DOM node template\r\n\t\t\t\t\tdomConstruct.destroy(value);\r\n\t\t\t\t}\r\n\t\t\t\tdelete cache[key];\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\treturn _TemplatedMixin;\r\n});\r\n"]}