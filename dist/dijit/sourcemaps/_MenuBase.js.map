{"version":3,"sources":["_MenuBase.js"],"names":["define","array","declare","dom","domAttr","domClass","lang","mouse","on","winUtils","a11yclick","registry","_Widget","_CssStateMixin","_KeyNavContainer","_TemplatedMixin","selected","_setSelectedAttr","item","this","_setSelected","_onChildDeselect","_set","activated","_setActivatedAttr","val","toggle","domNode","parentMenu","popupDelay","passivePopupDelay","Infinity","autoFocus","childSelector","node","widget","byNode","parentNode","containerNode","focus","postCreate","self","matches","hitch","own","selector","enter","onItemHover","leave","onItemUnhover","evt","onItemClick","stopPropagation","_onItemFocus","inherited","arguments","onKeyboardSearch","searchString","numMatches","popup","_keyboardSearchCompare","shortcutKey","toLowerCase","onExecute","onCancel","_moveToPopup","focusedChild","disabled","topMenu","_getTopMenu","_isMenuBar","focusNext","_onPopupHover","set","currentPopupItem","_stopPendingCloseTimer","hover_timer","defer","_openItemPopup","passive_hover_timer","remove","type","_hoveredChild","_stopPopupTimer","_pendingClose_timer","_closePopup","top","focusChild","byKeyboard","test","_origType","clientX","clientY","_onClick","onClick","from_item","_mouseoverHandle","once","_openPopup","parent","orient","_orient","_cleanUp","onClose","onOpen","isShowingNow","_closeChild","focused","focusNode","tabIndex","_onBlur","clearSelectedItem"],"mappings":"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","file":"../_MenuBase.js","sourcesContent":["define([\r\n\t\"dojo/_base/array\", // array.indexOf\r\n\t\"dojo/_base/declare\", // declare\r\n\t\"dojo/dom\", // dom.isDescendant domClass.replace\r\n\t\"dojo/dom-attr\",\r\n\t\"dojo/dom-class\", // domClass.replace\r\n\t\"dojo/_base/lang\", // lang.hitch\r\n\t\"dojo/mouse\", // mouse.enter, mouse.leave\r\n\t\"dojo/on\",\r\n\t\"dojo/window\",\r\n\t\"./a11yclick\",\r\n\t\"./registry\",\r\n\t\"./_Widget\",\r\n\t\"./_CssStateMixin\",\r\n\t\"./_KeyNavContainer\",\r\n\t\"./_TemplatedMixin\"\r\n], function(array, declare, dom, domAttr, domClass, lang, mouse, on, winUtils, a11yclick,\r\n\t\t\tregistry, _Widget, _CssStateMixin, _KeyNavContainer, _TemplatedMixin){\r\n\r\n\t// module:\r\n\t//\t\tdijit/_MenuBase\r\n\r\n\treturn declare(\"dijit._MenuBase\", [_Widget, _TemplatedMixin, _KeyNavContainer, _CssStateMixin], {\r\n\t\t// summary:\r\n\t\t//\t\tAbstract base class for Menu and MenuBar.\r\n\t\t//\t\tSubclass should implement _onUpArrow(), _onDownArrow(), _onLeftArrow(), and _onRightArrow().\r\n\r\n\t\t// selected: dijit/MenuItem\r\n\t\t//\t\tCurrently selected (a.k.a. highlighted) MenuItem, or null if no MenuItem is selected.\r\n\t\t//\t\tIf a submenu is open, will be set to MenuItem that displayed the submenu.   OTOH, if\r\n\t\t//\t\tthis Menu is in passive mode (i.e. hasn't been clicked yet), will be null, because\r\n\t\t//\t\t\"selected\" is not merely \"hovered\".\r\n\t\tselected: null,\r\n\t\t_setSelectedAttr: function(item){\r\n\t\t\tif(this.selected != item){\r\n\t\t\t\tif(this.selected){\r\n\t\t\t\t\tthis.selected._setSelected(false);\r\n\t\t\t\t\tthis._onChildDeselect(this.selected);\r\n\t\t\t\t}\r\n\t\t\t\tif(item){\r\n\t\t\t\t\titem._setSelected(true);\r\n\t\t\t\t}\r\n\t\t\t\tthis._set(\"selected\", item);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t// activated: [readonly] Boolean\r\n\t\t//\t\tThis Menu has been clicked (mouse or via space/arrow key) or opened as a submenu,\r\n\t\t//\t\tso mere mouseover will open submenus.  Focusing a menu via TAB does NOT automatically make it active\r\n\t\t//\t\tsince TAB is a navigation operation and not a selection one.\r\n\t\t//\t\tFor Windows apps, pressing the ALT key focuses the menubar menus (similar to TAB navigation) but the\r\n\t\t//\t\tmenu is not active (ie no dropdown) until an item is clicked.\r\n\t\tactivated: false,\r\n\t\t_setActivatedAttr: function(val){\r\n\t\t\tdomClass.toggle(this.domNode, \"dijitMenuActive\", val);\r\n\t\t\tdomClass.toggle(this.domNode, \"dijitMenuPassive\", !val);\r\n\t\t\tthis._set(\"activated\", val);\r\n\t\t},\r\n\r\n\t\t// parentMenu: [readonly] Widget\r\n\t\t//\t\tpointer to menu that displayed me\r\n\t\tparentMenu: null,\r\n\r\n\t\t// popupDelay: Integer\r\n\t\t//\t\tAfter a menu has been activated (by clicking on it etc.), number of milliseconds before hovering\r\n\t\t//\t\t(without clicking) another MenuItem causes that MenuItem's popup to automatically open.\r\n\t\tpopupDelay: 500,\r\n\r\n\t\t// passivePopupDelay: Integer\r\n\t\t//\t\tFor a passive (unclicked) Menu, number of milliseconds before hovering (without clicking) will cause\r\n\t\t//\t\tthe popup to open.  Default is Infinity, meaning you need to click the menu to open it.\r\n\t\tpassivePopupDelay: Infinity,\r\n\r\n\t\t// autoFocus: Boolean\r\n\t\t//\t\tA toggle to control whether or not a Menu gets focused when opened as a drop down from a MenuBar\r\n\t\t//\t\tor DropDownButton/ComboButton.   Note though that it always get focused when opened via the keyboard.\r\n\t\tautoFocus: false,\r\n\r\n\t\tchildSelector: function(/*DOMNode*/ node){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSelector (passed to on.selector()) used to identify MenuItem child widgets, but exclude inert children\r\n\t\t\t//\t\tlike MenuSeparator.  If subclass overrides to a string (ex: \"> *\"), the subclass must require dojo/query.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\r\n\t\t\tvar widget = registry.byNode(node);\r\n\t\t\treturn node.parentNode == this.containerNode && widget && widget.focus;\r\n\t\t},\r\n\r\n\t\tpostCreate: function(){\r\n\t\t\tvar self = this,\r\n\t\t\t\tmatches = typeof this.childSelector == \"string\" ? this.childSelector : lang.hitch(this, \"childSelector\");\r\n\t\t\tthis.own(\r\n\t\t\t\ton(this.containerNode, on.selector(matches, mouse.enter), function(){\r\n\t\t\t\t\tself.onItemHover(registry.byNode(this));\r\n\t\t\t\t}),\r\n\t\t\t\ton(this.containerNode, on.selector(matches, mouse.leave), function(){\r\n\t\t\t\t\tself.onItemUnhover(registry.byNode(this));\r\n\t\t\t\t}),\r\n\t\t\t\ton(this.containerNode, on.selector(matches, a11yclick), function(evt){\r\n\t\t\t\t\tself.onItemClick(registry.byNode(this), evt);\r\n\t\t\t\t\tevt.stopPropagation();\r\n\t\t\t\t}),\r\n\t\t\t\ton(this.containerNode, on.selector(matches, \"focusin\"), function(){\r\n\t\t\t\t\tself._onItemFocus(registry.byNode(this));\r\n\t\t\t\t})\r\n\t\t\t);\r\n\t\t\tthis.inherited(arguments);\r\n\t\t},\r\n\r\n\t\tonKeyboardSearch: function(/*MenuItem*/ item, /*Event*/ evt, /*String*/ searchString, /*Number*/ numMatches){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tAttach point for notification about when a menu item has been searched for\r\n\t\t\t//\t\tvia the keyboard search mechanism.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\t\t\tthis.inherited(arguments);\r\n\t\t\tif(!!item && (numMatches == -1 || (!!item.popup && numMatches == 1))){\r\n\t\t\t\tthis.onItemClick(item, evt);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_keyboardSearchCompare: function(/*dijit/_WidgetBase*/ item, /*String*/ searchString){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCompares the searchString to the widget's text label, returning:\r\n\t\t\t//\t\t-1: a high priority match and stop searching\r\n\t\t\t//\t\t 0: no match\r\n\t\t\t//\t\t 1: a match but keep looking for a higher priority match\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\tif(!!item.shortcutKey){\r\n\t\t\t\t// accessKey matches have priority\r\n\t\t\t\treturn searchString == item.shortcutKey.toLowerCase() ? -1 : 0;\r\n\t\t\t}\r\n\t\t\treturn this.inherited(arguments) ? 1 : 0; // change return value of -1 to 1 so that searching continues\r\n\t\t},\r\n\r\n\t\tonExecute: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tAttach point for notification about when a menu item has been executed.\r\n\t\t\t//\t\tThis is an internal mechanism used for Menus to signal to their parent to\r\n\t\t\t//\t\tclose them, because they are about to execute the onClick handler.  In\r\n\t\t\t//\t\tgeneral developers should not attach to or override this method.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\t\t},\r\n\r\n\t\tonCancel: function(/*Boolean*/ /*===== closeAll =====*/){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tAttach point for notification about when the user cancels the current menu\r\n\t\t\t//\t\tThis is an internal mechanism used for Menus to signal to their parent to\r\n\t\t\t//\t\tclose them.  In general developers should not attach to or override this method.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\t\t},\r\n\r\n\t\t_moveToPopup: function(/*Event*/ evt){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tThis handles the right arrow key (left arrow key on RTL systems),\r\n\t\t\t//\t\twhich will either open a submenu, or move to the next item in the\r\n\t\t\t//\t\tancestor MenuBar\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\r\n\t\t\tif(this.focusedChild && this.focusedChild.popup && !this.focusedChild.disabled){\r\n\t\t\t\tthis.onItemClick(this.focusedChild, evt);\r\n\t\t\t}else{\r\n\t\t\t\tvar topMenu = this._getTopMenu();\r\n\t\t\t\tif(topMenu && topMenu._isMenuBar){\r\n\t\t\t\t\ttopMenu.focusNext();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_onPopupHover: function(/*Event*/ /*===== evt =====*/){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tThis handler is called when the mouse moves over the popup.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\r\n\t\t\t// if the mouse hovers over a menu popup that is in pending-close state,\r\n\t\t\t// then stop the close operation.\r\n\t\t\t// This can't be done in onItemHover since some popup targets don't have MenuItems (e.g. ColorPicker)\r\n\r\n\t\t\t// highlight the parent menu item pointing to this popup (in case user temporarily moused over another MenuItem)\r\n\t\t\tthis.set(\"selected\", this.currentPopupItem);\r\n\r\n\t\t\t// cancel the pending close (if there is one) (in case user temporarily moused over another MenuItem)\r\n\t\t\tthis._stopPendingCloseTimer();\r\n\t\t},\r\n\r\n\t\tonItemHover: function(/*MenuItem*/ item){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCalled when cursor is over a MenuItem.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\r\n\t\t\t// Don't do anything unless user has \"activated\" the menu by:\r\n\t\t\t//\t\t1) clicking it\r\n\t\t\t//\t\t2) opening it from a parent menu (which automatically activates it)\r\n\r\n\t\t\tif(this.activated){\r\n\t\t\t\tthis.set(\"selected\", item);\r\n\t\t\t\tif(item.popup && !item.disabled && !this.hover_timer){\r\n\t\t\t\t\tthis.hover_timer = this.defer(function(){\r\n\t\t\t\t\t\tthis._openItemPopup(item);\r\n\t\t\t\t\t}, this.popupDelay);\r\n\t\t\t\t}\r\n\t\t\t}else if(this.passivePopupDelay < Infinity){\r\n\t\t\t\tif(this.passive_hover_timer){\r\n\t\t\t\t\tthis.passive_hover_timer.remove();\r\n\t\t\t\t}\r\n\t\t\t\tthis.passive_hover_timer = this.defer(function(){\r\n\t\t\t\t\tthis.onItemClick(item, {type: \"click\"});\r\n\t\t\t\t}, this.passivePopupDelay);\r\n\t\t\t}\r\n\r\n\t\t\tthis._hoveredChild = item;\r\n\r\n\t\t\titem._set(\"hovering\", true);\r\n\t\t},\r\n\r\n\t\t_onChildDeselect: function(item){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCalled when a child MenuItem becomes deselected.   Setup timer to close its popup.\r\n\r\n\t\t\tthis._stopPopupTimer();\r\n\r\n\t\t\t// Setup timer to close all popups that are open and descendants of this menu.\r\n\t\t\t// Will be canceled if user quickly moves the mouse over the popup.\r\n\t\t\tif(this.currentPopupItem == item){\r\n\t\t\t\tthis._stopPendingCloseTimer();\r\n\t\t\t\tthis._pendingClose_timer = this.defer(function(){\r\n\t\t\t\t\tthis._pendingClose_timer = null;\r\n\t\t\t\t\tthis.currentPopupItem = null;\r\n\t\t\t\t\titem._closePopup(); // this calls onClose\r\n\t\t\t\t}, this.popupDelay);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tonItemUnhover: function(/*MenuItem*/ item){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCallback fires when mouse exits a MenuItem\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\r\n\t\t\tif(this._hoveredChild == item){\r\n\t\t\t\tthis._hoveredChild = null;\r\n\t\t\t}\r\n\r\n\t\t\tif(this.passive_hover_timer){\r\n\t\t\t\tthis.passive_hover_timer.remove();\r\n\t\t\t\tthis.passive_hover_timer = null;\r\n\t\t\t}\r\n\r\n\t\t\titem._set(\"hovering\", false);\r\n\t\t},\r\n\r\n\t\t_stopPopupTimer: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCancels the popup timer because the user has stop hovering\r\n\t\t\t//\t\ton the MenuItem, etc.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\r\n\t\t\tif(this.hover_timer){\r\n\t\t\t\tthis.hover_timer = this.hover_timer.remove();\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_stopPendingCloseTimer: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCancels the pending-close timer because the close has been preempted\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\tif(this._pendingClose_timer){\r\n\t\t\t\tthis._pendingClose_timer = this._pendingClose_timer.remove();\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_getTopMenu: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns the top menu in this chain of Menus\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\tfor(var top = this; top.parentMenu; top = top.parentMenu){}\r\n\t\t\treturn top;\r\n\t\t},\r\n\r\n\t\tonItemClick: function(/*dijit/_WidgetBase*/ item, /*Event*/ evt){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tHandle clicks on an item.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\r\n\t\t\tif(this.passive_hover_timer){\r\n\t\t\t\tthis.passive_hover_timer.remove();\r\n\t\t\t}\r\n\r\n\t\t\tthis.focusChild(item);\r\n\r\n\t\t\tif(item.disabled){\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tif(item.popup){\r\n\t\t\t\tthis.set(\"selected\", item);\r\n\t\t\t\tthis.set(\"activated\", true);\r\n\t\t\t\tvar byKeyboard = /^key/.test(evt._origType || evt.type) ||\r\n\t\t\t\t\t(evt.clientX == 0 && evt.clientY == 0);\t// detects accessKey like ALT+SHIFT+F, where type is \"click\"\r\n\t\t\t\tthis._openItemPopup(item, byKeyboard);\r\n\t\t\t}else{\r\n\t\t\t\t// before calling user defined handler, close hierarchy of menus\r\n\t\t\t\t// and restore focus to place it was when menu was opened\r\n\t\t\t\tthis.onExecute();\r\n\r\n\t\t\t\t// user defined handler for click\r\n\t\t\t\titem._onClick ? item._onClick(evt) : item.onClick(evt);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_openItemPopup: function(/*dijit/MenuItem*/ from_item, /*Boolean*/ focus){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tOpen the popup to the side of/underneath the current menu item, and optionally focus first item\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\r\n\t\t\tif(from_item == this.currentPopupItem){\r\n\t\t\t\t// Specified popup is already being shown, so just return\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif(this.currentPopupItem){\r\n\t\t\t\t// If another popup is currently shown, then close it\r\n\t\t\t\tthis._stopPendingCloseTimer();\r\n\t\t\t\tthis.currentPopupItem._closePopup();\r\n\t\t\t}\r\n\t\t\tthis._stopPopupTimer();\r\n\r\n\t\t\tvar popup = from_item.popup;\r\n\t\t\tpopup.parentMenu = this;\r\n\r\n\t\t\t// detect mouseover of the popup to handle lazy mouse movements that temporarily focus other menu items\\c\r\n\t\t\tthis.own(this._mouseoverHandle = on.once(popup.domNode, \"mouseover\", lang.hitch(this, \"_onPopupHover\")));\r\n\r\n\t\t\tvar self = this;\r\n\t\t\tfrom_item._openPopup({\r\n\t\t\t\tparent: this,\r\n\t\t\t\torient: this._orient || [\"after\", \"before\"],\r\n\t\t\t\tonCancel: function(){ // called when the child menu is canceled\r\n\t\t\t\t\tif(focus){\r\n\t\t\t\t\t\t// put focus back on my node before focused node is hidden\r\n\t\t\t\t\t\tself.focusChild(from_item);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// close the submenu (be sure this is done _after_ focus is moved)\r\n\t\t\t\t\tself._cleanUp();\r\n\t\t\t\t},\r\n\t\t\t\tonExecute: lang.hitch(this, \"_cleanUp\", true),\r\n\t\t\t\tonClose: function(){\r\n\t\t\t\t\t// Remove handler created by onItemHover\r\n\t\t\t\t\tif(self._mouseoverHandle){\r\n\t\t\t\t\t\tself._mouseoverHandle.remove();\r\n\t\t\t\t\t\tdelete self._mouseoverHandle;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}, focus);\r\n\r\n\t\t\tthis.currentPopupItem = from_item;\r\n\r\n\t\t\t// TODO: focusing a popup should clear tabIndex on Menu (and it's child MenuItems), so that neither\r\n\t\t\t// TAB nor SHIFT-TAB returns to the menu.  Only ESC or ENTER should return to the menu.\r\n\t\t},\r\n\r\n\t\tonOpen: function(/*Event*/ /*===== e =====*/){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCallback when this menu is opened.\r\n\t\t\t//\t\tThis is called by the popup manager as notification that the menu\r\n\t\t\t//\t\twas opened.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\r\n\t\t\tthis.isShowingNow = true;\r\n\t\t\tthis.set(\"activated\", true);\r\n\t\t},\r\n\r\n\t\tonClose: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCallback when this menu is closed.\r\n\t\t\t//\t\tThis is called by the popup manager as notification that the menu\r\n\t\t\t//\t\twas closed.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\r\n\t\t\tthis.set(\"activated\", false);\r\n\t\t\tthis.set(\"selected\", null);\r\n\t\t\tthis.isShowingNow = false;\r\n\t\t\tthis.parentMenu = null;\r\n\t\t},\r\n\r\n\t\t_closeChild: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCalled when submenu is clicked or focus is lost.  Close hierarchy of menus.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\tthis._stopPopupTimer();\r\n\r\n\t\t\tif(this.currentPopupItem){\r\n\t\t\t\t// If focus is on a descendant MenuItem then move focus to me,\r\n\t\t\t\t// because IE doesn't like it when you display:none a node with focus,\r\n\t\t\t\t// and also so keyboard users don't lose control.\r\n\t\t\t\t// Likely, immediately after a user defined onClick handler will move focus somewhere\r\n\t\t\t\t// else, like a Dialog.\r\n\t\t\t\tif(this.focused){\r\n\t\t\t\t\tdomAttr.set(this.selected.focusNode, \"tabIndex\", this.tabIndex);\r\n\t\t\t\t\tthis.selected.focusNode.focus();\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Close all popups that are open and descendants of this menu\r\n\t\t\t\tthis.currentPopupItem._closePopup();\r\n\t\t\t\tthis.currentPopupItem = null;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_onItemFocus: function(/*MenuItem*/ item){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCalled when child of this Menu gets focus from:\r\n\t\t\t//\r\n\t\t\t//\t\t1. clicking it\r\n\t\t\t//\t\t2. tabbing into it\r\n\t\t\t//\t\t3. being opened by a parent menu.\r\n\t\t\t//\r\n\t\t\t//\t\tThis is not called just from mouse hover.\r\n\r\n\t\t\tif(this._hoveredChild && this._hoveredChild != item){\r\n\t\t\t\tthis.onItemUnhover(this._hoveredChild);\t// any previous mouse movement is trumped by focus selection\r\n\t\t\t}\r\n\t\t\tthis.set(\"selected\", item);\r\n\t\t},\r\n\r\n\t\t_onBlur: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCalled when focus is moved away from this Menu and it's submenus.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\r\n\t\t\tthis._cleanUp(true);\r\n\t\t\tthis.inherited(arguments);\r\n\t\t},\r\n\r\n\t\t_cleanUp: function(/*Boolean*/ clearSelectedItem){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCalled when the user is done with this menu.  Closes hierarchy of menus.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\r\n\t\t\tthis._closeChild(); // don't call this.onClose since that's incorrect for MenuBar's that never close\r\n\t\t\tif(typeof this.isShowingNow == 'undefined'){ // non-popup menu doesn't call onClose\r\n\t\t\t\tthis.set(\"activated\", false);\r\n\t\t\t}\r\n\r\n\t\t\tif(clearSelectedItem){\r\n\t\t\t\tthis.set(\"selected\", null);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n});\r\n"]}