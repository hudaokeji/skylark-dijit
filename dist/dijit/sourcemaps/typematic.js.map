{"version":3,"sources":["typematic.js"],"names":["define","array","connect","lang","on","has","dijit","typematic","_fireEventAndReload","this","_timer","_callback","_count","_node","_evt","_currentTimeout","Math","max","_initialDelay","_subsequentDelay","round","_minDelay","setTimeout","hitch","trigger","evt","_this","node","callback","obj","subsequentDelay","initialDelay","minDelay","_obj","attr","stop","faux","v","clearTimeout","addKeyListener","keyObject","type","_keypress","handles","undefined","ctrlKey","altKey","metaKey","shiftKey","stopPropagation","preventDefault","remove","forEach","h","addMouseListener","addListener","mouseNode","keyNode"],"mappings":"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","file":"../typematic.js","sourcesContent":["define([\r\n\t\"dojo/_base/array\", // array.forEach\r\n\t\"dojo/_base/connect\", // connect._keyPress\r\n\t\"dojo/_base/lang\", // lang.mixin, lang.hitch\r\n\t\"dojo/on\",\r\n\t\"dojo/sniff\", // has(\"ie\")\r\n\t\"./main\"        // setting dijit.typematic global\r\n], function(array, connect, lang, on, has, dijit){\r\n\r\n\t// module:\r\n\t//\t\tdijit/typematic\r\n\r\n\tvar typematic = (dijit.typematic = {\r\n\t\t// summary:\r\n\t\t//\t\tThese functions are used to repetitively call a user specified callback\r\n\t\t//\t\tmethod when a specific key or mouse click over a specific DOM node is\r\n\t\t//\t\theld down for a specific amount of time.\r\n\t\t//\t\tOnly 1 such event is allowed to occur on the browser page at 1 time.\r\n\r\n\t\t_fireEventAndReload: function(){\r\n\t\t\tthis._timer = null;\r\n\t\t\tthis._callback(++this._count, this._node, this._evt);\r\n\r\n\t\t\t// Schedule next event, timer is at most minDelay (default 10ms) to avoid\r\n\t\t\t// browser overload (particularly avoiding starving DOH robot so it never gets to send a mouseup)\r\n\t\t\tthis._currentTimeout = Math.max(\r\n\t\t\t\tthis._currentTimeout < 0 ? this._initialDelay :\r\n\t\t\t\t\t(this._subsequentDelay > 1 ? this._subsequentDelay : Math.round(this._currentTimeout * this._subsequentDelay)),\r\n\t\t\t\tthis._minDelay);\r\n\t\t\tthis._timer = setTimeout(lang.hitch(this, \"_fireEventAndReload\"), this._currentTimeout);\r\n\t\t},\r\n\r\n\t\ttrigger: function(/*Event*/ evt, /*Object*/ _this, /*DOMNode*/ node, /*Function*/ callback, /*Object*/ obj, /*Number?*/ subsequentDelay, /*Number?*/ initialDelay, /*Number?*/ minDelay){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tStart a timed, repeating callback sequence.\r\n\t\t\t//\t\tIf already started, the function call is ignored.\r\n\t\t\t//\t\tThis method is not normally called by the user but can be\r\n\t\t\t//\t\twhen the normal listener code is insufficient.\r\n\t\t\t// evt:\r\n\t\t\t//\t\tkey or mouse event object to pass to the user callback\r\n\t\t\t// _this:\r\n\t\t\t//\t\tpointer to the user's widget space.\r\n\t\t\t// node:\r\n\t\t\t//\t\tthe DOM node object to pass the the callback function\r\n\t\t\t// callback:\r\n\t\t\t//\t\tfunction to call until the sequence is stopped called with 3 parameters:\r\n\t\t\t// count:\r\n\t\t\t//\t\tinteger representing number of repeated calls (0..n) with -1 indicating the iteration has stopped\r\n\t\t\t// node:\r\n\t\t\t//\t\tthe DOM node object passed in\r\n\t\t\t// evt:\r\n\t\t\t//\t\tkey or mouse event object\r\n\t\t\t// obj:\r\n\t\t\t//\t\tuser space object used to uniquely identify each typematic sequence\r\n\t\t\t// subsequentDelay:\r\n\t\t\t//\t\tif > 1, the number of milliseconds until the 3->n events occur\r\n\t\t\t//\t\tor else the fractional time multiplier for the next event's delay, default=0.9\r\n\t\t\t// initialDelay:\r\n\t\t\t//\t\tthe number of milliseconds until the 2nd event occurs, default=500ms\r\n\t\t\t// minDelay:\r\n\t\t\t//\t\tthe maximum delay in milliseconds for event to fire, default=10ms\r\n\t\t\tif(obj != this._obj){\r\n\t\t\t\tthis.stop();\r\n\t\t\t\tthis._initialDelay = initialDelay || 500;\r\n\t\t\t\tthis._subsequentDelay = subsequentDelay || 0.90;\r\n\t\t\t\tthis._minDelay = minDelay || 10;\r\n\t\t\t\tthis._obj = obj;\r\n\t\t\t\tthis._node = node;\r\n\t\t\t\tthis._currentTimeout = -1;\r\n\t\t\t\tthis._count = -1;\r\n\t\t\t\tthis._callback = lang.hitch(_this, callback);\r\n\t\t\t\tthis._evt = { faux: true };\r\n\t\t\t\tfor(var attr in evt){\r\n\t\t\t\t\tif(attr != \"layerX\" && attr != \"layerY\"){ // prevent WebKit warnings\r\n\t\t\t\t\t\tvar v = evt[attr];\r\n\t\t\t\t\t\tif(typeof v != \"function\" && typeof v != \"undefined\"){\r\n\t\t\t\t\t\t\tthis._evt[attr] = v\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthis._fireEventAndReload();\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tstop: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tStop an ongoing timed, repeating callback sequence.\r\n\t\t\tif(this._timer){\r\n\t\t\t\tclearTimeout(this._timer);\r\n\t\t\t\tthis._timer = null;\r\n\t\t\t}\r\n\t\t\tif(this._obj){\r\n\t\t\t\tthis._callback(-1, this._node, this._evt);\r\n\t\t\t\tthis._obj = null;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\taddKeyListener: function(/*DOMNode*/ node, /*Object*/ keyObject, /*Object*/ _this, /*Function*/ callback, /*Number*/ subsequentDelay, /*Number*/ initialDelay, /*Number?*/ minDelay){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tStart listening for a specific typematic key.\r\n\t\t\t//\t\tSee also the trigger method for other parameters.\r\n\t\t\t// keyObject:\r\n\t\t\t//\t\tan object defining the key to listen for:\r\n\t\t\t//\r\n\t\t\t//\t\t- keyCode: the keyCode (number) to listen for, used for non-printable keys\r\n\t\t\t//\t\t- charCode: the charCode (number) to listen for, used for printable keys\r\n\t\t\t//\t\t- charOrCode: deprecated, use keyCode or charCode\r\n\t\t\t//\t\t- ctrlKey: desired ctrl key state to initiate the callback sequence:\r\n\t\t\t//\t\t\t- pressed (true)\r\n\t\t\t//\t\t\t- released (false)\r\n\t\t\t//\t\t\t- either (unspecified)\r\n\t\t\t//\t\t- altKey: same as ctrlKey but for the alt key\r\n\t\t\t//\t\t- shiftKey: same as ctrlKey but for the shift key\r\n\t\t\t// returns:\r\n\t\t\t//\t\ta connection handle\r\n\r\n\t\t\t// Setup keydown or keypress listener depending on whether keyCode or charCode was specified.\r\n\t\t\t// If charOrCode is specified use deprecated connect._keypress synthetic event (remove for 2.0)\r\n\t\t\tvar type = \"keyCode\" in keyObject ? \"keydown\" : \"charCode\" in keyObject ? \"keypress\" : connect._keypress,\r\n\t\t\t\tattr = \"keyCode\" in keyObject ? \"keyCode\" : \"charCode\" in keyObject ? \"charCode\" : \"charOrCode\";\r\n\r\n\t\t\tvar handles = [\r\n\t\t\t\ton(node, type, lang.hitch(this, function(evt){\r\n\t\t\t\t\tif(evt[attr] == keyObject[attr] &&\r\n\t\t\t\t\t\t(keyObject.ctrlKey === undefined || keyObject.ctrlKey == evt.ctrlKey) &&\r\n\t\t\t\t\t\t(keyObject.altKey === undefined || keyObject.altKey == evt.altKey) &&\r\n\t\t\t\t\t\t(keyObject.metaKey === undefined || keyObject.metaKey == (evt.metaKey || false)) && // IE doesn't even set metaKey\r\n\t\t\t\t\t\t(keyObject.shiftKey === undefined || keyObject.shiftKey == evt.shiftKey)){\r\n\t\t\t\t\t\tevt.stopPropagation();\r\n\t\t\t\t\t\tevt.preventDefault();\r\n\t\t\t\t\t\ttypematic.trigger(evt, _this, node, callback, keyObject, subsequentDelay, initialDelay, minDelay);\r\n\t\t\t\t\t}else if(typematic._obj == keyObject){\r\n\t\t\t\t\t\ttypematic.stop();\r\n\t\t\t\t\t}\r\n\t\t\t\t})),\r\n\t\t\t\ton(node, \"keyup\", lang.hitch(this, function(){\r\n\t\t\t\t\tif(typematic._obj == keyObject){\r\n\t\t\t\t\t\ttypematic.stop();\r\n\t\t\t\t\t}\r\n\t\t\t\t}))\r\n\t\t\t];\r\n\t\t\treturn { remove: function(){\r\n\t\t\t\tarray.forEach(handles, function(h){\r\n\t\t\t\t\th.remove();\r\n\t\t\t\t});\r\n\t\t\t} };\r\n\t\t},\r\n\r\n\t\taddMouseListener: function(/*DOMNode*/ node, /*Object*/ _this, /*Function*/ callback, /*Number*/ subsequentDelay, /*Number*/ initialDelay, /*Number?*/ minDelay){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tStart listening for a typematic mouse click.\r\n\t\t\t//\t\tSee the trigger method for other parameters.\r\n\t\t\t// returns:\r\n\t\t\t//\t\ta connection handle\r\n\t\t\tvar handles = [\r\n\t\t\t\ton(node, \"mousedown\", lang.hitch(this, function(evt){\r\n\t\t\t\t\tevt.preventDefault();\r\n\t\t\t\t\ttypematic.trigger(evt, _this, node, callback, node, subsequentDelay, initialDelay, minDelay);\r\n\t\t\t\t})),\r\n\t\t\t\ton(node, \"mouseup\", lang.hitch(this, function(evt){\r\n\t\t\t\t\tif(this._obj){\r\n\t\t\t\t\t\tevt.preventDefault();\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttypematic.stop();\r\n\t\t\t\t})),\r\n\t\t\t\ton(node, \"mouseout\", lang.hitch(this, function(evt){\r\n\t\t\t\t\tif(this._obj){\r\n\t\t\t\t\t\tevt.preventDefault();\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttypematic.stop();\r\n\t\t\t\t})),\r\n\t\t\t\ton(node, \"dblclick\", lang.hitch(this, function(evt){\r\n\t\t\t\t\tevt.preventDefault();\r\n\t\t\t\t\tif(has(\"ie\") < 9){\r\n\t\t\t\t\t\ttypematic.trigger(evt, _this, node, callback, node, subsequentDelay, initialDelay, minDelay);\r\n\t\t\t\t\t\tsetTimeout(lang.hitch(this, typematic.stop), 50);\r\n\t\t\t\t\t}\r\n\t\t\t\t}))\r\n\t\t\t];\r\n\t\t\treturn { remove: function(){\r\n\t\t\t\tarray.forEach(handles, function(h){\r\n\t\t\t\t\th.remove();\r\n\t\t\t\t});\r\n\t\t\t} };\r\n\t\t},\r\n\r\n\t\taddListener: function(/*Node*/ mouseNode, /*Node*/ keyNode, /*Object*/ keyObject, /*Object*/ _this, /*Function*/ callback, /*Number*/ subsequentDelay, /*Number*/ initialDelay, /*Number?*/ minDelay){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tStart listening for a specific typematic key and mouseclick.\r\n\t\t\t//\t\tThis is a thin wrapper to addKeyListener and addMouseListener.\r\n\t\t\t//\t\tSee the addMouseListener and addKeyListener methods for other parameters.\r\n\t\t\t// mouseNode:\r\n\t\t\t//\t\tthe DOM node object to listen on for mouse events.\r\n\t\t\t// keyNode:\r\n\t\t\t//\t\tthe DOM node object to listen on for key events.\r\n\t\t\t// returns:\r\n\t\t\t//\t\ta connection handle\r\n\t\t\tvar handles = [\r\n\t\t\t\tthis.addKeyListener(keyNode, keyObject, _this, callback, subsequentDelay, initialDelay, minDelay),\r\n\t\t\t\tthis.addMouseListener(mouseNode, _this, callback, subsequentDelay, initialDelay, minDelay)\r\n\t\t\t];\r\n\t\t\treturn { remove: function(){\r\n\t\t\t\tarray.forEach(handles, function(h){\r\n\t\t\t\t\th.remove();\r\n\t\t\t\t});\r\n\t\t\t} };\r\n\t\t}\r\n\t});\r\n\r\n\treturn typematic;\r\n});\r\n"]}