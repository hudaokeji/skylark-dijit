{"version":3,"sources":["tree/dndSource.js"],"names":["define","array","declare","dndCommon","domClass","domGeometry","lang","on","touch","topic","DNDManager","_dndSelector","isSource","accept","copyOnly","dragThreshold","betweenThreshold","generateText","constructor","tree","params","mixin","this","type","Array","length","i","isDragging","mouseDown","targetAnchor","targetBox","dropPosition","_lastX","_lastY","sourceState","add","node","targetState","topics","subscribe","hitch","checkAcceptance","copyState","keyPressed","destroy","h","inherited","arguments","pop","remove","_onDragMouse","e","firstTime","m","manager","oldTarget","newTarget","current","oldDropPosition","newDropPosition","position","rowNode","pageY","y","_removeItemClass","_addItemClass","rootNode","canDrop","dropOntoSelf","dropOntoParent","source","dragId","selection","dragNode","item","getParent","id","_isParentChildDrop","checkItemAcceptance","toLowerCase","onMouseMove","Math","abs","pageX","nodes","getSelectedTreeNodes","n","p","seen","r","nextitem","push","map","domNode","startDrag","getCopyKeyState","onMouseDown","mouseButton","button","onMouseUp","onMouseOut","_unmarkTargetAnchor","onDndSourceOver","onDndStart","copy","_changeState","accepted","overSource","itemCreator","name","textContent","innerText","onDndDrop","containerState","newParentItem","insertIndex","before","newItemsParams","model","target","getIndexInParent","getNextSibling","forEach","idx","sourceItem","getItem","indexOf","childTreeNode","data","childItem","oldParentItem","pasteItem","isItem","newItem","_expandNode","onDndCancel","onOverEvent","onOutEvent","outSource","targetRow","root","ids","parentNode","_markDndStatus"],"mappings":"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","file":"../../tree/dndSource.js","sourcesContent":["define([\r\n\t\"dojo/_base/array\", // array.forEach array.indexOf array.map\r\n\t\"dojo/_base/declare\", // declare\r\n\t\"dojo/dnd/common\",\r\n\t\"dojo/dom-class\", // domClass.add\r\n\t\"dojo/dom-geometry\", // domGeometry.position\r\n\t\"dojo/_base/lang\", // lang.mixin lang.hitch\r\n\t\"dojo/on\", // subscribe\r\n\t\"dojo/touch\",\r\n\t\"dojo/topic\",\r\n\t\"dojo/dnd/Manager\", // DNDManager.manager\r\n\t\"./_dndSelector\"\r\n], function(array, declare, dndCommon, domClass, domGeometry, lang, on, touch, topic, DNDManager, _dndSelector){\r\n\r\n\t// module:\r\n\t//\t\tdijit/tree/dndSource\r\n\r\n\t/*=====\r\n\tvar __Item = {\r\n\t\t// summary:\r\n\t\t//\t\tNew item to be added to the Tree, like:\r\n\t\t// id: Anything\r\n\t\tid: \"\",\r\n\t\t// name: String\r\n\t\tname: \"\"\r\n\t};\r\n\t=====*/\r\n\r\n\tvar dndSource = declare(\"dijit.tree.dndSource\", _dndSelector, {\r\n\t\t// summary:\r\n\t\t//\t\tHandles drag and drop operations (as a source or a target) for `dijit.Tree`\r\n\r\n\t\t// isSource: Boolean\r\n\t\t//\t\tCan be used as a DnD source.\r\n\t\tisSource: true,\r\n\r\n\t\t// accept: String[]\r\n\t\t//\t\tList of accepted types (text strings) for the Tree; defaults to\r\n\t\t//\t\t[\"text\"]\r\n\t\taccept: [\"text\", \"treeNode\"],\r\n\r\n\t\t// copyOnly: [private] Boolean\r\n\t\t//\t\tCopy items, if true, use a state of Ctrl key otherwise\r\n\t\tcopyOnly: false,\r\n\r\n\t\t// dragThreshold: Number\r\n\t\t//\t\tThe move delay in pixels before detecting a drag; 5 by default\r\n\t\tdragThreshold: 5,\r\n\r\n\t\t// betweenThreshold: Integer\r\n\t\t//\t\tDistance from upper/lower edge of node to allow drop to reorder nodes\r\n\t\tbetweenThreshold: 0,\r\n\r\n\t\t// Flag used by Avatar.js to signal to generate text node when dragging\r\n\t\tgenerateText: true,\r\n\r\n\t\tconstructor: function(/*dijit/Tree*/ tree, /*dijit/tree/dndSource*/ params){\r\n\t\t\t// summary:\r\n\t\t\t//\t\ta constructor of the Tree DnD Source\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\tif(!params){\r\n\t\t\t\tparams = {};\r\n\t\t\t}\r\n\t\t\tlang.mixin(this, params);\r\n\t\t\tvar type = params.accept instanceof Array ? params.accept : [\"text\", \"treeNode\"];\r\n\t\t\tthis.accept = null;\r\n\t\t\tif(type.length){\r\n\t\t\t\tthis.accept = {};\r\n\t\t\t\tfor(var i = 0; i < type.length; ++i){\r\n\t\t\t\t\tthis.accept[type[i]] = 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// class-specific variables\r\n\t\t\tthis.isDragging = false;\r\n\t\t\tthis.mouseDown = false;\r\n\t\t\tthis.targetAnchor = null;\t// DOMNode corresponding to the currently moused over TreeNode\r\n\t\t\tthis.targetBox = null;\t// coordinates of this.targetAnchor\r\n\t\t\tthis.dropPosition = \"\";\t// whether mouse is over/after/before this.targetAnchor\r\n\t\t\tthis._lastX = 0;\r\n\t\t\tthis._lastY = 0;\r\n\r\n\t\t\t// states\r\n\t\t\tthis.sourceState = \"\";\r\n\t\t\tif(this.isSource){\r\n\t\t\t\tdomClass.add(this.node, \"dojoDndSource\");\r\n\t\t\t}\r\n\t\t\tthis.targetState = \"\";\r\n\t\t\tif(this.accept){\r\n\t\t\t\tdomClass.add(this.node, \"dojoDndTarget\");\r\n\t\t\t}\r\n\r\n\t\t\t// set up events\r\n\t\t\tthis.topics = [\r\n\t\t\t\ttopic.subscribe(\"/dnd/source/over\", lang.hitch(this, \"onDndSourceOver\")),\r\n\t\t\t\ttopic.subscribe(\"/dnd/start\", lang.hitch(this, \"onDndStart\")),\r\n\t\t\t\ttopic.subscribe(\"/dnd/drop\", lang.hitch(this, \"onDndDrop\")),\r\n\t\t\t\ttopic.subscribe(\"/dnd/cancel\", lang.hitch(this, \"onDndCancel\"))\r\n\t\t\t];\r\n\t\t},\r\n\r\n\t\t// methods\r\n\t\tcheckAcceptance: function(/*===== source, nodes =====*/){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tChecks if the target can accept nodes from this source\r\n\t\t\t// source: dijit/tree/dndSource\r\n\t\t\t//\t\tThe source which provides items\r\n\t\t\t// nodes: DOMNode[]\r\n\t\t\t//\t\tArray of DOM nodes corresponding to nodes being dropped, dijitTreeRow nodes if\r\n\t\t\t//\t\tsource is a dijit/Tree.\r\n\t\t\t// tags:\r\n\t\t\t//\t\textension\r\n\t\t\treturn true;\t// Boolean\r\n\t\t},\r\n\r\n\t\tcopyState: function(keyPressed){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns true, if we need to copy items, false to move.\r\n\t\t\t//\t\tIt is separated to be overwritten dynamically, if needed.\r\n\t\t\t// keyPressed: Boolean\r\n\t\t\t//\t\tThe \"copy\" control key was pressed\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\t\t\treturn this.copyOnly || keyPressed;\t// Boolean\r\n\t\t},\r\n\t\tdestroy: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tPrepares the object to be garbage-collected.\r\n\t\t\tthis.inherited(arguments);\r\n\t\t\tvar h;\r\n\t\t\twhile(h = this.topics.pop()){\r\n\t\t\t\th.remove();\r\n\t\t\t}\r\n\t\t\tthis.targetAnchor = null;\r\n\t\t},\r\n\r\n\t\t_onDragMouse: function(e, firstTime){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tHelper method for processing onmousemove/onmouseover events while drag is in progress.\r\n\t\t\t//\t\tKeeps track of current drop target.\r\n\t\t\t// e: Event\r\n\t\t\t//\t\tThe mousemove event.\r\n\t\t\t// firstTime: Boolean?\r\n\t\t\t//\t\tIf this flag is set, this is the first mouse move event of the drag, so call m.canDrop() etc.\r\n\t\t\t//\t\teven if newTarget == null because the user quickly dragged a node in the Tree to a position\r\n\t\t\t//\t\tover Tree.containerNode but not over any TreeNode (#7971)\r\n\r\n\t\t\tvar m = DNDManager.manager(),\r\n\t\t\t\toldTarget = this.targetAnchor, // the TreeNode corresponding to TreeNode mouse was previously over\r\n\t\t\t\tnewTarget = this.current, // TreeNode corresponding to TreeNode mouse is currently over\r\n\t\t\t\toldDropPosition = this.dropPosition;\t// the previous drop position (over/before/after)\r\n\r\n\t\t\t// calculate if user is indicating to drop the dragged node before, after, or over\r\n\t\t\t// (i.e., to become a child of) the target node\r\n\t\t\tvar newDropPosition = \"Over\";\r\n\t\t\tif(newTarget && this.betweenThreshold > 0){\r\n\t\t\t\t// If mouse is over a new TreeNode, then get new TreeNode's position and size\r\n\t\t\t\tif(!this.targetBox || oldTarget != newTarget){\r\n\t\t\t\t\tthis.targetBox = domGeometry.position(newTarget.rowNode, true);\r\n\t\t\t\t}\r\n\t\t\t\tif((e.pageY - this.targetBox.y) <= this.betweenThreshold){\r\n\t\t\t\t\tnewDropPosition = \"Before\";\r\n\t\t\t\t}else if((e.pageY - this.targetBox.y) >= (this.targetBox.h - this.betweenThreshold)){\r\n\t\t\t\t\tnewDropPosition = \"After\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif(firstTime || newTarget != oldTarget || newDropPosition != oldDropPosition){\r\n\t\t\t\tif(oldTarget){\r\n\t\t\t\t\tthis._removeItemClass(oldTarget.rowNode, oldDropPosition);\r\n\t\t\t\t}\r\n\t\t\t\tif(newTarget){\r\n\t\t\t\t\tthis._addItemClass(newTarget.rowNode, newDropPosition);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Check if it's ok to drop the dragged node on/before/after the target node.\r\n\t\t\t\tif(!newTarget){\r\n\t\t\t\t\tm.canDrop(false);\r\n\t\t\t\t}else if(newTarget == this.tree.rootNode && newDropPosition != \"Over\"){\r\n\t\t\t\t\t// Can't drop before or after tree's root node; the dropped node would just disappear (at least visually)\r\n\t\t\t\t\tm.canDrop(false);\r\n\t\t\t\t}else{\r\n\t\t\t\t\t// Guard against dropping onto yourself or your parent.\r\n\t\t\t\t\t// But when dragging multiple objects, it's OK if some of them are being dropped onto own parent.\r\n\t\t\t\t\tvar dropOntoSelf = false,\r\n\t\t\t\t\t\tdropOntoParent = false;\r\n\t\t\t\t\tif(m.source == this){\r\n\t\t\t\t\t\tdropOntoParent = (newDropPosition === \"Over\");\r\n\t\t\t\t\t\tfor(var dragId in this.selection){\r\n\t\t\t\t\t\t\tvar dragNode = this.selection[dragId];\r\n\t\t\t\t\t\t\tif(dragNode.item === newTarget.item){\r\n\t\t\t\t\t\t\t\tdropOntoSelf = true;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif(dragNode.getParent().id !== newTarget.id){\r\n\t\t\t\t\t\t\t\tdropOntoParent = false;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tm.canDrop(\r\n\t\t\t\t\t\t!dropOntoSelf && !dropOntoParent &&\r\n\t\t\t\t\t\t!this._isParentChildDrop(m.source, newTarget.rowNode) &&\r\n\t\t\t\t\t\tthis.checkItemAcceptance(newTarget.rowNode, m.source, newDropPosition.toLowerCase())\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.targetAnchor = newTarget;\r\n\t\t\t\tthis.dropPosition = newDropPosition;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tonMouseMove: function(e){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCalled for any onmousemove/ontouchmove events over the Tree\r\n\t\t\t// e: Event\r\n\t\t\t//\t\tonmousemouse/ontouchmove event\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\tif(this.isDragging && this.targetState == \"Disabled\"){\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tthis.inherited(arguments);\r\n\t\t\tvar m = DNDManager.manager();\r\n\t\t\tif(this.isDragging){\r\n\t\t\t\tthis._onDragMouse(e);\r\n\t\t\t}else{\r\n\t\t\t\tif(this.mouseDown && this.isSource &&\r\n\t\t\t\t\t(Math.abs(e.pageX - this._lastX) >= this.dragThreshold || Math.abs(e.pageY - this._lastY) >= this.dragThreshold)){\r\n\t\t\t\t\tvar nodes = this.getSelectedTreeNodes();\r\n\t\t\t\t\tif(nodes.length){\r\n\t\t\t\t\t\tif(nodes.length > 1){\r\n\t\t\t\t\t\t\t//filter out all selected items which has one of their ancestor selected as well\r\n\t\t\t\t\t\t\tvar seen = this.selection, i = 0, r = [], n, p;\r\n\t\t\t\t\t\t\tnextitem: while((n = nodes[i++])){\r\n\t\t\t\t\t\t\t\tfor(p = n.getParent(); p && p !== this.tree; p = p.getParent()){\r\n\t\t\t\t\t\t\t\t\tif(seen[p.id]){ //parent is already selected, skip this node\r\n\t\t\t\t\t\t\t\t\t\tcontinue nextitem;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t//this node does not have any ancestors selected, add it\r\n\t\t\t\t\t\t\t\tr.push(n);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tnodes = r;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tnodes = array.map(nodes, function(n){\r\n\t\t\t\t\t\t\treturn n.domNode\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tm.startDrag(this, nodes, this.copyState(dndCommon.getCopyKeyState(e)));\r\n\t\t\t\t\t\tthis._onDragMouse(e, true);\t// because this may be the only mousemove event we get before the drop\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tonMouseDown: function(e){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tEvent processor for onmousedown/ontouchstart\r\n\t\t\t// e: Event\r\n\t\t\t//\t\tonmousedown/ontouchend event\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\tthis.mouseDown = true;\r\n\t\t\tthis.mouseButton = e.button;\r\n\t\t\tthis._lastX = e.pageX;\r\n\t\t\tthis._lastY = e.pageY;\r\n\t\t\tthis.inherited(arguments);\r\n\t\t},\r\n\r\n\t\tonMouseUp: function(e){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tEvent processor for onmouseup/ontouchend\r\n\t\t\t// e: Event\r\n\t\t\t//\t\tonmouseup/ontouchend event\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\tif(this.mouseDown){\r\n\t\t\t\tthis.mouseDown = false;\r\n\t\t\t\tthis.inherited(arguments);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tonMouseOut: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tEvent processor for when mouse is moved away from a TreeNode\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\tthis.inherited(arguments);\r\n\t\t\tthis._unmarkTargetAnchor();\r\n\t\t},\r\n\r\n\t\tcheckItemAcceptance: function(/*===== target, source, position =====*/){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tStub function to be overridden if one wants to check for the ability to drop at the node/item level\r\n\t\t\t// description:\r\n\t\t\t//\t\tIn the base case, this is called to check if target can become a child of source.\r\n\t\t\t//\t\tWhen betweenThreshold is set, position=\"before\" or \"after\" means that we\r\n\t\t\t//\t\tare asking if the source node can be dropped before/after the target node.\r\n\t\t\t// target: DOMNode\r\n\t\t\t//\t\tThe dijitTreeRoot DOM node inside of the TreeNode that we are dropping on to\r\n\t\t\t//\t\tUse dijit.getEnclosingWidget(target) to get the TreeNode.\r\n\t\t\t// source: dijit/tree/dndSource\r\n\t\t\t//\t\tThe (set of) nodes we are dropping\r\n\t\t\t// position: String\r\n\t\t\t//\t\t\"over\", \"before\", or \"after\"\r\n\t\t\t// tags:\r\n\t\t\t//\t\textension\r\n\t\t\treturn true;\r\n\t\t},\r\n\r\n\t\t// topic event processors\r\n\t\tonDndSourceOver: function(source){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tTopic event processor for /dnd/source/over, called when detected a current source.\r\n\t\t\t// source: Object\r\n\t\t\t//\t\tThe dijit/tree/dndSource / dojo/dnd/Source which has the mouse over it\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\tif(this != source){\r\n\t\t\t\tthis.mouseDown = false;\r\n\t\t\t\tthis._unmarkTargetAnchor();\r\n\t\t\t}else if(this.isDragging){\r\n\t\t\t\tvar m = DNDManager.manager();\r\n\t\t\t\tm.canDrop(false);\r\n\t\t\t}\r\n\t\t},\r\n\t\tonDndStart: function(source, nodes, copy){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tTopic event processor for /dnd/start, called to initiate the DnD operation\r\n\t\t\t// source: Object\r\n\t\t\t//\t\tThe dijit/tree/dndSource / dojo/dnd/Source which is providing the items\r\n\t\t\t// nodes: DomNode[]\r\n\t\t\t//\t\tThe list of transferred items, dndTreeNode nodes if dragging from a Tree\r\n\t\t\t// copy: Boolean\r\n\t\t\t//\t\tCopy items, if true, move items otherwise\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\r\n\t\t\tif(this.isSource){\r\n\t\t\t\tthis._changeState(\"Source\", this == source ? (copy ? \"Copied\" : \"Moved\") : \"\");\r\n\t\t\t}\r\n\t\t\tvar accepted = this.checkAcceptance(source, nodes);\r\n\r\n\t\t\tthis._changeState(\"Target\", accepted ? \"\" : \"Disabled\");\r\n\r\n\t\t\tif(this == source){\r\n\t\t\t\tDNDManager.manager().overSource(this);\r\n\t\t\t}\r\n\r\n\t\t\tthis.isDragging = true;\r\n\t\t},\r\n\r\n\t\titemCreator: function(nodes /*===== , target, source =====*/){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns objects passed to `Tree.model.newItem()` based on DnD nodes\r\n\t\t\t//\t\tdropped onto the tree.   Developer must override this method to enable\r\n\t\t\t//\t\tdropping from external sources onto this Tree, unless the Tree.model's items\r\n\t\t\t//\t\thappen to look like {id: 123, name: \"Apple\" } with no other attributes.\r\n\t\t\t// description:\r\n\t\t\t//\t\tFor each node in nodes[], which came from source, create a hash of name/value\r\n\t\t\t//\t\tpairs to be passed to Tree.model.newItem().  Returns array of those hashes.\r\n\t\t\t// nodes: DomNode[]\r\n\t\t\t// target: DomNode\r\n\t\t\t// source: dojo/dnd/Source\r\n\t\t\t// returns: __Item[]\r\n\t\t\t//\t\tArray of name/value hashes for each new item to be added to the Tree\r\n\t\t\t// tags:\r\n\t\t\t//\t\textension\r\n\r\n\t\t\t// TODO: for 2.0 refactor so itemCreator() is called once per drag node, and\r\n\t\t\t// make signature itemCreator(sourceItem, node, target) (or similar).\r\n\r\n\t\t\treturn array.map(nodes, function(node){\r\n\t\t\t\treturn {\r\n\t\t\t\t\t\"id\": node.id,\r\n\t\t\t\t\t\"name\": node.textContent || node.innerText || \"\"\r\n\t\t\t\t};\r\n\t\t\t}); // Object[]\r\n\t\t},\r\n\r\n\t\tonDndDrop: function(source, nodes, copy){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tTopic event processor for /dnd/drop, called to finish the DnD operation.\r\n\t\t\t// description:\r\n\t\t\t//\t\tUpdates data store items according to where node was dragged from and dropped\r\n\t\t\t//\t\tto.   The tree will then respond to those data store updates and redraw itself.\r\n\t\t\t// source: Object\r\n\t\t\t//\t\tThe dijit/tree/dndSource / dojo/dnd/Source which is providing the items\r\n\t\t\t// nodes: DomNode[]\r\n\t\t\t//\t\tThe list of transferred items, dndTreeNode nodes if dragging from a Tree\r\n\t\t\t// copy: Boolean\r\n\t\t\t//\t\tCopy items, if true, move items otherwise\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\t\t\tif(this.containerState == \"Over\"){\r\n\t\t\t\tvar tree = this.tree,\r\n\t\t\t\t\tmodel = tree.model,\r\n\t\t\t\t\ttarget = this.targetAnchor;\r\n\r\n\t\t\t\tthis.isDragging = false;\r\n\r\n\t\t\t\t// Compute the new parent item\r\n\t\t\t\tvar newParentItem;\r\n\t\t\t\tvar insertIndex;\r\n\t\t\t\tvar before;\t\t// drop source before (aka previous sibling) of target\r\n\t\t\t\tnewParentItem = (target && target.item) || tree.item;\r\n\t\t\t\tif(this.dropPosition == \"Before\" || this.dropPosition == \"After\"){\r\n\t\t\t\t\t// TODO: if there is no parent item then disallow the drop.\r\n\t\t\t\t\t// Actually this should be checked during onMouseMove too, to make the drag icon red.\r\n\t\t\t\t\tnewParentItem = (target.getParent() && target.getParent().item) || tree.item;\r\n\t\t\t\t\t// Compute the insert index for reordering\r\n\t\t\t\t\tinsertIndex = target.getIndexInParent();\r\n\t\t\t\t\tif(this.dropPosition == \"After\"){\r\n\t\t\t\t\t\tinsertIndex = target.getIndexInParent() + 1;\r\n\t\t\t\t\t\tbefore = target.getNextSibling() && target.getNextSibling().item;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tbefore = target.item;\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tnewParentItem = (target && target.item) || tree.item;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// If necessary, use this variable to hold array of hashes to pass to model.newItem()\r\n\t\t\t\t// (one entry in the array for each dragged node).\r\n\t\t\t\tvar newItemsParams;\r\n\r\n\t\t\t\tarray.forEach(nodes, function(node, idx){\r\n\t\t\t\t\t// dojo/dnd/Item representing the thing being dropped.\r\n\t\t\t\t\t// Don't confuse the use of item here (meaning a DnD item) with the\r\n\t\t\t\t\t// uses below where item means dojo.data item.\r\n\t\t\t\t\tvar sourceItem = source.getItem(node.id);\r\n\r\n\t\t\t\t\t// Information that's available if the source is another Tree\r\n\t\t\t\t\t// (possibly but not necessarily this tree, possibly but not\r\n\t\t\t\t\t// necessarily the same model as this Tree)\r\n\t\t\t\t\tif(array.indexOf(sourceItem.type, \"treeNode\") != -1){\r\n\t\t\t\t\t\tvar childTreeNode = sourceItem.data,\r\n\t\t\t\t\t\t\tchildItem = childTreeNode.item,\r\n\t\t\t\t\t\t\toldParentItem = childTreeNode.getParent().item;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif(source == this){\r\n\t\t\t\t\t\t// This is a node from my own tree, and we are moving it, not copying.\r\n\t\t\t\t\t\t// Remove item from old parent's children attribute.\r\n\t\t\t\t\t\t// TODO: dijit/tree/dndSelector should implement deleteSelectedNodes()\r\n\t\t\t\t\t\t// and this code should go there.\r\n\r\n\t\t\t\t\t\tif(typeof insertIndex == \"number\"){\r\n\t\t\t\t\t\t\tif(newParentItem == oldParentItem && childTreeNode.getIndexInParent() < insertIndex){\r\n\t\t\t\t\t\t\t\tinsertIndex -= 1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tmodel.pasteItem(childItem, oldParentItem, newParentItem, copy, insertIndex, before);\r\n\t\t\t\t\t}else if(model.isItem(childItem)){\r\n\t\t\t\t\t\t// Item from same model\r\n\t\t\t\t\t\t// (maybe we should only do this branch if the source is a tree?)\r\n\t\t\t\t\t\tmodel.pasteItem(childItem, oldParentItem, newParentItem, copy, insertIndex, before);\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\t// Get the hash to pass to model.newItem().  A single call to\r\n\t\t\t\t\t\t// itemCreator() returns an array of hashes, one for each drag source node.\r\n\t\t\t\t\t\tif(!newItemsParams){\r\n\t\t\t\t\t\t\tnewItemsParams = this.itemCreator(nodes, target.rowNode, source);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Create new item in the tree, based on the drag source.\r\n\t\t\t\t\t\tmodel.newItem(newItemsParams[idx], newParentItem, insertIndex, before);\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this);\r\n\r\n\t\t\t\t// Expand the target node (if it's currently collapsed) so the user can see\r\n\t\t\t\t// where their node was dropped.   In particular since that node is still selected.\r\n\t\t\t\tthis.tree._expandNode(target);\r\n\t\t\t}\r\n\t\t\tthis.onDndCancel();\r\n\t\t},\r\n\r\n\t\tonDndCancel: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tTopic event processor for /dnd/cancel, called to cancel the DnD operation\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\tthis._unmarkTargetAnchor();\r\n\t\t\tthis.isDragging = false;\r\n\t\t\tthis.mouseDown = false;\r\n\t\t\tdelete this.mouseButton;\r\n\t\t\tthis._changeState(\"Source\", \"\");\r\n\t\t\tthis._changeState(\"Target\", \"\");\r\n\t\t},\r\n\r\n\t\t// When focus moves in/out of the entire Tree\r\n\t\tonOverEvent: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tThis method is called when mouse is moved over our container (like onmouseenter)\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\tthis.inherited(arguments);\r\n\t\t\tDNDManager.manager().overSource(this);\r\n\t\t},\r\n\t\tonOutEvent: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tThis method is called when mouse is moved out of our container (like onmouseleave)\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\tthis._unmarkTargetAnchor();\r\n\t\t\tvar m = DNDManager.manager();\r\n\t\t\tif(this.isDragging){\r\n\t\t\t\tm.canDrop(false);\r\n\t\t\t}\r\n\t\t\tm.outSource(this);\r\n\r\n\t\t\tthis.inherited(arguments);\r\n\t\t},\r\n\r\n\t\t_isParentChildDrop: function(source, targetRow){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tChecks whether the dragged items are parent rows in the tree which are being\r\n\t\t\t//\t\tdragged into their own children.\r\n\t\t\t//\r\n\t\t\t// source:\r\n\t\t\t//\t\tThe DragSource object.\r\n\t\t\t//\r\n\t\t\t// targetRow:\r\n\t\t\t//\t\tThe tree row onto which the dragged nodes are being dropped.\r\n\t\t\t//\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\r\n\t\t\t// If the dragged object is not coming from the tree this widget belongs to,\r\n\t\t\t// it cannot be invalid.\r\n\t\t\tif(!source.tree || source.tree != this.tree){\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\r\n\t\t\tvar root = source.tree.domNode;\r\n\t\t\tvar ids = source.selection;\r\n\r\n\t\t\tvar node = targetRow.parentNode;\r\n\r\n\t\t\t// Iterate up the DOM hierarchy from the target drop row,\r\n\t\t\t// checking of any of the dragged nodes have the same ID.\r\n\t\t\twhile(node != root && !ids[node.id]){\r\n\t\t\t\tnode = node.parentNode;\r\n\t\t\t}\r\n\r\n\t\t\treturn node.id && ids[node.id];\r\n\t\t},\r\n\r\n\t\t_unmarkTargetAnchor: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tRemoves hover class of the current target anchor\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\tif(!this.targetAnchor){\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tthis._removeItemClass(this.targetAnchor.rowNode, this.dropPosition);\r\n\t\t\tthis.targetAnchor = null;\r\n\t\t\tthis.targetBox = null;\r\n\t\t\tthis.dropPosition = null;\r\n\t\t},\r\n\r\n\t\t_markDndStatus: function(copy){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tChanges source's state based on \"copy\" status\r\n\t\t\tthis._changeState(\"Source\", copy ? \"Copied\" : \"Moved\");\r\n\t\t}\r\n\t});\r\n\r\n\t/*=====\r\n\tdndSource.__Item = __Item;\r\n\t=====*/\r\n\r\n\treturn dndSource;\r\n});\r\n"]}