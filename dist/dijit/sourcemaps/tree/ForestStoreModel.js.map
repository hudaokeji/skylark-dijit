{"version":3,"sources":["tree/ForestStoreModel.js"],"names":["define","array","declare","kernel","lang","TreeStoreModel","rootId","rootLabel","query","constructor","params","this","root","store","id","label","children","rootChildren","mayHaveChildren","item","inherited","arguments","getChildren","parentItem","callback","onError","fetch","onComplete","hitch","items","isItem","something","fetchItemByIdentity","keywordArgs","identity","scope","global","onItem","call","getIdentity","getLabel","newItem","args","parent","insertIndex","onNewRootItem","pasteItem","childItem","oldParentItem","newParentItem","bCopy","onLeaveRoot","onAddToRoot","console","log","_requeryTop","oldChildren","newChildren","length","some","idx","onChildrenChange","onNewItem","parentInfo","onDeleteItem","indexOf","onSetItem","attribute","oldValue","newValue"],"mappings":";;;;;;;AAAAA,QACC,mBACA,qBACA,oBACA,kBACA,oBACE,SAASC,EAAOC,EAASC,EAAQC,EAAMC,GAK1C,OAAOH,EAAQ,8BAA+BG,GAwB7CC,OAAQ,SAIRC,UAAW,OAMXC,MAAO,KAIPC,YAAa,SAASC,GAOrBC,KAAKC,MACJC,MAAOF,KACPC,MAAM,EACNE,GAAIJ,EAAOJ,OACXS,MAAOL,EAAOH,UACdS,SAAUN,EAAOO,eAOnBC,gBAAiB,SAA4BC,GAQ5C,OAAOA,IAASR,KAAKC,MAAQD,KAAKS,UAAUC,YAG7CC,YAAa,SAA4BC,EAAgCC,EAAuBC,GAG5FF,IAAeZ,KAAKC,KACnBD,KAAKC,KAAKI,SAEZQ,EAASb,KAAKC,KAAKI,UAEnBL,KAAKE,MAAMa,OACVlB,MAAOG,KAAKH,MACZmB,WAAYvB,EAAKwB,MAAMjB,KAAM,SAASkB,GACrClB,KAAKC,KAAKI,SAAWa,EACrBL,EAASK,KAEVJ,QAASA,IAIXd,KAAKS,UAAUC,YAOjBS,OAAQ,SAAwBC,GAC/B,OAAQA,IAAcpB,KAAKC,MAAeD,KAAKS,UAAUC,YAG1DW,oBAAqB,SAAsBC,GAC1C,GAAGA,EAAYC,UAAYvB,KAAKC,KAAKE,GAAG,CACvC,IAAIqB,EAAQF,EAAYE,OAAShC,EAAOiC,OACrCH,EAAYI,QACdJ,EAAYI,OAAOC,KAAKH,EAAOxB,KAAKC,WAGrCD,KAAKS,UAAUC,YAIjBkB,YAAa,SAAoBpB,GAChC,OAAQA,IAASR,KAAKC,KAAQD,KAAKC,KAAKE,GAAKH,KAAKS,UAAUC,YAG7DmB,SAAU,SAAoBrB,GAC7B,OAAQA,IAASR,KAAKC,KAAQD,KAAKC,KAAKG,MAAQJ,KAAKS,UAAUC,YAMhEoB,QAAS,SAA2CC,EAAeC,EAAiBC,GAInF,OAAGD,IAAWhC,KAAKC,MAClBD,KAAKkC,cAAcH,GACZ/B,KAAKE,MAAM4B,QAAQC,IAEnB/B,KAAKS,UAAUC,YAIxBwB,cAAe,aAMfC,UAAW,SAAkBC,EAAoBC,EAAwBC,EAA2BC,EAAgBN,GAIhHI,IAAkBrC,KAAKC,OACrBsC,GAIHvC,KAAKwC,YAAYJ,IAGnBpC,KAAKS,UAAUC,WAAY0B,EAC1BC,IAAkBrC,KAAKC,KAAO,KAAOoC,EACrCC,IAAkBtC,KAAKC,KAAO,KAAOqC,EACrCC,EACAN,IAEEK,IAAkBtC,KAAKC,MAIzBD,KAAKyC,YAAYL,IAOnBK,YAAa,SAAoBjC,GAQhCkC,QAAQC,IAAI3C,KAAM,UAAWQ,EAAM,mBAGpCgC,YAAa,SAAoBhC,GAQhCkC,QAAQC,IAAI3C,KAAM,UAAWQ,EAAM,uBAMpCoC,YAAa,WAGZ,IAAIC,EAAc7C,KAAKC,KAAKI,aAC5BL,KAAKE,MAAMa,OACVlB,MAAOG,KAAKH,MACZmB,WAAYvB,EAAKwB,MAAMjB,KAAM,SAAS8C,GACrC9C,KAAKC,KAAKI,SAAWyC,GAGlBD,EAAYE,QAAUD,EAAYC,QACpCzD,EAAM0D,KAAKH,EAAa,SAASrC,EAAMyC,GAAM,OAAOH,EAAYG,IAAQzC,MACxER,KAAKkD,iBAAiBlD,KAAKC,KAAM6C,QAMrCK,UAAW,SAAkC3C,EAAmB4C,GAe/DpD,KAAK4C,cAEL5C,KAAKS,UAAUC,YAGhB2C,aAAc,SAAoB7C,IAMc,GAA5ClB,EAAMgE,QAAQtD,KAAKC,KAAKI,SAAUG,IACpCR,KAAK4C,cAGN5C,KAAKS,UAAUC,YAGhB6C,UAAW,SAAoB/C,EACCgD,EACTC,EACAC,GAgBtB1D,KAAK4C,cACL5C,KAAKS,UAAUC","file":"../../tree/ForestStoreModel.js","sourcesContent":["define([\r\n\t\"dojo/_base/array\", // array.indexOf array.some\r\n\t\"dojo/_base/declare\", // declare\r\n\t\"dojo/_base/kernel\", // global\r\n\t\"dojo/_base/lang\", // lang.hitch\r\n\t\"./TreeStoreModel\"\r\n], function(array, declare, kernel, lang, TreeStoreModel){\r\n\r\n// module:\r\n//\t\tdijit/tree/ForestStoreModel\r\n\r\nreturn declare(\"dijit.tree.ForestStoreModel\", TreeStoreModel, {\r\n\t// summary:\r\n\t//\t\tInterface between a dijit.Tree and a dojo.data store that doesn't have a root item,\r\n\t//\t\ta.k.a. a store that has multiple \"top level\" items.\r\n\t//\r\n\t// description:\r\n\t//\t\tUse this class to wrap a dojo.data store, making all the items matching the specified query\r\n\t//\t\tappear as children of a fabricated \"root item\".  If no query is specified then all the\r\n\t//\t\titems returned by fetch() on the underlying store become children of the root item.\r\n\t//\t\tThis class allows dijit.Tree to assume a single root item, even if the store doesn't have one.\r\n\t//\r\n\t//\t\tWhen using this class the developer must override a number of methods according to their app and\r\n\t//\t\tdata, including:\r\n\t//\r\n\t//\t\t- onNewRootItem\r\n\t//\t\t- onAddToRoot\r\n\t//\t\t- onLeaveRoot\r\n\t//\t\t- onNewItem\r\n\t//\t\t- onSetItem\r\n\r\n\t// Parameters to constructor\r\n\r\n\t// rootId: String\r\n\t//\t\tID of fabricated root item\r\n\trootId: \"$root$\",\r\n\r\n\t// rootLabel: String\r\n\t//\t\tLabel of fabricated root item\r\n\trootLabel: \"ROOT\",\r\n\r\n\t// query: String\r\n\t//\t\tSpecifies the set of children of the root item.\r\n\t// example:\r\n\t//\t|\t{type:'continent'}\r\n\tquery: null,\r\n\r\n\t// End of parameters to constructor\r\n\r\n\tconstructor: function(params){\r\n\t\t// summary:\r\n\t\t//\t\tSets up variables, etc.\r\n\t\t// tags:\r\n\t\t//\t\tprivate\r\n\r\n\t\t// Make dummy root item\r\n\t\tthis.root = {\r\n\t\t\tstore: this,\r\n\t\t\troot: true,\r\n\t\t\tid: params.rootId,\r\n\t\t\tlabel: params.rootLabel,\r\n\t\t\tchildren: params.rootChildren\t// optional param\r\n\t\t};\r\n\t},\r\n\r\n\t// =======================================================================\r\n\t// Methods for traversing hierarchy\r\n\r\n\tmayHaveChildren: function(/*dojo/data/Item*/ item){\r\n\t\t// summary:\r\n\t\t//\t\tTells if an item has or may have children.  Implementing logic here\r\n\t\t//\t\tavoids showing +/- expando icon for nodes that we know don't have children.\r\n\t\t//\t\t(For efficiency reasons we may not want to check if an element actually\r\n\t\t//\t\thas children until user clicks the expando node)\r\n\t\t// tags:\r\n\t\t//\t\textension\r\n\t\treturn item === this.root || this.inherited(arguments);\r\n\t},\r\n\r\n\tgetChildren: function(/*dojo/data/Item*/ parentItem, /*function(items)*/ callback, /*function*/ onError){\r\n\t\t// summary:\r\n\t\t//\t\tCalls onComplete() with array of child items of given parent item, all loaded.\r\n\t\tif(parentItem === this.root){\r\n\t\t\tif(this.root.children){\r\n\t\t\t\t// already loaded, just return\r\n\t\t\t\tcallback(this.root.children);\r\n\t\t\t}else{\r\n\t\t\t\tthis.store.fetch({\r\n\t\t\t\t\tquery: this.query,\r\n\t\t\t\t\tonComplete: lang.hitch(this, function(items){\r\n\t\t\t\t\t\tthis.root.children = items;\r\n\t\t\t\t\t\tcallback(items);\r\n\t\t\t\t\t}),\r\n\t\t\t\t\tonError: onError\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tthis.inherited(arguments);\r\n\t\t}\r\n\t},\r\n\r\n\t// =======================================================================\r\n\t// Inspecting items\r\n\r\n\tisItem: function(/* anything */ something){\r\n\t\treturn (something === this.root) ? true : this.inherited(arguments);\r\n\t},\r\n\r\n\tfetchItemByIdentity: function(/* object */ keywordArgs){\r\n\t\tif(keywordArgs.identity == this.root.id){\r\n\t\t\tvar scope = keywordArgs.scope || kernel.global;\r\n\t\t\tif(keywordArgs.onItem){\r\n\t\t\t\tkeywordArgs.onItem.call(scope, this.root);\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tthis.inherited(arguments);\r\n\t\t}\r\n\t},\r\n\r\n\tgetIdentity: function(/* item */ item){\r\n\t\treturn (item === this.root) ? this.root.id : this.inherited(arguments);\r\n\t},\r\n\r\n\tgetLabel: function(/* item */ item){\r\n\t\treturn\t(item === this.root) ? this.root.label : this.inherited(arguments);\r\n\t},\r\n\r\n\t// =======================================================================\r\n\t// Write interface\r\n\r\n\tnewItem: function(/* dijit/tree/dndSource.__Item */ args, /*Item*/ parent, /*int?*/ insertIndex){\r\n\t\t// summary:\r\n\t\t//\t\tCreates a new item.   See dojo/data/api/Write for details on args.\r\n\t\t//\t\tUsed in drag & drop when item from external source dropped onto tree.\r\n\t\tif(parent === this.root){\r\n\t\t\tthis.onNewRootItem(args);\r\n\t\t\treturn this.store.newItem(args);\r\n\t\t}else{\r\n\t\t\treturn this.inherited(arguments);\r\n\t\t}\r\n\t},\r\n\r\n\tonNewRootItem: function(/* dijit/tree/dndSource.__Item */ /*===== args =====*/){\r\n\t\t// summary:\r\n\t\t//\t\tUser can override this method to modify a new element that's being\r\n\t\t//\t\tadded to the root of the tree, for example to add a flag like root=true\r\n\t},\r\n\r\n\tpasteItem: function(/*Item*/ childItem, /*Item*/ oldParentItem, /*Item*/ newParentItem, /*Boolean*/ bCopy, /*int?*/ insertIndex){\r\n\t\t// summary:\r\n\t\t//\t\tMove or copy an item from one parent item to another.\r\n\t\t//\t\tUsed in drag & drop\r\n\t\tif(oldParentItem === this.root){\r\n\t\t\tif(!bCopy){\r\n\t\t\t\t// It's onLeaveRoot()'s responsibility to modify the item so it no longer matches\r\n\t\t\t\t// this.query... thus triggering an onChildrenChange() event to notify the Tree\r\n\t\t\t\t// that this element is no longer a child of the root node\r\n\t\t\t\tthis.onLeaveRoot(childItem);\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.inherited(arguments, [childItem,\r\n\t\t\toldParentItem === this.root ? null : oldParentItem,\r\n\t\t\tnewParentItem === this.root ? null : newParentItem,\r\n\t\t\tbCopy,\r\n\t\t\tinsertIndex\r\n\t\t]);\r\n\t\tif(newParentItem === this.root){\r\n\t\t\t// It's onAddToRoot()'s responsibility to modify the item so it matches\r\n\t\t\t// this.query... thus triggering an onChildrenChange() event to notify the Tree\r\n\t\t\t// that this element is now a child of the root node\r\n\t\t\tthis.onAddToRoot(childItem);\r\n\t\t}\r\n\t},\r\n\r\n\t// =======================================================================\r\n\t// Handling for top level children\r\n\r\n\tonAddToRoot: function(/* item */ item){\r\n\t\t// summary:\r\n\t\t//\t\tCalled when item added to root of tree; user must override this method\r\n\t\t//\t\tto modify the item so that it matches the query for top level items\r\n\t\t// example:\r\n\t\t//\t|\tstore.setValue(item, \"root\", true);\r\n\t\t// tags:\r\n\t\t//\t\textension\r\n\t\tconsole.log(this, \": item \", item, \" added to root\");\r\n\t},\r\n\r\n\tonLeaveRoot: function(/* item */ item){\r\n\t\t// summary:\r\n\t\t//\t\tCalled when item removed from root of tree; user must override this method\r\n\t\t//\t\tto modify the item so it doesn't match the query for top level items\r\n\t\t// example:\r\n\t\t//\t|\tstore.unsetAttribute(item, \"root\");\r\n\t\t// tags:\r\n\t\t//\t\textension\r\n\t\tconsole.log(this, \": item \", item, \" removed from root\");\r\n\t},\r\n\r\n\t// =======================================================================\r\n\t// Events from data store\r\n\r\n\t_requeryTop: function(){\r\n\t\t// reruns the query for the children of the root node,\r\n\t\t// sending out an onSet notification if those children have changed\r\n\t\tvar oldChildren = this.root.children || [];\r\n\t\tthis.store.fetch({\r\n\t\t\tquery: this.query,\r\n\t\t\tonComplete: lang.hitch(this, function(newChildren){\r\n\t\t\t\tthis.root.children = newChildren;\r\n\r\n\t\t\t\t// If the list of children or the order of children has changed...\r\n\t\t\t\tif(oldChildren.length != newChildren.length ||\r\n\t\t\t\t\tarray.some(oldChildren, function(item, idx){ return newChildren[idx] != item;})){\r\n\t\t\t\t\tthis.onChildrenChange(this.root, newChildren);\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t});\r\n\t},\r\n\r\n\tonNewItem: function(/* dojo/data/api/Item */ item, /* Object */ parentInfo){\r\n\t\t// summary:\r\n\t\t//\t\tHandler for when new items appear in the store.  Developers should override this\r\n\t\t//\t\tmethod to be more efficient based on their app/data.\r\n\t\t// description:\r\n\t\t//\t\tNote that the default implementation requeries the top level items every time\r\n\t\t//\t\ta new item is created, since any new item could be a top level item (even in\r\n\t\t//\t\taddition to being a child of another item, since items can have multiple parents).\r\n\t\t//\r\n\t\t//\t\tIf developers can detect which items are possible top level items (based on the item and the\r\n\t\t//\t\tparentInfo parameters), they should override this method to only call _requeryTop() for top\r\n\t\t//\t\tlevel items.  Often all top level items have parentInfo==null, but\r\n\t\t//\t\tthat will depend on which store you use and what your data is like.\r\n\t\t// tags:\r\n\t\t//\t\textension\r\n\t\tthis._requeryTop();\r\n\r\n\t\tthis.inherited(arguments);\r\n\t},\r\n\r\n\tonDeleteItem: function(/*Object*/ item){\r\n\t\t// summary:\r\n\t\t//\t\tHandler for delete notifications from underlying store\r\n\r\n\t\t// check if this was a child of root, and if so send notification that root's children\r\n\t\t// have changed\r\n\t\tif(array.indexOf(this.root.children, item) != -1){\r\n\t\t\tthis._requeryTop();\r\n\t\t}\r\n\r\n\t\tthis.inherited(arguments);\r\n\t},\r\n\r\n\tonSetItem: function(/* item */ item,\r\n\t\t\t\t\t/* attribute-name-string */ attribute,\r\n\t\t\t\t\t/* Object|Array */ oldValue,\r\n\t\t\t\t\t/* Object|Array */ newValue){\r\n\t\t// summary:\r\n\t\t//\t\tUpdates the tree view according to changes to an item in the data store.\r\n\t\t//\t\tDevelopers should override this method to be more efficient based on their app/data.\r\n\t\t// description:\r\n\t\t//\t\tHandles updates to an item's children by calling onChildrenChange(), and\r\n\t\t//\t\tother updates to an item by calling onChange().\r\n\t\t//\r\n\t\t//\t\tAlso, any change to any item re-executes the query for the tree's top-level items,\r\n\t\t//\t\tsince this modified item may have started/stopped matching the query for top level items.\r\n\t\t//\r\n\t\t//\t\tIf possible, developers should override this function to only call _requeryTop() when\r\n\t\t//\t\tthe change to the item has caused it to stop/start being a top level item in the tree.\r\n\t\t// tags:\r\n\t\t//\t\textension\r\n\r\n\t\tthis._requeryTop();\r\n\t\tthis.inherited(arguments);\r\n\t}\r\n\r\n});\r\n\r\n});\r\n"]}