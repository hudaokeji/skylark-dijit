{"version":3,"sources":["tree/ObjectStoreModel.js"],"names":["define","array","aspect","declare","Deferred","lang","when","Destroyable","store","labelAttr","labelType","root","query","constructor","args","mixin","this","childrenCache","getRoot","onItem","onError","res","then","own","hitch","items","length","Error","observe","obj","onChange","mayHaveChildren","getChildren","parentItem","onComplete","id","getIdentity","removedFrom","insertedInto","isItem","item","getLabel","newItem","parent","insertIndex","before","put","pasteItem","childItem","oldParentItem","newParentItem","bCopy","d","oldParentChildren","concat","index","indexOf","splice","onChildrenChange","resolve","overwrite","oldParent","onDelete"],"mappings":";;;;;;;AAAAA,QACC,mBACA,cACA,qBACA,gBACA,kBACA,YACA,kBACE,SAASC,EAAOC,EAAQC,EAASC,EAAUC,EAAMC,EAAMC,GAKzD,OAAOJ,EAAQ,8BAA+BI,GAkB7CC,MAAO,KAIPC,UAAW,OAKXC,UAAW,OAIXC,KAAM,KAQNC,MAAO,KAEPC,YAAa,SAAsBC,GAMlCT,EAAKU,MAAMC,KAAMF,GAGjBE,KAAKC,kBAMNC,QAAS,SAASC,EAAQC,GAIzB,GAAGJ,KAAKL,KACPQ,EAAOH,KAAKL,UACR,CACJ,IAAIU,EAAML,KAAKR,MAAMI,MAAMI,KAAKJ,OAC7BS,EAAIC,MACNN,KAAKO,IAAIF,GAGVf,EAAKe,EACJhB,EAAKmB,MAAMR,KAAM,SAASS,GAEzB,GAAmB,GAAhBA,EAAMC,OACR,MAAM,IAAIC,MAAM,oDAAsDF,EAAMC,OAC3E,uCAEFV,KAAKL,KAAOc,EAAM,GAClBN,EAAOH,KAAKL,MAGTU,EAAIO,SACNP,EAAIO,QAAQvB,EAAKmB,MAAMR,KAAM,SAASa,GAGrCb,KAAKc,SAASD,MACX,KAGNT,KAKHW,gBAAiB,WAgBhB,OAAO,GAGRC,YAAa,SAAoBC,EAAgCC,EAAyBd,GAkBzF,IAAIe,EAAKnB,KAAKR,MAAM4B,YAAYH,GAEhC,GAAGjB,KAAKC,cAAckB,GAGrB7B,EAAKU,KAAKC,cAAckB,GAAKD,EAAYd,OAH1C,CAWA,IAAIC,EAAML,KAAKC,cAAckB,GAAMnB,KAAKR,MAAMwB,YAAYC,GACvDZ,EAAIC,MACNN,KAAKO,IAAIF,GAIPA,EAAIO,SACNZ,KAAKO,IAAIF,EAAIO,QAAQvB,EAAKmB,MAAMR,KAAM,SAASa,EAAKQ,EAAaC,GAKhEtB,KAAKc,SAASD,GAEXQ,GAAeC,GAGjBhC,EAAKe,EAAKhB,EAAKmB,MAAMR,KAAM,mBAAoBiB,OAE7C,IAIL3B,EAAKe,EAAKa,EAAYd,KAMvBmB,OAAQ,WACP,OAAO,GAGRH,YAAa,SAAoBI,GAChC,OAAOxB,KAAKR,MAAM4B,YAAYI,IAG/BC,SAAU,SAA4BD,GAGrC,OAAOA,EAAKxB,KAAKP,YAMlBiC,QAAS,SAA2C5B,EAAe6B,EAAiBC,EAAsBC,GAKzG,OAAO7B,KAAKR,MAAMsC,IAAIhC,GACrB6B,OAAQA,EACRE,OAAQA,KAIVE,UAAW,SAAkBC,EAAoBC,EAAwBC,EAC1DC,EAAgBP,EAAsBC,GAKpD,IAAIO,EAAI,IAAIhD,EAEZ,OAAG6C,IAAkBC,GAAkBC,GAAUN,GAQ9CI,IAAkBE,EASpBnC,KAAKgB,YAAYiB,EAAe5C,EAAKmB,MAAMR,KAAM,SAASqC,GACzDA,KAAuBC,OAAOD,GAC9B,IAAIE,EAAQtD,EAAMuD,QAAQH,EAAmBL,GAC7CK,EAAkBI,OAAOF,EAAO,GAChCvC,KAAK0C,iBAAiBT,EAAeI,GAErCD,EAAEO,QAAQ3C,KAAKR,MAAMsC,IAAIE,GACxBY,WAAW,EACXjB,OAAQO,EACRW,UAAWZ,EACXJ,OAAQA,QAIVO,EAAEO,QAAQ3C,KAAKR,MAAMsC,IAAIE,GACxBY,WAAW,EACXjB,OAAQO,EACRW,UAAWZ,EACXJ,OAAQA,KAIHO,IAnCNA,EAAEO,SAAQ,GACHP,IAwCTtB,SAAU,aAUV4B,iBAAkB,aAUlBI,SAAU","file":"../../tree/ObjectStoreModel.js","sourcesContent":["define([\r\n\t\"dojo/_base/array\", // array.filter array.forEach array.indexOf array.some\r\n\t\"dojo/aspect\", // aspect.before, aspect.after\r\n\t\"dojo/_base/declare\", // declare\r\n\t\"dojo/Deferred\",\r\n\t\"dojo/_base/lang\", // lang.hitch\r\n\t\"dojo/when\",\r\n\t\"../Destroyable\"\r\n], function(array, aspect, declare, Deferred, lang, when, Destroyable){\r\n\r\n\t// module:\r\n\t//\t\tdijit/tree/ObjectStoreModel\r\n\r\n\treturn declare(\"dijit.tree.ObjectStoreModel\", Destroyable, {\r\n\t\t// summary:\r\n\t\t//\t\tImplements dijit/tree/model connecting dijit/Tree to a dojo/store/api/Store that implements\r\n\t\t//\t\tgetChildren().\r\n\t\t//\r\n\t\t//\t\tIf getChildren() returns an array with an observe() method, then it will be leveraged to reflect\r\n\t\t//\t\tstore updates to the tree.   So, this class will work best when:\r\n\t\t//\r\n\t\t//\t\t\t1. the store implements dojo/store/Observable\r\n\t\t//\t\t\t2. getChildren() is implemented as a query to the server (i.e. it calls store.query())\r\n\t\t//\r\n\t\t//\t\tDrag and Drop: To support drag and drop, besides implementing getChildren()\r\n\t\t//\t\tand dojo/store/Observable, the store must support the parent option to put().\r\n\t\t//\t\tAnd in order to have child elements ordered according to how the user dropped them,\r\n\t\t//\t\tput() must support the before option.\r\n\r\n\t\t// store: dojo/store/api/Store\r\n\t\t//\t\tUnderlying store\r\n\t\tstore: null,\r\n\r\n\t\t// labelAttr: String\r\n\t\t//\t\tGet label for tree node from this attribute\r\n\t\tlabelAttr: \"name\",\r\n\r\n\t\t// labelType: [const] String\r\n\t\t//\t\tSpecifies how to interpret the labelAttr in the data store items.\r\n\t\t//\t\tCan be \"html\" or \"text\".\r\n\t\tlabelType: \"text\",\r\n\r\n\t\t// root: [readonly] Object\r\n\t\t//\t\tPointer to the root item from the dojo/store/api/Store (read only, not a parameter)\r\n\t\troot: null,\r\n\r\n\t\t// query: anything\r\n\t\t//\t\tSpecifies datastore query to return the root item for the tree.\r\n\t\t//\t\tMust only return a single item.   Alternately can just pass in pointer\r\n\t\t//\t\tto root item.\r\n\t\t// example:\r\n\t\t//\t|\t{id:'ROOT'}\r\n\t\tquery: null,\r\n\r\n\t\tconstructor: function(/* Object */ args){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tPassed the arguments listed above (store, etc)\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\r\n\t\t\tlang.mixin(this, args);\r\n\r\n\t\t\t// Map from id of each parent node to array of its children, or to Promise for that array of children.\r\n\t\t\tthis.childrenCache = {};\r\n\t\t},\r\n\r\n\t\t// =======================================================================\r\n\t\t// Methods for traversing hierarchy\r\n\r\n\t\tgetRoot: function(onItem, onError){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCalls onItem with the root item for the tree, possibly a fabricated item.\r\n\t\t\t//\t\tCalls onError on error.\r\n\t\t\tif(this.root){\r\n\t\t\t\tonItem(this.root);\r\n\t\t\t}else{\r\n\t\t\t\tvar res = this.store.query(this.query);\r\n\t\t\t\tif(res.then){\r\n\t\t\t\t\tthis.own(res);\t// in case app calls destroy() before query completes\r\n\t\t\t\t}\r\n\r\n\t\t\t\twhen(res,\r\n\t\t\t\t\tlang.hitch(this, function(items){\r\n\t\t\t\t\t\t//console.log(\"queried root: \", res);\r\n\t\t\t\t\t\tif(items.length != 1){\r\n\t\t\t\t\t\t\tthrow new Error(\"dijit.tree.ObjectStoreModel: root query returned \" + items.length +\r\n\t\t\t\t\t\t\t\t\" items, but must return exactly one\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tthis.root = items[0];\r\n\t\t\t\t\t\tonItem(this.root);\r\n\r\n\t\t\t\t\t\t// Setup listener to detect if root item changes\r\n\t\t\t\t\t\tif(res.observe){\r\n\t\t\t\t\t\t\tres.observe(lang.hitch(this, function(obj){\r\n\t\t\t\t\t\t\t\t// Presumably removedFrom == insertedInto == 1, and this call indicates item has changed.\r\n\t\t\t\t\t\t\t\t//console.log(\"root changed: \", obj);\r\n\t\t\t\t\t\t\t\tthis.onChange(obj);\r\n\t\t\t\t\t\t\t}), true);\t// true to listen for updates to obj\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}),\r\n\t\t\t\t\tonError\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tmayHaveChildren: function(/*===== item =====*/){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tTells if an item has or might have children.  Implementing logic here\r\n\t\t\t//\t\tavoids showing +/- expando icon for nodes that we know won't have children.\r\n\t\t\t//\t\t(For efficiency reasons we may not want to check if an element actually\r\n\t\t\t//\t\thas children until user clicks the expando node).\r\n\t\t\t//\r\n\t\t\t//\t\tApplication code should override this method based on the data, for example\r\n\t\t\t//\t\tit could be `return item.leaf == true;`.\r\n\t\t\t//\r\n\t\t\t//\t\tNote that mayHaveChildren() must return true for an item if it could possibly\r\n\t\t\t//\t\thave children in the future, due to drag-an-drop or some other data store update.\r\n\t\t\t//\t\tAlso note that it may return true if it's just too expensive to check during tree\r\n\t\t\t//\t\tcreation whether or not the item has children.\r\n\t\t\t// item: Object\r\n\t\t\t//\t\tItem from the dojo/store\r\n\t\t\treturn true;\r\n\t\t},\r\n\r\n\t\tgetChildren: function(/*Object*/ parentItem, /*function(items)*/ onComplete, /*function*/ onError){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCalls onComplete() with array of child items of given parent item.\r\n\t\t\t// parentItem:\r\n\t\t\t//\t\tItem from the dojo/store\r\n\r\n\t\t\t// TODO:\r\n\t\t\t// For 2.0, change getChildren(), getRoot(), etc. to return a cancelable promise, rather than taking\r\n\t\t\t// onComplete() and onError() callbacks.   Also, probably get rid of the caching.\r\n\t\t\t//\r\n\t\t\t// But be careful if we continue to maintain ObjectStoreModel as a separate class\r\n\t\t\t// from Tree, because in that case ObjectStoreModel can be shared by two trees, and destroying one tree\r\n\t\t\t// should not interfere with an in-progress getChildren() call from another tree.  Also, need to make\r\n\t\t\t// sure that multiple calls to getChildren() for the same parentItem don't trigger duplicate calls\r\n\t\t\t// to onChildrenChange() and onChange().\r\n\t\t\t//\r\n\t\t\t// I think for 2.0 though that ObjectStoreModel should be rolled into Tree itself.\r\n\r\n\t\t\tvar id = this.store.getIdentity(parentItem);\r\n\r\n\t\t\tif(this.childrenCache[id]){\r\n\t\t\t\t// If this.childrenCache[id] is defined, then it always has the latest list of children\r\n\t\t\t\t// (like a live collection), so just return it.\r\n\t\t\t\twhen(this.childrenCache[id], onComplete, onError);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Query the store.\r\n\t\t\t// Cache result so that we can close the query on destroy(), and to avoid setting up multiple observers\r\n\t\t\t// when getChildren() is called multiple times for the same parent.\r\n\t\t\t// The only problem is that getChildren() on non-Observable stores may return a stale value.\r\n\t\t\tvar res = this.childrenCache[id] = this.store.getChildren(parentItem);\r\n\t\t\tif(res.then){\r\n\t\t\t\tthis.own(res);\t// in case app calls destroy() before query completes\r\n\t\t\t}\r\n\r\n\t\t\t// Setup observer in case children list changes, or the item(s) in the children list are updated.\r\n\t\t\tif(res.observe){\r\n\t\t\t\tthis.own(res.observe(lang.hitch(this, function(obj, removedFrom, insertedInto){\r\n\t\t\t\t\t//console.log(\"observe on children of \", id, \": \", obj, removedFrom, insertedInto);\r\n\r\n\t\t\t\t\t// If removedFrom == insertedInto, this call indicates that the item has changed.\r\n\t\t\t\t\t// Even if removedFrom != insertedInto, the item may have changed.\r\n\t\t\t\t\tthis.onChange(obj);\r\n\r\n\t\t\t\t\tif(removedFrom != insertedInto){\r\n\t\t\t\t\t\t// Indicates an item was added, removed, or re-parented.  The children[] array (returned from\r\n\t\t\t\t\t\t// res.then(...)) has already been updated (like a live collection), so just use it.\r\n\t\t\t\t\t\twhen(res, lang.hitch(this, \"onChildrenChange\", parentItem));\r\n\t\t\t\t\t}\r\n\t\t\t\t}), true));\t// true means to notify on item changes\r\n\t\t\t}\r\n\r\n\t\t\t// User callback\r\n\t\t\twhen(res, onComplete, onError);\r\n\t\t},\r\n\r\n\t\t// =======================================================================\r\n\t\t// Inspecting items\r\n\r\n\t\tisItem: function(/*===== something =====*/){\r\n\t\t\treturn true;\t// Boolean\r\n\t\t},\r\n\r\n\t\tgetIdentity: function(/* item */ item){\r\n\t\t\treturn this.store.getIdentity(item);\t// Object\r\n\t\t},\r\n\r\n\t\tgetLabel: function(/*dojo/data/Item*/ item){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tGet the label for an item\r\n\t\t\treturn item[this.labelAttr];\t// String\r\n\t\t},\r\n\r\n\t\t// =======================================================================\r\n\t\t// Write interface, for DnD\r\n\r\n\t\tnewItem: function(/* dijit/tree/dndSource.__Item */ args, /*Item*/ parent, /*int?*/ insertIndex, /*Item*/ before){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCreates a new item.   See `dojo/data/api/Write` for details on args.\r\n\t\t\t//\t\tUsed in drag & drop when item from external source dropped onto tree.\r\n\r\n\t\t\treturn this.store.put(args, {\r\n\t\t\t\tparent: parent,\r\n\t\t\t\tbefore: before\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\tpasteItem: function(/*Item*/ childItem, /*Item*/ oldParentItem, /*Item*/ newParentItem,\r\n\t\t\t\t\t/*Boolean*/ bCopy, /*int?*/ insertIndex, /*Item*/ before){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tMove or copy an item from one parent item to another.\r\n\t\t\t//\t\tUsed in drag & drop.\r\n\r\n\t\t\tvar d = new Deferred();\r\n\r\n\t\t\tif(oldParentItem === newParentItem && !bCopy && !before){\r\n\t\t\t\t// Avoid problem when items visually disappear when dropped onto their parent.\r\n\t\t\t\t// Happens because the (no-op) store.put() call doesn't generate any notification\r\n\t\t\t\t// that the childItem was added/moved.\r\n\t\t\t\td.resolve(true);\r\n\t\t\t\treturn d;\r\n\t\t\t}\r\n\r\n\t\t\tif(oldParentItem && !bCopy){\r\n\t\t\t\t// In order for DnD moves to work correctly, childItem needs to be orphaned from oldParentItem\r\n\t\t\t\t// before being adopted by newParentItem.   That way, the TreeNode is moved rather than\r\n\t\t\t\t// an additional TreeNode being created, and the old TreeNode subsequently being deleted.\r\n\t\t\t\t// The latter loses information such as selection and opened/closed children TreeNodes.\r\n\t\t\t\t// Unfortunately simply calling this.store.put() will send notifications in a random order, based\r\n\t\t\t\t// on when the TreeNodes in question originally appeared, and not based on the drag-from\r\n\t\t\t\t// TreeNode vs. the drop-onto TreeNode.\r\n\r\n\t\t\t\tthis.getChildren(oldParentItem, lang.hitch(this, function(oldParentChildren){\r\n\t\t\t\t\toldParentChildren = [].concat(oldParentChildren); // concat to make copy\r\n\t\t\t\t\tvar index = array.indexOf(oldParentChildren, childItem);\r\n\t\t\t\t\toldParentChildren.splice(index, 1);\r\n\t\t\t\t\tthis.onChildrenChange(oldParentItem, oldParentChildren);\r\n\r\n\t\t\t\t\td.resolve(this.store.put(childItem, {\r\n\t\t\t\t\t\toverwrite: true,\r\n\t\t\t\t\t\tparent: newParentItem,\r\n\t\t\t\t\t\toldParent: oldParentItem,\r\n\t\t\t\t\t\tbefore: before\r\n\t\t\t\t\t}));\r\n\t\t\t\t}));\r\n\t\t\t}else{\r\n\t\t\t\td.resolve(this.store.put(childItem, {\r\n\t\t\t\t\toverwrite: true,\r\n\t\t\t\t\tparent: newParentItem,\r\n\t\t\t\t\toldParent: oldParentItem,\r\n\t\t\t\t\tbefore: before\r\n\t\t\t\t}));\r\n\t\t\t}\r\n\r\n\t\t\treturn d;\r\n\t\t},\r\n\r\n\t\t// =======================================================================\r\n\t\t// Callbacks\r\n\r\n\t\tonChange: function(/*dojo/data/Item*/ /*===== item =====*/){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCallback whenever an item has changed, so that Tree\r\n\t\t\t//\t\tcan update the label, icon, etc.   Note that changes\r\n\t\t\t//\t\tto an item's children or parent(s) will trigger an\r\n\t\t\t//\t\tonChildrenChange() so you can ignore those changes here.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tcallback\r\n\t\t},\r\n\r\n\t\tonChildrenChange: function(/*===== parent, newChildrenList =====*/){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCallback to do notifications about new, updated, or deleted items.\r\n\t\t\t// parent: dojo/data/Item\r\n\t\t\t// newChildrenList: Object[]\r\n\t\t\t//\t\tItems from the store\r\n\t\t\t// tags:\r\n\t\t\t//\t\tcallback\r\n\t\t},\r\n\r\n\t\tonDelete: function(/*dojo/data/Item*/ /*===== item =====*/){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCallback when an item has been deleted.\r\n\t\t\t//\t\tActually we have no way of knowing this with the new dojo.store API,\r\n\t\t\t//\t\tso this method is never called (but it's left here since Tree connects\r\n\t\t\t//\t\tto it).\r\n\t\t\t// tags:\r\n\t\t\t//\t\tcallback\r\n\t\t}\r\n\t});\r\n});\r\n"]}