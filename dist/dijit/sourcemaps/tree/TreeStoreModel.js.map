{"version":3,"sources":["tree/TreeStoreModel.js"],"names":["define","array","aspect","declare","lang","store","childrenAttrs","newItemIdAttr","labelAttr","root","query","deferItemLoadingUntilExpand","constructor","args","mixin","this","connects","getFeatures","Error","concat","after","hitch","destroy","h","pop","remove","getRoot","onItem","onError","fetch","onComplete","items","length","mayHaveChildren","item","some","attr","hasAttribute","getChildren","parentItem","isItemLoaded","childItems","i","vals","getValues","_waitCount","forEach","idx","loadItem","arguments","callee","isItem","something","fetchItemByIdentity","keywordArgs","getIdentity","getLabel","getValue","newItem","parent","insertIndex","LnewItem","pInfo","attribute","identity","scope","pasteItem","undefined","childItem","oldParentItem","newParentItem","bCopy","parentAttr","containsValue","values","filter","x","setValues","slice","splice","onChange","onChildrenChange","onDelete","onNewItem","parentInfo","children","onDeleteItem","onSetItem","indexOf"],"mappings":";;;;;;;AAAAA,QACC,mBACA,cACA,qBACA,mBACE,SAASC,EAAOC,EAAQC,EAASC,GAKnC,OAAOD,EAAQ,4BAA6B,MAQ3CE,MAAO,KAIPC,eAAgB,YAUhBC,cAAe,KAKfC,UAAW,GAIXC,KAAM,KAQNC,MAAO,KASPC,6BAA6B,EAE7BC,YAAa,SAAsBC,GAMlCT,EAAKU,MAAMC,KAAMF,GAEjBE,KAAKC,YAEL,IAAIX,EAAQU,KAAKV,MACjB,IAAIA,EAAMY,cAAc,0BACvB,MAAM,IAAIC,MAAM,oEAIdb,EAAMY,cAAc,gCACtBF,KAAKC,SAAWD,KAAKC,SAASG,QAC7BjB,EAAOkB,MAAMf,EAAO,QAASD,EAAKiB,MAAMN,KAAM,cAAc,GAC5Db,EAAOkB,MAAMf,EAAO,WAAYD,EAAKiB,MAAMN,KAAM,iBAAiB,GAClEb,EAAOkB,MAAMf,EAAO,QAASD,EAAKiB,MAAMN,KAAM,cAAc,OAK/DO,QAAS,WAER,IADA,IAAIC,EACEA,EAAIR,KAAKC,SAASQ,OAAQD,EAAEE,UAOnCC,QAAS,SAASC,EAAQC,GAItBb,KAAKN,KACPkB,EAAOZ,KAAKN,MAEZM,KAAKV,MAAMwB,OACVnB,MAAOK,KAAKL,MACZoB,WAAY1B,EAAKiB,MAAMN,KAAM,SAASgB,GACrC,GAAmB,GAAhBA,EAAMC,OACR,MAAM,IAAId,MAAM,kDAAoDa,EAAMC,OACzE,uCAEFjB,KAAKN,KAAOsB,EAAM,GAClBJ,EAAOZ,KAAKN,QAEbmB,QAASA,KAKZK,gBAAiB,SAA4BC,GAM5C,OAAOjC,EAAMkC,KAAKpB,KAAKT,cAAe,SAAS8B,GAC9C,OAAOrB,KAAKV,MAAMgC,aAAaH,EAAME,IACnCrB,OAGJuB,YAAa,SAA4BC,EAAgCT,EAAyBF,GAIjG,IAAIvB,EAAQU,KAAKV,MACjB,GAAIA,EAAMmC,aAAaD,GAAvB,CAgBA,IADA,IAAIE,KACIC,EAAE,EAAGA,EAAE3B,KAAKT,cAAc0B,OAAQU,IAAI,CAC7C,IAAIC,EAAOtC,EAAMuC,UAAUL,EAAYxB,KAAKT,cAAcoC,IAC1DD,EAAaA,EAAWtB,OAAOwB,GAIhC,IAAIE,EAAa,EACb9B,KAAKJ,6BACRV,EAAM6C,QAAQL,EAAY,SAASP,GAAW7B,EAAMmC,aAAaN,IAAQW,MAGzD,GAAdA,EAEFf,EAAWW,GAGXxC,EAAM6C,QAAQL,EAAY,SAASP,EAAMa,GACpC1C,EAAMmC,aAAaN,IACtB7B,EAAM2C,UACLd,KAAMA,EACNP,OAAQ,SAASO,GAChBO,EAAWM,GAAOb,EACC,KAAdW,GAEJf,EAAWW,IAGbb,QAASA,UA3Cb,CAIC,IAAIU,EAAclC,EAAKiB,MAAMN,KAAMkC,UAAUC,QAC7C7C,EAAM2C,UACLd,KAAMK,EACNZ,OAAQ,SAASY,GAChBD,EAAYC,EAAYT,EAAYF,IAErCA,QAASA,MA2CZuB,OAAQ,SAAwBC,GAC/B,OAAOrC,KAAKV,MAAM8C,OAAOC,IAG1BC,oBAAqB,SAAsBC,GAS1CvC,KAAKV,MAAMgD,oBAAoBC,IAGhCC,YAAa,SAAoBrB,GAChC,OAAOnB,KAAKV,MAAMkD,YAAYrB,IAG/BsB,SAAU,SAA4BtB,GAGrC,OAAGnB,KAAKP,UACAO,KAAKV,MAAMoD,SAASvB,EAAKnB,KAAKP,WAE9BO,KAAKV,MAAMmD,SAAStB,IAO7BwB,QAAS,SAA2C7C,EAA6B8C,EAAiBC,GASjG,IAAgEC,EAA5DC,GAASH,OAAQA,EAAQI,UAAWhD,KAAKT,cAAc,IAExDS,KAAKR,eAAiBM,EAAKE,KAAKR,eAElCQ,KAAKsC,qBAAqBW,SAAUnD,EAAKE,KAAKR,eAAgB0D,MAAOlD,KAAMY,OAAQ,SAASO,GACxFA,EAEFnB,KAAKmD,UAAUhC,EAAM,KAAMyB,GAAQ,EAAMC,IAGzCC,EAAS9C,KAAKV,MAAMqD,QAAQ7C,EAAMiD,UACLK,GAAbP,GAEf7C,KAAKmD,UAAUL,EAAUF,EAAQA,GAAQ,EAAOC,OAMnDC,EAAS9C,KAAKV,MAAMqD,QAAQ7C,EAAMiD,UACLK,GAAbP,GAEf7C,KAAKmD,UAAUL,EAAUF,EAAQA,GAAQ,EAAOC,IAKnDM,UAAW,SAAkBE,EAAoBC,EAAwBC,EAA2BC,EAAgBX,GAInH,IAAIvD,EAAQU,KAAKV,MAChBmE,EAAazD,KAAKT,cAAc,GAkBjC,GAfG+D,GACFpE,EAAM6C,QAAQ/B,KAAKT,cAAe,SAAS8B,GAC1C,GAAG/B,EAAMoE,cAAcJ,EAAejC,EAAMgC,GAAW,CACtD,IAAIG,EAAM,CACT,IAAIG,EAASzE,EAAM0E,OAAOtE,EAAMuC,UAAUyB,EAAejC,GAAO,SAASwC,GACxE,OAAOA,GAAKR,IAEb/D,EAAMwE,UAAUR,EAAejC,EAAMsC,GAEtCF,EAAapC,KAMbkC,EACF,GAAyB,iBAAfV,EAAwB,CAEjC,IAAInB,EAAapC,EAAMuC,UAAU0B,EAAeE,GAAYM,QAC5DrC,EAAWsC,OAAOnB,EAAa,EAAGQ,GAClC/D,EAAMwE,UAAUP,EAAeE,EAAY/B,QAE3CpC,EAAMwE,UAAUP,EAAeE,EAC9BnE,EAAMuC,UAAU0B,EAAeE,GAAYrD,OAAOiD,KAQtDY,SAAU,aAUVC,iBAAkB,aASlBC,SAAU,aAaVC,UAAW,SAA8BjD,EAAmBkD,GAcvDA,GASJrE,KAAKuB,YAAY8C,EAAWlD,KAAM9B,EAAKiB,MAAMN,KAAM,SAASsE,GAC3DtE,KAAKkE,iBAAiBG,EAAWlD,KAAMmD,OAIzCC,aAAc,SAAoBpD,GAGjCnB,KAAKmE,SAAShD,IAGfqD,UAAW,SAASrD,EAAM6B,IAe2B,GAAjD9D,EAAMuF,QAAQzE,KAAKT,cAAeyD,GAEpChD,KAAKuB,YAAYJ,EAAM9B,EAAKiB,MAAMN,KAAM,SAASsE,GAEhDtE,KAAKkE,iBAAiB/C,EAAMmD,MAI7BtE,KAAKiE,SAAS9C","file":"../../tree/TreeStoreModel.js","sourcesContent":["define([\r\n\t\"dojo/_base/array\", // array.filter array.forEach array.indexOf array.some\r\n\t\"dojo/aspect\", // aspect.after\r\n\t\"dojo/_base/declare\", // declare\r\n\t\"dojo/_base/lang\" // lang.hitch\r\n], function(array, aspect, declare, lang){\r\n\r\n\t// module:\r\n\t//\t\tdijit/tree/TreeStoreModel\r\n\r\n\treturn declare(\"dijit.tree.TreeStoreModel\", null, {\r\n\t\t// summary:\r\n\t\t//\t\tImplements dijit/Tree/model connecting to a dojo.data store with a single\r\n\t\t//\t\troot item.  Any methods passed into the constructor will override\r\n\t\t//\t\tthe ones defined here.\r\n\r\n\t\t// store: dojo/data/api/Read\r\n\t\t//\t\tUnderlying store\r\n\t\tstore: null,\r\n\r\n\t\t// childrenAttrs: String[]\r\n\t\t//\t\tOne or more attribute names (attributes in the dojo.data item) that specify that item's children\r\n\t\tchildrenAttrs: [\"children\"],\r\n\r\n\t\t// newItemIdAttr: String\r\n\t\t//\t\tName of attribute in the Object passed to newItem() that specifies the id.\r\n\t\t//\r\n\t\t//\t\tIf newItemIdAttr is set then it's used when newItem() is called to see if an\r\n\t\t//\t\titem with the same id already exists, and if so just links to the old item\r\n\t\t//\t\t(so that the old item ends up with two parents).\r\n\t\t//\r\n\t\t//\t\tSetting this to null or \"\" will make every drop create a new item.\r\n\t\tnewItemIdAttr: \"id\",\r\n\r\n\t\t// labelAttr: String\r\n\t\t//\t\tIf specified, get label for tree node from this attribute, rather\r\n\t\t//\t\tthan by calling store.getLabel()\r\n\t\tlabelAttr: \"\",\r\n\r\n\t\t// root: [readonly] dojo/data/Item\r\n\t\t//\t\tPointer to the root item (read only, not a parameter)\r\n\t\troot: null,\r\n\r\n\t\t// query: anything\r\n\t\t//\t\tSpecifies datastore query to return the root item for the tree.\r\n\t\t//\t\tMust only return a single item.   Alternately can just pass in pointer\r\n\t\t//\t\tto root item.\r\n\t\t// example:\r\n\t\t//\t|\t{id:'ROOT'}\r\n\t\tquery: null,\r\n\r\n\t\t// deferItemLoadingUntilExpand: Boolean\r\n\t\t//\t\tSetting this to true will cause the TreeStoreModel to defer calling loadItem on nodes\r\n\t\t//\t\tuntil they are expanded. This allows for lazying loading where only one\r\n\t\t//\t\tloadItem (and generally one network call, consequently) per expansion\r\n\t\t//\t\t(rather than one for each child).\r\n\t\t//\t\tThis relies on partial loading of the children items; each children item of a\r\n\t\t//\t\tfully loaded item should contain the label and info about having children.\r\n\t\tdeferItemLoadingUntilExpand: false,\r\n\r\n\t\tconstructor: function(/* Object */ args){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tPassed the arguments listed above (store, etc)\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\r\n\t\t\tlang.mixin(this, args);\r\n\r\n\t\t\tthis.connects = [];\r\n\r\n\t\t\tvar store = this.store;\r\n\t\t\tif(!store.getFeatures()['dojo.data.api.Identity']){\r\n\t\t\t\tthrow new Error(\"dijit.tree.TreeStoreModel: store must support dojo.data.Identity\");\r\n\t\t\t}\r\n\r\n\t\t\t// if the store supports Notification, subscribe to the notification events\r\n\t\t\tif(store.getFeatures()['dojo.data.api.Notification']){\r\n\t\t\t\tthis.connects = this.connects.concat([\r\n\t\t\t\t\taspect.after(store, \"onNew\", lang.hitch(this, \"onNewItem\"), true),\r\n\t\t\t\t\taspect.after(store, \"onDelete\", lang.hitch(this, \"onDeleteItem\"), true),\r\n\t\t\t\t\taspect.after(store, \"onSet\", lang.hitch(this, \"onSetItem\"), true)\r\n\t\t\t\t]);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tdestroy: function(){\r\n\t\t\tvar h;\r\n\t\t\twhile(h = this.connects.pop()){ h.remove(); }\r\n\t\t\t// TODO: should cancel any in-progress processing of getRoot(), getChildren()\r\n\t\t},\r\n\r\n\t\t// =======================================================================\r\n\t\t// Methods for traversing hierarchy\r\n\r\n\t\tgetRoot: function(onItem, onError){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCalls onItem with the root item for the tree, possibly a fabricated item.\r\n\t\t\t//\t\tCalls onError on error.\r\n\t\t\tif(this.root){\r\n\t\t\t\tonItem(this.root);\r\n\t\t\t}else{\r\n\t\t\t\tthis.store.fetch({\r\n\t\t\t\t\tquery: this.query,\r\n\t\t\t\t\tonComplete: lang.hitch(this, function(items){\r\n\t\t\t\t\t\tif(items.length != 1){\r\n\t\t\t\t\t\t\tthrow new Error(\"dijit.tree.TreeStoreModel: root query returned \" + items.length +\r\n\t\t\t\t\t\t\t\t\" items, but must return exactly one\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tthis.root = items[0];\r\n\t\t\t\t\t\tonItem(this.root);\r\n\t\t\t\t\t}),\r\n\t\t\t\t\tonError: onError\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tmayHaveChildren: function(/*dojo/data/Item*/ item){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tTells if an item has or may have children.  Implementing logic here\r\n\t\t\t//\t\tavoids showing +/- expando icon for nodes that we know don't have children.\r\n\t\t\t//\t\t(For efficiency reasons we may not want to check if an element actually\r\n\t\t\t//\t\thas children until user clicks the expando node)\r\n\t\t\treturn array.some(this.childrenAttrs, function(attr){\r\n\t\t\t\treturn this.store.hasAttribute(item, attr);\r\n\t\t\t}, this);\r\n\t\t},\r\n\r\n\t\tgetChildren: function(/*dojo/data/Item*/ parentItem, /*function(items)*/ onComplete, /*function*/ onError){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCalls onComplete() with array of child items of given parent item, all loaded.\r\n\r\n\t\t\tvar store = this.store;\r\n\t\t\tif(!store.isItemLoaded(parentItem)){\r\n\t\t\t\t// The parent is not loaded yet, we must be in deferItemLoadingUntilExpand\r\n\t\t\t\t// mode, so we will load it and just return the children (without loading each\r\n\t\t\t\t// child item)\r\n\t\t\t\tvar getChildren = lang.hitch(this, arguments.callee);\r\n\t\t\t\tstore.loadItem({\r\n\t\t\t\t\titem: parentItem,\r\n\t\t\t\t\tonItem: function(parentItem){\r\n\t\t\t\t\t\tgetChildren(parentItem, onComplete, onError);\r\n\t\t\t\t\t},\r\n\t\t\t\t\tonError: onError\r\n\t\t\t\t});\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t// get children of specified item\r\n\t\t\tvar childItems = [];\r\n\t\t\tfor(var i=0; i<this.childrenAttrs.length; i++){\r\n\t\t\t\tvar vals = store.getValues(parentItem, this.childrenAttrs[i]);\r\n\t\t\t\tchildItems = childItems.concat(vals);\r\n\t\t\t}\r\n\r\n\t\t\t// count how many items need to be loaded\r\n\t\t\tvar _waitCount = 0;\r\n\t\t\tif(!this.deferItemLoadingUntilExpand){\r\n\t\t\t\tarray.forEach(childItems, function(item){ if(!store.isItemLoaded(item)){ _waitCount++; } });\r\n\t\t\t}\r\n\r\n\t\t\tif(_waitCount == 0){\r\n\t\t\t\t// all items are already loaded (or we aren't loading them).  proceed...\r\n\t\t\t\tonComplete(childItems);\r\n\t\t\t}else{\r\n\t\t\t\t// still waiting for some or all of the items to load\r\n\t\t\t\tarray.forEach(childItems, function(item, idx){\r\n\t\t\t\t\tif(!store.isItemLoaded(item)){\r\n\t\t\t\t\t\tstore.loadItem({\r\n\t\t\t\t\t\t\titem: item,\r\n\t\t\t\t\t\t\tonItem: function(item){\r\n\t\t\t\t\t\t\t\tchildItems[idx] = item;\r\n\t\t\t\t\t\t\t\tif(--_waitCount == 0){\r\n\t\t\t\t\t\t\t\t\t// all nodes have been loaded, send them to the tree\r\n\t\t\t\t\t\t\t\t\tonComplete(childItems);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tonError: onError\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t// =======================================================================\r\n\t\t// Inspecting items\r\n\r\n\t\tisItem: function(/* anything */ something){\r\n\t\t\treturn this.store.isItem(something);\t// Boolean\r\n\t\t},\r\n\r\n\t\tfetchItemByIdentity: function(/* object */ keywordArgs){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tGiven the identity of an item, this method returns the item that has\r\n\t\t\t//\t\tthat identity through the onItem callback.  Conforming implementations\r\n\t\t\t//\t\tshould return null if there is no item with the given identity.\r\n\t\t\t//\t\tImplementations of fetchItemByIdentity() may sometimes return an item\r\n\t\t\t//\t\tfrom a local cache and may sometimes fetch an item from a remote server.\r\n\t\t\t// tags:\r\n\t\t\t//\t\textension\r\n\t\t\tthis.store.fetchItemByIdentity(keywordArgs);\r\n\t\t},\r\n\r\n\t\tgetIdentity: function(/* item */ item){\r\n\t\t\treturn this.store.getIdentity(item);\t// Object\r\n\t\t},\r\n\r\n\t\tgetLabel: function(/*dojo/data/Item*/ item){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tGet the label for an item\r\n\t\t\tif(this.labelAttr){\r\n\t\t\t\treturn this.store.getValue(item,this.labelAttr);\t// String\r\n\t\t\t}else{\r\n\t\t\t\treturn this.store.getLabel(item);\t// String\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t// =======================================================================\r\n\t\t// Write interface\r\n\r\n\t\tnewItem: function(/* dijit/tree/dndSource.__Item */ args, /*dojo/data/api/Item*/ parent, /*int?*/ insertIndex){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCreates a new item.   See `dojo/data/api/Write` for details on args.\r\n\t\t\t//\t\tUsed in drag & drop when item from external source dropped onto tree.\r\n\t\t\t// description:\r\n\t\t\t//\t\tDevelopers will need to override this method if new items get added\r\n\t\t\t//\t\tto parents with multiple children attributes, in order to define which\r\n\t\t\t//\t\tchildren attribute points to the new item.\r\n\r\n\t\t\tvar pInfo = {parent: parent, attribute: this.childrenAttrs[0]}, LnewItem;\r\n\r\n\t\t\tif(this.newItemIdAttr && args[this.newItemIdAttr]){\r\n\t\t\t\t// Maybe there's already a corresponding item in the store; if so, reuse it.\r\n\t\t\t\tthis.fetchItemByIdentity({identity: args[this.newItemIdAttr], scope: this, onItem: function(item){\r\n\t\t\t\t\tif(item){\r\n\t\t\t\t\t\t// There's already a matching item in store, use it\r\n\t\t\t\t\t\tthis.pasteItem(item, null, parent, true, insertIndex);\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\t// Create new item in the tree, based on the drag source.\r\n\t\t\t\t\t\tLnewItem=this.store.newItem(args, pInfo);\r\n\t\t\t\t\t\tif(LnewItem && (insertIndex!=undefined)){\r\n\t\t\t\t\t\t\t// Move new item to desired position\r\n\t\t\t\t\t\t\tthis.pasteItem(LnewItem, parent, parent, false, insertIndex);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}});\r\n\t\t\t}else{\r\n\t\t\t\t// [as far as we know] there is no id so we must assume this is a new item\r\n\t\t\t\tLnewItem=this.store.newItem(args, pInfo);\r\n\t\t\t\tif(LnewItem && (insertIndex!=undefined)){\r\n\t\t\t\t\t// Move new item to desired position\r\n\t\t\t\t\tthis.pasteItem(LnewItem, parent, parent, false, insertIndex);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tpasteItem: function(/*Item*/ childItem, /*Item*/ oldParentItem, /*Item*/ newParentItem, /*Boolean*/ bCopy, /*int?*/ insertIndex){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tMove or copy an item from one parent item to another.\r\n\t\t\t//\t\tUsed in drag & drop\r\n\t\t\tvar store = this.store,\r\n\t\t\t\tparentAttr = this.childrenAttrs[0];\t// name of \"children\" attr in parent item\r\n\r\n\t\t\t// remove child from source item, and record the attribute that child occurred in\r\n\t\t\tif(oldParentItem){\r\n\t\t\t\tarray.forEach(this.childrenAttrs, function(attr){\r\n\t\t\t\t\tif(store.containsValue(oldParentItem, attr, childItem)){\r\n\t\t\t\t\t\tif(!bCopy){\r\n\t\t\t\t\t\t\tvar values = array.filter(store.getValues(oldParentItem, attr), function(x){\r\n\t\t\t\t\t\t\t\treturn x != childItem;\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\tstore.setValues(oldParentItem, attr, values);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tparentAttr = attr;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// modify target item's children attribute to include this item\r\n\t\t\tif(newParentItem){\r\n\t\t\t\tif(typeof insertIndex == \"number\"){\r\n\t\t\t\t\t// call slice() to avoid modifying the original array, confusing the data store\r\n\t\t\t\t\tvar childItems = store.getValues(newParentItem, parentAttr).slice();\r\n\t\t\t\t\tchildItems.splice(insertIndex, 0, childItem);\r\n\t\t\t\t\tstore.setValues(newParentItem, parentAttr, childItems);\r\n\t\t\t\t}else{\r\n\t\t\t\t\tstore.setValues(newParentItem, parentAttr,\r\n\t\t\t\t\t\tstore.getValues(newParentItem, parentAttr).concat(childItem));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t// =======================================================================\r\n\t\t// Callbacks\r\n\r\n\t\tonChange: function(/*dojo/data/Item*/ /*===== item =====*/){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCallback whenever an item has changed, so that Tree\r\n\t\t\t//\t\tcan update the label, icon, etc.   Note that changes\r\n\t\t\t//\t\tto an item's children or parent(s) will trigger an\r\n\t\t\t//\t\tonChildrenChange() so you can ignore those changes here.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tcallback\r\n\t\t},\r\n\r\n\t\tonChildrenChange: function(/*===== parent, newChildrenList =====*/){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCallback to do notifications about new, updated, or deleted items.\r\n\t\t\t// parent: dojo/data/Item\r\n\t\t\t// newChildrenList: dojo/data/Item[]\r\n\t\t\t// tags:\r\n\t\t\t//\t\tcallback\r\n\t\t},\r\n\r\n\t\tonDelete: function(/*dojo/data/Item*/ /*===== item =====*/){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCallback when an item has been deleted.\r\n\t\t\t// description:\r\n\t\t\t//\t\tNote that there will also be an onChildrenChange() callback for the parent\r\n\t\t\t//\t\tof this item.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tcallback\r\n\t\t},\r\n\r\n\t\t// =======================================================================\r\n\t\t// Events from data store\r\n\r\n\t\tonNewItem: function(/* dojo/data/Item */ item, /* Object */ parentInfo){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tHandler for when new items appear in the store, either from a drop operation\r\n\t\t\t//\t\tor some other way.   Updates the tree view (if necessary).\r\n\t\t\t// description:\r\n\t\t\t//\t\tIf the new item is a child of an existing item,\r\n\t\t\t//\t\tcalls onChildrenChange() with the new list of children\r\n\t\t\t//\t\tfor that existing item.\r\n\t\t\t//\r\n\t\t\t// tags:\r\n\t\t\t//\t\textension\r\n\r\n\t\t\t// We only care about the new item if it has a parent that corresponds to a TreeNode\r\n\t\t\t// we are currently displaying\r\n\t\t\tif(!parentInfo){\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Call onChildrenChange() on parent (ie, existing) item with new list of children\r\n\t\t\t// In the common case, the new list of children is simply parentInfo.newValue or\r\n\t\t\t// [ parentInfo.newValue ], although if items in the store has multiple\r\n\t\t\t// child attributes (see `childrenAttr`), then it's a superset of parentInfo.newValue,\r\n\t\t\t// so call getChildren() to be sure to get right answer.\r\n\t\t\tthis.getChildren(parentInfo.item, lang.hitch(this, function(children){\r\n\t\t\t\tthis.onChildrenChange(parentInfo.item, children);\r\n\t\t\t}));\r\n\t\t},\r\n\r\n\t\tonDeleteItem: function(/*Object*/ item){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tHandler for delete notifications from underlying store\r\n\t\t\tthis.onDelete(item);\r\n\t\t},\r\n\r\n\t\tonSetItem: function(item, attribute /*===== , oldValue, newValue =====*/){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tUpdates the tree view according to changes in the data store.\r\n\t\t\t// description:\r\n\t\t\t//\t\tHandles updates to an item's children by calling onChildrenChange(), and\r\n\t\t\t//\t\tother updates to an item by calling onChange().\r\n\t\t\t//\r\n\t\t\t//\t\tSee `onNewItem` for more details on handling updates to an item's children.\r\n\t\t\t// item: Item\r\n\t\t\t// attribute: attribute-name-string\r\n\t\t\t// oldValue: Object|Array\r\n\t\t\t// newValue: Object|Array\r\n\t\t\t// tags:\r\n\t\t\t//\t\textension\r\n\r\n\t\t\tif(array.indexOf(this.childrenAttrs, attribute) != -1){\r\n\t\t\t\t// item's children list changed\r\n\t\t\t\tthis.getChildren(item, lang.hitch(this, function(children){\r\n\t\t\t\t\t// See comments in onNewItem() about calling getChildren()\r\n\t\t\t\t\tthis.onChildrenChange(item, children);\r\n\t\t\t\t}));\r\n\t\t\t}else{\r\n\t\t\t\t// item's label/icon/etc. changed.\r\n\t\t\t\tthis.onChange(item);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n});\r\n"]}