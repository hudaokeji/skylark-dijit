{"version":3,"sources":["Menu.js"],"names":["define","require","array","declare","dom","domAttr","domGeometry","domStyle","keys","lang","on","has","win","winUtils","pm","DropDownMenu","ready","constructor","this","_bindings","targetNodeIds","selector","contextMenuForWindow","leftClickToOpen","refocus","postCreate","bindDomNode","ownerDocumentBody","forEach","inherited","arguments","_iframeContentWindow","iframe_el","get","_iframeContentDocument","name","document","frames","contentDocument","contentWindow","node","cn","byId","ownerDocument","tagName","toLowerCase","iframe","window","body","documentElement","binding","set","id","push","doConnects","hitch","delegatedEvent","eventType","self","evt","stopPropagation","preventDefault","Date","getTime","_lastKeyDown","_scheduleOpen","x","pageX","y","pageY","target","keyCode","shiftKey","F10","SPACE","connects","onloadHandler","addEventListener","attachEvent","unBindDomNode","nodeName","e","attrName","h","bid","b","pop","remove","removeEventListener","detachEvent","delegatedTarget","coords","_openTimer","defer","_openMyself","args","byKeyboard","currentTarget","ifc","position","scroll","docScroll","cs","getComputedStyle","tp","toPixelValue","left","paddingLeft","borderLeftWidth","top","paddingTop","borderTopWidth","prevFocusNode","_focusManager","curFocusNode","savedFocusNode","isDescendant","domNode","closeAndRestoreFocus","focus","close","open","popup","onExecute","onCancel","orient","isLeftToRight","_cleanUp","_onBlur","destroy"],"mappings":"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","file":"../Menu.js","sourcesContent":["define([\r\n\t\"require\",\r\n\t\"dojo/_base/array\", // array.forEach\r\n\t\"dojo/_base/declare\", // declare\r\n\t\"dojo/dom\", // dom.byId dom.isDescendant\r\n\t\"dojo/dom-attr\", // domAttr.get domAttr.set domAttr.has domAttr.remove\r\n\t\"dojo/dom-geometry\", // domStyle.getComputedStyle domGeometry.position\r\n\t\"dojo/dom-style\", // domStyle.getComputedStyle\r\n\t\"dojo/keys\", // keys.F10\r\n\t\"dojo/_base/lang\", // lang.hitch\r\n\t\"dojo/on\",\r\n\t\"dojo/sniff\", // has(\"ie\"), has(\"quirks\")\r\n\t\"dojo/_base/window\", // win.body\r\n\t\"dojo/window\", // winUtils.get\r\n\t\"./popup\",\r\n\t\"./DropDownMenu\",\r\n\t\"dojo/ready\"\r\n], function(require, array, declare, dom, domAttr, domGeometry, domStyle, keys, lang, on, has, win, winUtils, pm, DropDownMenu, ready){\r\n\r\n\t// module:\r\n\t//\t\tdijit/Menu\r\n\r\n\t// Back compat w/1.6, remove for 2.0\r\n\tif(has(\"dijit-legacy-requires\")){\r\n\t\tready(0, function(){\r\n\t\t\tvar requires = [\"dijit/MenuItem\", \"dijit/PopupMenuItem\", \"dijit/CheckedMenuItem\", \"dijit/MenuSeparator\"];\r\n\t\t\trequire(requires);\t// use indirection so modules not rolled into a build\r\n\t\t});\r\n\t}\r\n\r\n\treturn declare(\"dijit.Menu\", DropDownMenu, {\r\n\t\t// summary:\r\n\t\t//\t\tA context menu you can assign to multiple elements\r\n\r\n\t\tconstructor: function(/*===== params, srcNodeRef =====*/){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCreate the widget.\r\n\t\t\t// params: Object|null\r\n\t\t\t//\t\tHash of initialization parameters for widget, including scalar values (like title, duration etc.)\r\n\t\t\t//\t\tand functions, typically callbacks like onClick.\r\n\t\t\t//\t\tThe hash can contain any of the widget's properties, excluding read-only properties.\r\n\t\t\t// srcNodeRef: DOMNode|String?\r\n\t\t\t//\t\tIf a srcNodeRef (DOM node) is specified:\r\n\t\t\t//\r\n\t\t\t//\t\t- use srcNodeRef.innerHTML as my contents\r\n\t\t\t//\t\t- replace srcNodeRef with my generated DOM tree\r\n\r\n\t\t\tthis._bindings = [];\r\n\t\t},\r\n\r\n\t\t// targetNodeIds: [const] String[]\r\n\t\t//\t\tArray of dom node ids of nodes to attach to.\r\n\t\t//\t\tFill this with nodeIds upon widget creation and it becomes context menu for those nodes.\r\n\t\ttargetNodeIds: [],\r\n\r\n\t\t// selector: String?\r\n\t\t//\t\tCSS expression to apply this Menu to descendants of targetNodeIds, rather than to\r\n\t\t//\t\tthe nodes specified by targetNodeIds themselves.  Useful for applying a Menu to\r\n\t\t//\t\ta range of rows in a table, tree, etc.\r\n\t\t//\r\n\t\t//\t\tThe application must require() an appropriate level of dojo/query to handle the selector.\r\n\t\tselector: \"\",\r\n\r\n\t\t// TODO: in 2.0 remove support for multiple targetNodeIds.   selector gives the same effect.\r\n\t\t// So, change targetNodeIds to a targetNodeId: \"\", remove bindDomNode()/unBindDomNode(), etc.\r\n\r\n\t\t/*=====\r\n\t\t// currentTarget: [readonly] DOMNode\r\n\t\t//\t\tFor context menus, set to the current node that the Menu is being displayed for.\r\n\t\t//\t\tUseful so that the menu actions can be tailored according to the node\r\n\t\tcurrentTarget: null,\r\n\t\t=====*/\r\n\r\n\t\t// contextMenuForWindow: [const] Boolean\r\n\t\t//\t\tIf true, right clicking anywhere on the window will cause this context menu to open.\r\n\t\t//\t\tIf false, must specify targetNodeIds.\r\n\t\tcontextMenuForWindow: false,\r\n\r\n\t\t// leftClickToOpen: [const] Boolean\r\n\t\t//\t\tIf true, menu will open on left click instead of right click, similar to a file menu.\r\n\t\tleftClickToOpen: false,\r\n\t\t// TODO: remove in 2.0, we have better ways of opening a menu with a left click, by extending _HasDropDown.\r\n\r\n\t\t// refocus: Boolean\r\n\t\t//\t\tWhen this menu closes, re-focus the element which had focus before it was opened.\r\n\t\trefocus: true,\r\n\r\n\t\tpostCreate: function(){\r\n\t\t\tif(this.contextMenuForWindow){\r\n\t\t\t\tthis.bindDomNode(this.ownerDocumentBody);\r\n\t\t\t}else{\r\n\t\t\t\tarray.forEach(this.targetNodeIds, this.bindDomNode, this);\r\n\t\t\t}\r\n\t\t\tthis.inherited(arguments);\r\n\t\t},\r\n\r\n\t\t// thanks burstlib!\r\n\t\t_iframeContentWindow: function(/* HTMLIFrameElement */iframe_el){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns the window reference of the passed iframe\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\treturn winUtils.get(this._iframeContentDocument(iframe_el)) ||\r\n\t\t\t\t// Moz. TODO: is this available when defaultView isn't?\r\n\t\t\t\tthis._iframeContentDocument(iframe_el)['__parent__'] ||\r\n\t\t\t\t(iframe_el.name && document.frames[iframe_el.name]) || null;\t//\tWindow\r\n\t\t},\r\n\r\n\t\t_iframeContentDocument: function(/* HTMLIFrameElement */iframe_el){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns a reference to the document object inside iframe_el\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\t\t\treturn iframe_el.contentDocument // W3\r\n\t\t\t\t|| (iframe_el.contentWindow && iframe_el.contentWindow.document) // IE\r\n\t\t\t\t|| (iframe_el.name && document.frames[iframe_el.name] && document.frames[iframe_el.name].document)\r\n\t\t\t\t|| null;\t//\tHTMLDocument\r\n\t\t},\r\n\r\n\t\tbindDomNode: function(/*String|DomNode*/ node){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tAttach menu to given node\r\n\t\t\tnode = dom.byId(node, this.ownerDocument);\r\n\r\n\t\t\tvar cn;\t// Connect node\r\n\r\n\t\t\t// Support context menus on iframes.  Rather than binding to the iframe itself we need\r\n\t\t\t// to bind to the <body> node inside the iframe.\r\n\t\t\tif(node.tagName.toLowerCase() == \"iframe\"){\r\n\t\t\t\tvar iframe = node,\r\n\t\t\t\t\twindow = this._iframeContentWindow(iframe);\r\n\t\t\t\tcn = win.body(window.document);\r\n\t\t\t}else{\r\n\t\t\t\t// To capture these events at the top level, attach to <html>, not <body>.\r\n\t\t\t\t// Otherwise right-click context menu just doesn't work.\r\n\t\t\t\tcn = (node == win.body(this.ownerDocument) ? this.ownerDocument.documentElement : node);\r\n\t\t\t}\r\n\r\n\r\n\t\t\t// \"binding\" is the object to track our connection to the node (ie, the parameter to bindDomNode())\r\n\t\t\tvar binding = {\r\n\t\t\t\tnode: node,\r\n\t\t\t\tiframe: iframe\r\n\t\t\t};\r\n\r\n\t\t\t// Save info about binding in _bindings[], and make node itself record index(+1) into\r\n\t\t\t// _bindings[] array.  Prefix w/_dijitMenu to avoid setting an attribute that may\r\n\t\t\t// start with a number, which fails on FF/safari.\r\n\t\t\tdomAttr.set(node, \"_dijitMenu\" + this.id, this._bindings.push(binding));\r\n\r\n\t\t\t// Setup the connections to monitor click etc., unless we are connecting to an iframe which hasn't finished\r\n\t\t\t// loading yet, in which case we need to wait for the onload event first, and then connect\r\n\t\t\t// On linux Shift-F10 produces the oncontextmenu event, but on Windows it doesn't, so\r\n\t\t\t// we need to monitor keyboard events in addition to the oncontextmenu event.\r\n\t\t\tvar doConnects = lang.hitch(this, function(cn){\r\n\t\t\t\tvar selector = this.selector,\r\n\t\t\t\t\tdelegatedEvent = selector ?\r\n\t\t\t\t\t\tfunction(eventType){\r\n\t\t\t\t\t\t\treturn on.selector(selector, eventType);\r\n\t\t\t\t\t\t} :\r\n\t\t\t\t\t\tfunction(eventType){\r\n\t\t\t\t\t\t\treturn eventType;\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\tself = this;\r\n\t\t\t\treturn [\r\n\t\t\t\t\ton(cn, delegatedEvent(this.leftClickToOpen ? \"click\" : \"contextmenu\"), function(evt){\r\n\t\t\t\t\t\tevt.stopPropagation();\r\n\t\t\t\t\t\tevt.preventDefault();\r\n\r\n\t\t\t\t\t\tif((new Date()).getTime() < this._lastKeyDown + 500){\r\n\t\t\t\t\t\t\t// Ignore contextmenu/click events that were already processed in keydown handler below.\r\n\t\t\t\t\t\t\t// But still call preventDefault() (above) so system context menu doesn't appear.\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Schedule context menu to be opened.\r\n\t\t\t\t\t\t// Note that this won't work will if the click was generated by the keyboard, while\r\n\t\t\t\t\t\t// focused on a <button> etc.   In that case evt.pageX and evt.pageY are either (0,0) or\r\n\t\t\t\t\t\t// wherever the mouse cursor is.  See keydown handler below.\r\n\t\t\t\t\t\tself._scheduleOpen(this, iframe, {x: evt.pageX, y: evt.pageY}, evt.target);\r\n\t\t\t\t\t}),\r\n\t\t\t\t\ton(cn, delegatedEvent(\"keydown\"), function(evt){\r\n\t\t\t\t\t\tif(evt.keyCode == 93 ||\t\t\t\t\t\t\t\t\t// context menu key\r\n\t\t\t\t\t\t\t(evt.shiftKey && evt.keyCode == keys.F10) ||\t\t// shift-F10\r\n\t\t\t\t\t\t\t(this.leftClickToOpen && evt.keyCode == keys.SPACE)\t// space key\r\n\t\t\t\t\t\t){\r\n\t\t\t\t\t\t\tevt.stopPropagation();\r\n\t\t\t\t\t\t\tevt.preventDefault();\r\n\r\n\t\t\t\t\t\t\t// Open the menu around evt.target.  Note that \"this\" and evt.target\r\n\t\t\t\t\t\t\t// are likely different, especially for global context menu, where \"this\" is <body>.\r\n\t\t\t\t\t\t\tself._scheduleOpen(this, iframe, null, evt.target);\t// no coords - open near evt.target\r\n\r\n\t\t\t\t\t\t\tthis._lastKeyDown = (new Date()).getTime();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t];\r\n\t\t\t});\r\n\t\t\tbinding.connects = cn ? doConnects(cn) : [];\r\n\r\n\t\t\tif(iframe){\r\n\t\t\t\t// Setup handler to [re]bind to the iframe when the contents are initially loaded,\r\n\t\t\t\t// and every time the contents change.\r\n\t\t\t\t// Need to do this b/c we are actually binding to the iframe's <body> node.\r\n\t\t\t\t// Note: can't use connect.connect(), see #9609.\r\n\r\n\t\t\t\tbinding.onloadHandler = lang.hitch(this, function(){\r\n\t\t\t\t\t// want to remove old connections, but IE throws exceptions when trying to\r\n\t\t\t\t\t// access the <body> node because it's already gone, or at least in a state of limbo\r\n\r\n\t\t\t\t\tvar window = this._iframeContentWindow(iframe),\r\n\t\t\t\t\t\tcn = win.body(window.document);\r\n\t\t\t\t\tbinding.connects = doConnects(cn);\r\n\t\t\t\t});\r\n\t\t\t\tif(iframe.addEventListener){\r\n\t\t\t\t\tiframe.addEventListener(\"load\", binding.onloadHandler, false);\r\n\t\t\t\t}else{\r\n\t\t\t\t\tiframe.attachEvent(\"onload\", binding.onloadHandler);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tunBindDomNode: function(/*String|DomNode*/ nodeName){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tDetach menu from given node\r\n\r\n\t\t\tvar node;\r\n\t\t\ttry{\r\n\t\t\t\tnode = dom.byId(nodeName, this.ownerDocument);\r\n\t\t\t}catch(e){\r\n\t\t\t\t// On IE the dom.byId() call will get an exception if the attach point was\r\n\t\t\t\t// the <body> node of an <iframe> that has since been reloaded (and thus the\r\n\t\t\t\t// <body> node is in a limbo state of destruction.\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// node[\"_dijitMenu\" + this.id] contains index(+1) into my _bindings[] array\r\n\t\t\tvar attrName = \"_dijitMenu\" + this.id;\r\n\t\t\tif(node && domAttr.has(node, attrName)){\r\n\t\t\t\tvar bid = domAttr.get(node, attrName) - 1, b = this._bindings[bid], h;\r\n\t\t\t\twhile((h = b.connects.pop())){\r\n\t\t\t\t\th.remove();\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Remove listener for iframe onload events\r\n\t\t\t\tvar iframe = b.iframe;\r\n\t\t\t\tif(iframe){\r\n\t\t\t\t\tif(iframe.removeEventListener){\r\n\t\t\t\t\t\tiframe.removeEventListener(\"load\", b.onloadHandler, false);\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tiframe.detachEvent(\"onload\", b.onloadHandler);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdomAttr.remove(node, attrName);\r\n\t\t\t\tdelete this._bindings[bid];\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_scheduleOpen: function(delegatedTarget, iframe, coords, target){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSet timer to display myself.  Using a timer rather than displaying immediately solves\r\n\t\t\t//\t\tIE problem: without the delay, focus work in \"open\" causes the system\r\n\t\t\t//\t\tcontext menu to appear in spite of evt.preventDefault().\r\n\t\t\t// delegatedTarget: Element\r\n\t\t\t//\t\tThe node specified in targetNodeIds or matching selector that the menu is being opened for.\r\n\t\t\t// iframe: HTMLIframeElement?\r\n\t\t\t//\t\tSet if target is inside the specified iframe.\r\n\t\t\t// coords: Object\r\n\t\t\t//\t\tx/y position to center the menu around.  Undefined if menu was opened via keyboard.\r\n\t\t\t// target: Element\r\n\t\t\t//\t\tThe actual clicked node, either delegatedTarget or a descendant.\r\n\r\n\t\t\tif(!this._openTimer){\r\n\t\t\t\tthis._openTimer = this.defer(function(){\r\n\t\t\t\t\tdelete this._openTimer;\r\n\t\t\t\t\tthis._openMyself({\r\n\t\t\t\t\t\ttarget: target,\r\n\t\t\t\t\t\tdelegatedTarget: delegatedTarget,\r\n\t\t\t\t\t\tiframe: iframe,\r\n\t\t\t\t\t\tcoords: coords\r\n\t\t\t\t\t});\r\n\t\t\t\t}, 1);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_openMyself: function(args){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tInternal function for opening myself when the user does a right-click or something similar.\r\n\t\t\t// args:\r\n\t\t\t//\t\tThis is an Object containing:\r\n\t\t\t//\r\n\t\t\t//\t\t- target: The node that is being clicked.\r\n\t\t\t//\t\t- delegatedTarget: The node from this.targetNodeIds or matching this.selector,\r\n\t\t\t//\t\t  either the same as target or an ancestor of target.\r\n\t\t\t//\t\t- iframe: If an `<iframe>` is being clicked, iframe points to that iframe\r\n\t\t\t//\t\t- coords: Mouse cursor x/y coordinates.  Null when opened via keyboard.\r\n\t\t\t//\t\t  Put menu at specified position in iframe (if iframe specified) or otherwise in viewport.\r\n\t\t\t//\r\n\t\t\t//\t\t_openMyself() formerly took the event object, and since various code references\r\n\t\t\t//\t\tevt.target (after connecting to _openMyself()), using an Object for parameters\r\n\t\t\t//\t\t(so that old code still works).\r\n\r\n\t\t\tvar target = args.target,\r\n\t\t\t\tiframe = args.iframe,\r\n\t\t\t\tcoords = args.coords,\r\n\t\t\t\tbyKeyboard = !coords;\r\n\r\n\t\t\t// To be used by MenuItem event handlers to tell which node the menu was opened on\r\n\t\t\tthis.currentTarget = args.delegatedTarget;\r\n\r\n\t\t\t// Get coordinates to open menu, either at specified (mouse) position or (if triggered via keyboard)\r\n\t\t\t// then near the node the menu is assigned to.\r\n\t\t\tif(coords){\r\n\t\t\t\tif(iframe){\r\n\t\t\t\t\t// Specified coordinates are on <body> node of an <iframe>, convert to match main document\r\n\t\t\t\t\tvar ifc = domGeometry.position(iframe, true),\r\n\t\t\t\t\t\twindow = this._iframeContentWindow(iframe),\r\n\t\t\t\t\t\tscroll = domGeometry.docScroll(window.document);\r\n\r\n\t\t\t\t\tvar cs = domStyle.getComputedStyle(iframe),\r\n\t\t\t\t\t\ttp = domStyle.toPixelValue,\r\n\t\t\t\t\t\tleft = (has(\"ie\") && has(\"quirks\") ? 0 : tp(iframe, cs.paddingLeft)) + (has(\"ie\") && has(\"quirks\") ? tp(iframe, cs.borderLeftWidth) : 0),\r\n\t\t\t\t\t\ttop = (has(\"ie\") && has(\"quirks\") ? 0 : tp(iframe, cs.paddingTop)) + (has(\"ie\") && has(\"quirks\") ? tp(iframe, cs.borderTopWidth) : 0);\r\n\r\n\t\t\t\t\tcoords.x += ifc.x + left - scroll.x;\r\n\t\t\t\t\tcoords.y += ifc.y + top - scroll.y;\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tcoords = domGeometry.position(target, true);\r\n\t\t\t\tcoords.x += 10;\r\n\t\t\t\tcoords.y += 10;\r\n\t\t\t}\r\n\r\n\t\t\tvar self = this;\r\n\t\t\tvar prevFocusNode = this._focusManager.get(\"prevNode\");\r\n\t\t\tvar curFocusNode = this._focusManager.get(\"curNode\");\r\n\t\t\tvar savedFocusNode = !curFocusNode || (dom.isDescendant(curFocusNode, this.domNode)) ? prevFocusNode : curFocusNode;\r\n\r\n\t\t\tfunction closeAndRestoreFocus(){\r\n\t\t\t\t// user has clicked on a menu or popup\r\n\t\t\t\tif(self.refocus && savedFocusNode){\r\n\t\t\t\t\tsavedFocusNode.focus();\r\n\t\t\t\t}\r\n\t\t\t\tpm.close(self);\r\n\t\t\t}\r\n\r\n\t\t\tpm.open({\r\n\t\t\t\tpopup: this,\r\n\t\t\t\tx: coords.x,\r\n\t\t\t\ty: coords.y,\r\n\t\t\t\tonExecute: closeAndRestoreFocus,\r\n\t\t\t\tonCancel: closeAndRestoreFocus,\r\n\t\t\t\torient: this.isLeftToRight() ? 'L' : 'R'\r\n\t\t\t});\r\n\r\n\t\t\t// Focus the menu even when opened by mouse, so that a click on blank area of screen will close it\r\n\t\t\tthis.focus();\r\n\t\t\tif(!byKeyboard){\r\n\t\t\t\t// But then (when opened by mouse), mark Menu as passive, so that the first item isn't highlighted.\r\n\t\t\t\t// On IE9+ this needs to be on a delay because the focus is asynchronous.\r\n\t\t\t\tthis.defer(function(){\r\n\t\t\t\t\tthis._cleanUp(true);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tthis._onBlur = function(){\r\n\t\t\t\tthis.inherited('_onBlur', arguments);\r\n\t\t\t\t// Usually the parent closes the child widget but if this is a context\r\n\t\t\t\t// menu then there is no parent\r\n\t\t\t\tpm.close(this);\r\n\t\t\t\t// don't try to restore focus; user has clicked another part of the screen\r\n\t\t\t\t// and set focus there\r\n\t\t\t};\r\n\t\t},\r\n\r\n\t\tdestroy: function(){\r\n\t\t\tarray.forEach(this._bindings, function(b){\r\n\t\t\t\tif(b){\r\n\t\t\t\t\tthis.unBindDomNode(b.node);\r\n\t\t\t\t}\r\n\t\t\t}, this);\r\n\t\t\tthis.inherited(arguments);\r\n\t\t}\r\n\t});\r\n});\r\n"]}