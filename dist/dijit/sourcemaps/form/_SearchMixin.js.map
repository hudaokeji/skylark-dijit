{"version":3,"sources":["form/_SearchMixin.js"],"names":["define","declare","keys","lang","query","string","when","registry","pageSize","Infinity","store","fetchProperties","list","_setListAttr","this","_set","searchDelay","searchAttr","queryExpr","ignoreCase","_patternToRegExp","pattern","RegExp","replace","str","literal","star","question","_abortQuery","searchTimer","remove","_queryDeferHandle","_fetchHandle","abort","_cancelingQuery","cancel","_processInput","evt","disabled","readOnly","key","charOrCode","type","substring","altKey","ctrlKey","metaKey","SHIFT","doSearch","_prev_key_backspace","DELETE","BACKSPACE","_maskValidSubsetError","defer","onSearch","_startSearchFromInput","_startSearch","focusNode","value","text","q","_this","clone","options","start","count","queryOptions","deep","qs","substitute","startQuery","resPromise","_lastQuery","res","total","isNaN","nextPage","direction","length","Math","max","err","console","error","declaredClass","toString","mixin","_oldAPI","constructor","postMixInProperties","byId","inherited","arguments"],"mappings":"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","file":"../../form/_SearchMixin.js","sourcesContent":["define([\r\n\t\"dojo/_base/declare\", // declare\r\n\t\"dojo/keys\", // keys\r\n\t\"dojo/_base/lang\", // lang.clone lang.hitch\r\n\t\"dojo/query\", // query\r\n\t\"dojo/string\", // string.substitute\r\n\t\"dojo/when\",\r\n\t\"../registry\"\t// registry.byId\r\n], function(declare, keys, lang, query, string, when, registry){\r\n\r\n\t// module:\r\n\t//\t\tdijit/form/_SearchMixin\r\n\r\n\r\n\treturn declare(\"dijit.form._SearchMixin\", null, {\r\n\t\t// summary:\r\n\t\t//\t\tA mixin that implements the base functionality to search a store based upon user-entered text such as\r\n\t\t//\t\twith `dijit/form/ComboBox` or `dijit/form/FilteringSelect`\r\n\t\t// tags:\r\n\t\t//\t\tprotected\r\n\r\n\t\t// pageSize: Integer\r\n\t\t//\t\tArgument to data provider.\r\n\t\t//\t\tSpecifies maximum number of search results to return per query\r\n\t\tpageSize: Infinity,\r\n\r\n\t\t// store: [const] dojo/store/api/Store\r\n\t\t//\t\tReference to data provider object used by this ComboBox.\r\n\t\t//\t\tThe store must accept an object hash of properties for its query. See `query` and `queryExpr` for details.\r\n\t\tstore: null,\r\n\r\n\t\t// fetchProperties: Object\r\n\t\t//\t\tMixin to the store's fetch.\r\n\t\t//\t\tFor example, to set the sort order of the ComboBox menu, pass:\r\n\t\t//\t|\t{ sort: [{attribute:\"name\",descending: true}] }\r\n\t\t//\t\tTo override the default queryOptions so that deep=false, do:\r\n\t\t//\t|\t{ queryOptions: {ignoreCase: true, deep: false} }\r\n\t\tfetchProperties:{},\r\n\r\n\t\t// query: Object\r\n\t\t//\t\tA query that can be passed to `store` to initially filter the items.\r\n\t\t//\t\tComboBox overwrites any reference to the `searchAttr` and sets it to the `queryExpr` with the user's input substituted.\r\n\t\tquery: {},\r\n\r\n\t\t// list: [const] String\r\n\t\t//\t\tAlternate to specifying a store.  Id of a dijit/form/DataList widget.\r\n\t\tlist: \"\",\r\n\t\t_setListAttr: function(list){\r\n\t\t\t// Avoid having list applied to the DOM node, since it has native meaning in modern browsers\r\n\t\t\tthis._set(\"list\", list);\r\n\t\t},\r\n\r\n\t\t// searchDelay: Integer\r\n\t\t//\t\tDelay in milliseconds between when user types something and we start\r\n\t\t//\t\tsearching based on that value\r\n\t\tsearchDelay: 200,\r\n\r\n\t\t// searchAttr: String\r\n\t\t//\t\tSearch for items in the data store where this attribute (in the item)\r\n\t\t//\t\tmatches what the user typed\r\n\t\tsearchAttr: \"name\",\r\n\r\n\t\t// queryExpr: String\r\n\t\t//\t\tThis specifies what query is sent to the data store,\r\n\t\t//\t\tbased on what the user has typed.  Changing this expression will modify\r\n\t\t//\t\twhether the results are only exact matches, a \"starting with\" match,\r\n\t\t//\t\tetc.\r\n\t\t//\t\t`${0}` will be substituted for the user text.\r\n\t\t//\t\t`*` is used for wildcards.\r\n\t\t//\t\t`${0}*` means \"starts with\", `*${0}*` means \"contains\", `${0}` means \"is\"\r\n\t\tqueryExpr: \"${0}*\",\r\n\r\n\t\t// ignoreCase: Boolean\r\n\t\t//\t\tSet true if the query should ignore case when matching possible items\r\n\t\tignoreCase: true,\r\n\r\n\t\t_patternToRegExp: function(pattern){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tHelper function to convert a simple pattern to a regular expression for matching.\r\n\t\t\t// description:\r\n\t\t\t//\t\tReturns a regular expression object that conforms to the defined conversion rules.\r\n\t\t\t//\t\tFor example:\r\n\t\t\t//\r\n\t\t\t//\t\t- ca*   -> /^ca.*$/\r\n\t\t\t//\t\t- *ca*  -> /^.*ca.*$/\r\n\t\t\t//\t\t- *c\\*a*  -> /^.*c\\*a.*$/\r\n\t\t\t//\t\t- *c\\*a?*  -> /^.*c\\*a..*$/\r\n\t\t\t//\r\n\t\t\t//\t\tand so on.\r\n\t\t\t// pattern: string\r\n\t\t\t//\t\tA simple matching pattern to convert that follows basic rules:\r\n\t\t\t//\r\n\t\t\t//\t\t- * Means match anything, so ca* means match anything starting with ca\r\n\t\t\t//\t\t- ? Means match single character.  So, b?b will match to bob and bab, and so on.\r\n\t\t\t//\t\t- \\ is an escape character.  So for example, \\* means do not treat * as a match, but literal character *.\r\n\t\t\t//\r\n\t\t\t//\t\tTo use a \\ as a character in the string, it must be escaped.  So in the pattern it should be\r\n\t\t\t//\t\trepresented by \\\\ to be treated as an ordinary \\ character instead of an escape.\r\n\r\n\t\t\treturn new RegExp(\"^\" + pattern.replace(/(\\\\.)|(\\*)|(\\?)|\\W/g, function(str, literal, star, question){\r\n\t\t\t\treturn star ? \".*\" : question ? \".\" : literal ? literal : \"\\\\\" + str;\r\n\t\t\t}) + \"$\", this.ignoreCase ? \"mi\" : \"m\");\r\n\t\t},\r\n\r\n\t\t_abortQuery: function(){\r\n\t\t\t// stop in-progress query\r\n\t\t\tif(this.searchTimer){\r\n\t\t\t\tthis.searchTimer = this.searchTimer.remove();\r\n\t\t\t}\r\n\t\t\tif(this._queryDeferHandle){\r\n\t\t\t\tthis._queryDeferHandle = this._queryDeferHandle.remove();\r\n\t\t\t}\r\n\t\t\tif(this._fetchHandle){\r\n\t\t\t\tif(this._fetchHandle.abort){\r\n\t\t\t\t\tthis._cancelingQuery = true;\r\n\t\t\t\t\tthis._fetchHandle.abort();\r\n\t\t\t\t\tthis._cancelingQuery = false;\r\n\t\t\t\t}\r\n\t\t\t\tif(this._fetchHandle.cancel){\r\n\t\t\t\t\tthis._cancelingQuery = true;\r\n\t\t\t\t\tthis._fetchHandle.cancel();\r\n\t\t\t\t\tthis._cancelingQuery = false;\r\n\t\t\t\t}\r\n\t\t\t\tthis._fetchHandle = null;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_processInput: function(/*Event*/ evt){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tHandles input (keyboard/paste) events\r\n\t\t\tif(this.disabled || this.readOnly){ return; }\r\n\t\t\tvar key = evt.charOrCode;\r\n\r\n\t\t\t// except for cutting/pasting case - ctrl + x/v\r\n\t\t\tif(\"type\" in evt && evt.type.substring(0,3) == \"key\" && (evt.altKey || ((evt.ctrlKey || evt.metaKey) && (key != 'x' && key != 'v')) || key == keys.SHIFT)){\r\n\t\t\t\treturn; // throw out weird key combinations and spurious events\r\n\t\t\t}\r\n\r\n\t\t\tvar doSearch = false;\r\n\t\t\tthis._prev_key_backspace = false;\r\n\r\n\t\t\tswitch(key){\r\n\t\t\t\tcase keys.DELETE:\r\n\t\t\t\tcase keys.BACKSPACE:\r\n\t\t\t\t\tthis._prev_key_backspace = true;\r\n\t\t\t\t\tthis._maskValidSubsetError = true;\r\n\t\t\t\t\tdoSearch = true;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\t// Non char keys (F1-F12 etc..) shouldn't start a search..\r\n\t\t\t\t\t// Ascii characters and IME input (Chinese, Japanese etc.) should.\r\n\t\t\t\t\t//IME input produces keycode == 229.\r\n\t\t\t\t\tdoSearch = typeof key == 'string' || key == 229;\r\n\t\t\t}\r\n\t\t\tif(doSearch){\r\n\t\t\t\t// need to wait a tad before start search so that the event\r\n\t\t\t\t// bubbles through DOM and we have value visible\r\n\t\t\t\tif(!this.store){\r\n\t\t\t\t\tthis.onSearch();\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthis.searchTimer = this.defer(\"_startSearchFromInput\", 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tonSearch: function(/*===== results, query, options =====*/){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCallback when a search completes.\r\n\t\t\t//\r\n\t\t\t// results: Object\r\n\t\t\t//\t\tAn array of items from the originating _SearchMixin's store.\r\n\t\t\t//\r\n\t\t\t// query: Object\r\n\t\t\t//\t\tA copy of the originating _SearchMixin's query property.\r\n\t\t\t//\r\n\t\t\t// options: Object\r\n\t\t\t//\t\tThe additional parameters sent to the originating _SearchMixin's store, including: start, count, queryOptions.\r\n\t\t\t//\r\n\t\t\t// tags:\r\n\t\t\t//\t\tcallback\r\n\t\t},\r\n\r\n\t\t_startSearchFromInput: function(){\r\n\t\t\tthis._startSearch(this.focusNode.value);\r\n\t\t},\r\n\r\n\t\t_startSearch: function(/*String*/ text){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tStarts a search for elements matching text (text==\"\" means to return all items),\r\n\t\t\t//\t\tand calls onSearch(...) when the search completes, to display the results.\r\n\r\n\t\t\tthis._abortQuery();\r\n\t\t\tvar\r\n\t\t\t\t_this = this,\r\n\t\t\t\t// Setup parameters to be passed to store.query().\r\n\t\t\t\t// Create a new query to prevent accidentally querying for a hidden\r\n\t\t\t\t// value from FilteringSelect's keyField\r\n\t\t\t\tquery = lang.clone(this.query), // #5970\r\n\t\t\t\toptions = {\r\n\t\t\t\t\tstart: 0,\r\n\t\t\t\t\tcount: this.pageSize,\r\n\t\t\t\t\tqueryOptions: {\t\t// remove for 2.0\r\n\t\t\t\t\t\tignoreCase: this.ignoreCase,\r\n\t\t\t\t\t\tdeep: true\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\tqs = string.substitute(this.queryExpr, [text.replace(/([\\\\\\*\\?])/g, \"\\\\$1\")]),\r\n\t\t\t\tq,\r\n\t\t\t\tstartQuery = function(){\r\n\t\t\t\t\tvar resPromise = _this._fetchHandle = _this.store.query(query, options);\r\n\t\t\t\t\tif(_this.disabled || _this.readOnly || (q !== _this._lastQuery)){\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t} // avoid getting unwanted notify\r\n\t\t\t\t\twhen(resPromise, function(res){\r\n\t\t\t\t\t\t_this._fetchHandle = null;\r\n\t\t\t\t\t\tif(!_this.disabled && !_this.readOnly && (q === _this._lastQuery)){ // avoid getting unwanted notify\r\n\t\t\t\t\t\t\twhen(resPromise.total, function(total){\r\n\t\t\t\t\t\t\t\tres.total = total;\r\n\t\t\t\t\t\t\t\tvar pageSize = _this.pageSize;\r\n\t\t\t\t\t\t\t\tif(isNaN(pageSize) || pageSize > res.total){ pageSize = res.total; }\r\n\t\t\t\t\t\t\t\t// Setup method to fetching the next page of results\r\n\t\t\t\t\t\t\t\tres.nextPage = function(direction){\r\n\t\t\t\t\t\t\t\t\t//\ttell callback the direction of the paging so the screen\r\n\t\t\t\t\t\t\t\t\t//\treader knows which menu option to shout\r\n\t\t\t\t\t\t\t\t\toptions.direction = direction = direction !== false;\r\n\t\t\t\t\t\t\t\t\toptions.count = pageSize;\r\n\t\t\t\t\t\t\t\t\tif(direction){\r\n\t\t\t\t\t\t\t\t\t\toptions.start += res.length;\r\n\t\t\t\t\t\t\t\t\t\tif(options.start >= res.total){\r\n\t\t\t\t\t\t\t\t\t\t\toptions.count = 0;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\toptions.start -= pageSize;\r\n\t\t\t\t\t\t\t\t\t\tif(options.start < 0){\r\n\t\t\t\t\t\t\t\t\t\t\toptions.count = Math.max(pageSize + options.start, 0);\r\n\t\t\t\t\t\t\t\t\t\t\toptions.start = 0;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif(options.count <= 0){\r\n\t\t\t\t\t\t\t\t\t\tres.length = 0;\r\n\t\t\t\t\t\t\t\t\t\t_this.onSearch(res, query, options);\r\n\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\tstartQuery();\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t\t_this.onSearch(res, query, options);\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}, function(err){\r\n\t\t\t\t\t\t_this._fetchHandle = null;\r\n\t\t\t\t\t\tif(!_this._cancelingQuery){\t// don't treat canceled query as an error\r\n\t\t\t\t\t\t\tconsole.error(_this.declaredClass + ' ' + err.toString());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t};\r\n\r\n\t\t\tlang.mixin(options, this.fetchProperties);\r\n\r\n\t\t\t// Generate query\r\n\t\t\tif(this.store._oldAPI){\r\n\t\t\t\t// remove this branch for 2.0\r\n\t\t\t\tq = qs;\r\n\t\t\t}else{\r\n\t\t\t\t// Query on searchAttr is a regex for benefit of dojo/store/Memory,\r\n\t\t\t\t// but with a toString() method to help dojo/store/JsonRest.\r\n\t\t\t\t// Search string like \"Co*\" converted to regex like /^Co.*$/i.\r\n\t\t\t\tq = this._patternToRegExp(qs);\r\n\t\t\t\tq.toString = function(){ return qs; };\r\n\t\t\t}\r\n\r\n\t\t\t// set _lastQuery, *then* start the timeout\r\n\t\t\t// otherwise, if the user types and the last query returns before the timeout,\r\n\t\t\t// _lastQuery won't be set and their input gets rewritten\r\n\t\t\tthis._lastQuery = query[this.searchAttr] = q;\r\n\t\t\tthis._queryDeferHandle = this.defer(startQuery, this.searchDelay);\r\n\t\t},\r\n\r\n\t\t//////////// INITIALIZATION METHODS ///////////////////////////////////////\r\n\r\n\t\tconstructor: function(){\r\n\t\t\tthis.query={};\r\n\t\t\tthis.fetchProperties={};\r\n\t\t},\r\n\r\n\t\tpostMixInProperties: function(){\r\n\t\t\tif(!this.store){\r\n\t\t\t\tvar list = this.list;\r\n\t\t\t\tif(list){\r\n\t\t\t\t\tthis.store = registry.byId(list);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.inherited(arguments);\r\n\t\t}\r\n\t});\r\n});\r\n"]}