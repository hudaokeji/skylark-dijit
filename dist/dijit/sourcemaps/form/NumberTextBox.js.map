{"version":3,"sources":["form/NumberTextBox.js"],"names":["define","declare","lang","i18n","string","number","RangeBoundTextBox","getDecimalInfo","constraints","places","bundle","getLocalization","normalizeLocale","locale","pattern","type","length","replace","indexOf","split","sep","decimal","NumberTextBoxMixin","this","focused","editOptions","_regExpGenerator","delegate","value","NaN","_formatter","format","regexp","_decimalInfo","postMixInProperties","inherited","arguments","_set","_setConstraintsAttr","max","Math","pow","min","focusNode","isNaN","set","_onFocus","disabled","readOnly","val","get","formattedValue","undefined","textbox","String","rangeCheck","exponent","test","mixin","_parser","parse","v","_getDisplayedValueAttr","filter","round","serialize","options","_setBlurValue","hitch","_setValueAttr","priorityChange","_getValueAttr","RegExp","_realNumberRegexp","n","Number","isValid","isFocused","_isEmpty","_isValidSubset","hasMinConstraint","hasMaxConstraint","curVal","integerDigits","valNegative","hasDecimal","remainingDigitsCount","maxLength","fractionalDigitStr","normalizedValueStr","ninePaddingStr","rep","minPossibleValue","maxPossibleValue","NumberTextBox","baseClass","Mixin"],"mappings":"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","file":"../../form/NumberTextBox.js","sourcesContent":["define([\r\n\t\"dojo/_base/declare\", // declare\r\n\t\"dojo/_base/lang\", // lang.hitch lang.mixin\r\n\t\"dojo/i18n\", // i18n.normalizeLocale, i18n.getLocalization\r\n\t\"dojo/string\", // string.rep\r\n\t\"dojo/number\", // number._realNumberRegexp number.format number.parse number.regexp\r\n\t\"./RangeBoundTextBox\"\r\n], function(declare, lang, i18n, string, number, RangeBoundTextBox){\r\n\r\n\t// module:\r\n\t//\t\tdijit/form/NumberTextBox\r\n\r\n\t// A private helper function to determine decimal information\r\n\t// Returns an object with \"sep\" and \"places\" properties\r\n\tvar getDecimalInfo = function(constraints){\r\n\t\tvar constraints = constraints || {},\r\n\t\t\tbundle = i18n.getLocalization(\"dojo.cldr\", \"number\", i18n.normalizeLocale(constraints.locale)),\r\n\t\t\tpattern = constraints.pattern ? constraints.pattern : bundle[(constraints.type || \"decimal\")+\"Format\"];\r\n\r\n\t\t// The number of places in the constraint can be specified in several ways,\r\n\t\t// the resolution order is:\r\n\t\t//\r\n\t\t// 1. If constraints.places is a number, use that\r\n\t\t// 2. If constraints.places is a string, which specifies a range, use the range max (e.g. 0,4)\r\n\t\t// 3. If a pattern is specified, use the implicit number of places in the pattern.\r\n\t\t// 4. If neither constraints.pattern or constraints.places is specified, use the locale default pattern\r\n\t\tvar places;\r\n\t\tif(typeof constraints.places == \"number\"){\r\n\t\t\tplaces = constraints.places;\r\n\t\t}else if(typeof constraints.places === \"string\" && constraints.places.length > 0){\r\n\t\t\tplaces = constraints.places.replace(/.*,/, \"\");\r\n\t\t}else{\r\n\t\t\tplaces = (pattern.indexOf(\".\") != -1 ? pattern.split(\".\")[1].replace(/[^#0]/g, \"\").length : 0);\r\n\t\t}\r\n\r\n\t\treturn { sep: bundle.decimal, places: places };\r\n\t};\r\n\r\n\tvar NumberTextBoxMixin = declare(\"dijit.form.NumberTextBoxMixin\", null, {\r\n\t\t// summary:\r\n\t\t//\t\tA mixin for all number textboxes\r\n\t\t// tags:\r\n\t\t//\t\tprotected\r\n\r\n\t\t// Override ValidationTextBox.pattern.... we use a reg-ex generating function rather\r\n\t\t// than a straight regexp to deal with locale (plus formatting options too?)\r\n\t\tpattern: function(constraints){\r\n\t\t\t// if focused, accept either currency data or NumberTextBox format\r\n\t\t\treturn '(' + (this.focused && this.editOptions ? this._regExpGenerator(lang.delegate(constraints, this.editOptions)) + '|' : '')\r\n\t\t\t\t+ this._regExpGenerator(constraints) + ')';\r\n\t\t},\r\n\r\n\t\t/*=====\r\n\t\t// constraints: NumberTextBox.__Constraints\r\n\t\t//\t\tDespite the name, this parameter specifies both constraints on the input\r\n\t\t//\t\t(including minimum/maximum allowed values) as well as\r\n\t\t//\t\tformatting options like places (the number of digits to display after\r\n\t\t//\t\tthe decimal point).\r\n\t\tconstraints: {},\r\n\t\t======*/\r\n\r\n\t\t// value: Number\r\n\t\t//\t\tThe value of this NumberTextBox as a Javascript Number (i.e., not a String).\r\n\t\t//\t\tIf the displayed value is blank, the value is NaN, and if the user types in\r\n\t\t//\t\tan gibberish value (like \"hello world\"), the value is undefined\r\n\t\t//\t\t(i.e. get('value') returns undefined).\r\n\t\t//\r\n\t\t//\t\tSymmetrically, set('value', NaN) will clear the displayed value,\r\n\t\t//\t\twhereas set('value', undefined) will have no effect.\r\n\t\tvalue: NaN,\r\n\r\n\t\t// editOptions: [protected] Object\r\n\t\t//\t\tProperties to mix into constraints when the value is being edited.\r\n\t\t//\t\tThis is here because we edit the number in the format \"12345\", which is\r\n\t\t//\t\tdifferent than the display value (ex: \"12,345\")\r\n\t\teditOptions: { pattern: '#.######' },\r\n\r\n\t\t/*=====\r\n\t\t_formatter: function(value, options){\r\n\t\t\t// summary:\r\n\t\t\t//\t\t_formatter() is called by format().  It's the base routine for formatting a number,\r\n\t\t\t//\t\tas a string, for example converting 12345 into \"12,345\".\r\n\t\t\t// value: Number\r\n\t\t\t//\t\tThe number to be converted into a string.\r\n\t\t\t// options: number.__FormatOptions?\r\n\t\t\t//\t\tFormatting options\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected extension\r\n\r\n\t\t\treturn \"12345\";\t\t// String\r\n\t\t},\r\n\t\t =====*/\r\n\t\t_formatter: number.format,\r\n\r\n\t\t/*=====\r\n\t\t_regExpGenerator: function(constraints){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tGenerate a localized regular expression as a string, according to constraints.\r\n\t\t\t// constraints: number.__ParseOptions\r\n\t\t\t//\t\tFormatting options\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\r\n\t\t\treturn \"(\\d*).(\\d*)\";\t// string\r\n\t\t},\r\n\t\t=====*/\r\n\t\t_regExpGenerator: number.regexp,\r\n\r\n\t\t// _decimalInfo: Object\r\n\t\t// summary:\r\n\t\t//\t\tAn object containing decimal related properties relevant to this TextBox.\r\n\t\t// tags:\r\n\t\t//\t\tprivate\r\n\t\t_decimalInfo: getDecimalInfo(),\r\n\r\n\t\tpostMixInProperties: function(){\r\n\t\t\tthis.inherited(arguments);\r\n\t\t\tthis._set(\"type\", \"text\"); // in case type=\"number\" was specified which messes up parse/format\r\n\t\t},\r\n\r\n\t\t_setConstraintsAttr: function(/*Object*/ constraints){\r\n\t\t\tvar places = typeof constraints.places == \"number\"? constraints.places : 0;\r\n\t\t\tif(places){ places++; } // decimal rounding errors take away another digit of precision\r\n\t\t\tif(typeof constraints.max != \"number\"){\r\n\t\t\t\tconstraints.max = 9 * Math.pow(10, 15-places);\r\n\t\t\t}\r\n\t\t\tif(typeof constraints.min != \"number\"){\r\n\t\t\t\tconstraints.min = -9 * Math.pow(10, 15-places);\r\n\t\t\t}\r\n\t\t\tthis.inherited(arguments, [ constraints ]);\r\n\t\t\tif(this.focusNode && this.focusNode.value && !isNaN(this.value)){\r\n\t\t\t\tthis.set('value', this.value);\r\n\t\t\t}\r\n\t\t\t// Capture decimal information based on the constraint locale and pattern.\r\n\t\t\tthis._decimalInfo = getDecimalInfo(constraints);\r\n\t\t},\r\n\r\n\t\t_onFocus: function(){\r\n\t\t\tif(this.disabled || this.readOnly){ return; }\r\n\t\t\tvar val = this.get('value');\r\n\t\t\tif(typeof val == \"number\" && !isNaN(val)){\r\n\t\t\t\tvar formattedValue = this.format(val, this.constraints);\r\n\t\t\t\tif(formattedValue !== undefined){\r\n\t\t\t\t\tthis.textbox.value = formattedValue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.inherited(arguments);\r\n\t\t},\r\n\r\n\t\tformat: function(/*Number*/ value, /*number.__FormatOptions*/ constraints){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tFormats the value as a Number, according to constraints.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\r\n\t\t\tvar formattedValue = String(value);\r\n\t\t\tif(typeof value != \"number\"){ return formattedValue; }\r\n\t\t\tif(isNaN(value)){ return \"\"; }\r\n\t\t\t// check for exponential notation that dojo/number.format() chokes on\r\n\t\t\tif(!(\"rangeCheck\" in this && this.rangeCheck(value, constraints)) && constraints.exponent !== false && /\\de[-+]?\\d/i.test(formattedValue)){\r\n\t\t\t\treturn formattedValue;\r\n\t\t\t}\r\n\t\t\tif(this.editOptions && this.focused){\r\n\t\t\t\tconstraints = lang.mixin({}, constraints, this.editOptions);\r\n\t\t\t}\r\n\t\t\treturn this._formatter(value, constraints);\r\n\t\t},\r\n\r\n\t\t/*=====\r\n\t\t_parser: function(value, constraints){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tParses the string value as a Number, according to constraints.\r\n\t\t\t// value: String\r\n\t\t\t//\t\tString representing a number\r\n\t\t\t// constraints: number.__ParseOptions\r\n\t\t\t//\t\tFormatting options\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\r\n\t\t\treturn 123.45;\t\t// Number\r\n\t\t},\r\n\t\t=====*/\r\n\t\t_parser: number.parse,\r\n\r\n\t\tparse: function(/*String*/ value, /*number.__FormatOptions*/ constraints){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReplaceable function to convert a formatted string to a number value\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected extension\r\n\r\n\t\t\tvar v = this._parser(value, lang.mixin({}, constraints, (this.editOptions && this.focused) ? this.editOptions : {}));\r\n\t\t\tif(this.editOptions && this.focused && isNaN(v)){\r\n\t\t\t\tv = this._parser(value, constraints); // parse w/o editOptions: not technically needed but is nice for the user\r\n\t\t\t}\r\n\t\t\treturn v;\r\n\t\t},\r\n\r\n\t\t_getDisplayedValueAttr: function(){\r\n\t\t\tvar v = this.inherited(arguments);\r\n\t\t\treturn isNaN(v) ? this.textbox.value : v;\r\n\t\t},\r\n\r\n\t\tfilter: function(/*Number*/ value){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tThis is called with both the display value (string), and the actual value (a number).\r\n\t\t\t//\t\tWhen called with the actual value it does corrections so that '' etc. are represented as NaN.\r\n\t\t\t//\t\tOtherwise it dispatches to the superclass's filter() method.\r\n\t\t\t//\r\n\t\t\t//\t\tSee `dijit/form/TextBox.filter()` for more details.\r\n\t\t\tif(value == null  /* or undefined */ || typeof value == \"string\" && value ==''){\r\n\t\t\t\treturn NaN;\r\n\t\t\t}else if(typeof value == \"number\" && !isNaN(value) && value != 0){\r\n\t\t\t\tvalue = number.round(value, this._decimalInfo.places);\r\n\t\t\t}\r\n\t\t\treturn this.inherited(arguments, [value]);\r\n\t\t},\r\n\r\n\t\tserialize: function(/*Number*/ value, /*Object?*/ options){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tConvert value (a Number) into a canonical string (ie, how the number literal is written in javascript/java/C/etc.)\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\t\t\treturn (typeof value != \"number\" || isNaN(value)) ? '' : this.inherited(arguments);\r\n\t\t},\r\n\r\n\t\t_setBlurValue: function(){\r\n\t\t\tvar val = lang.hitch(lang.delegate(this, { focused: true }), \"get\")('value'); // parse with editOptions\r\n\t\t\tthis._setValueAttr(val, true);\r\n\t\t},\r\n\r\n\t\t_setValueAttr: function(/*Number*/ value, /*Boolean?*/ priorityChange, /*String?*/ formattedValue){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tHook so set('value', ...) works.\r\n\t\t\tif(value !== undefined && formattedValue === undefined){\r\n\t\t\t\tformattedValue = String(value);\r\n\t\t\t\tif(typeof value == \"number\"){\r\n\t\t\t\t\tif(isNaN(value)){ formattedValue = '' }\r\n\t\t\t\t\t// check for exponential notation that number.format chokes on\r\n\t\t\t\t\telse if((\"rangeCheck\" in this && this.rangeCheck(value, this.constraints)) || this.constraints.exponent === false || !/\\de[-+]?\\d/i.test(formattedValue)){\r\n\t\t\t\t\t\tformattedValue = undefined; // lets format compute a real string value\r\n\t\t\t\t\t}\r\n\t\t\t\t}else if(!value){ // 0 processed in if branch above, ''|null|undefined flows through here\r\n\t\t\t\t\tformattedValue = '';\r\n\t\t\t\t\tvalue = NaN;\r\n\t\t\t\t}else{ // non-numeric values\r\n\t\t\t\t\tvalue = undefined;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.inherited(arguments, [value, priorityChange, formattedValue]);\r\n\t\t},\r\n\r\n\t\t_getValueAttr: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tHook so get('value') works.\r\n\t\t\t//\t\tReturns Number, NaN for '', or undefined for unparseable text\r\n\t\t\tvar v = this.inherited(arguments); // returns Number for all values accepted by parse() or NaN for all other displayed values\r\n\r\n\t\t\t// If the displayed value of the textbox is gibberish (ex: \"hello world\"), this.inherited() above\r\n\t\t\t// returns NaN; this if() branch converts the return value to undefined.\r\n\t\t\t// Returning undefined prevents user text from being overwritten when doing _setValueAttr(_getValueAttr()).\r\n\t\t\t// A blank displayed value is still returned as NaN.\r\n\t\t\tif(isNaN(v) && this.textbox.value !== ''){\r\n\t\t\t\tif(this.constraints.exponent !== false && /\\de[-+]?\\d/i.test(this.textbox.value) && (new RegExp(\"^\"+number._realNumberRegexp(lang.delegate(this.constraints))+\"$\").test(this.textbox.value))){\t// check for exponential notation that parse() rejected (erroneously?)\r\n\t\t\t\t\tvar n = Number(this.textbox.value);\r\n\t\t\t\t\treturn isNaN(n) ? undefined : n; // return exponential Number or undefined for random text (may not be possible to do with the above RegExp check)\r\n\t\t\t\t}else{\r\n\t\t\t\t\treturn undefined; // gibberish\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\treturn v; // Number or NaN for ''\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tisValid: function(/*Boolean*/ isFocused){\r\n\t\t\t// Overrides dijit/form/RangeBoundTextBox.isValid() to check that the editing-mode value is valid since\r\n\t\t\t// it may not be formatted according to the regExp validation rules\r\n\t\t\tif(!this.focused || this._isEmpty(this.textbox.value)){\r\n\t\t\t\treturn this.inherited(arguments);\r\n\t\t\t}else{\r\n\t\t\t\tvar v = this.get('value');\r\n\t\t\t\tif(!isNaN(v) && this.rangeCheck(v, this.constraints)){\r\n\t\t\t\t\tif(this.constraints.exponent !== false && /\\de[-+]?\\d/i.test(this.textbox.value)){ // exponential, parse doesn't like it\r\n\t\t\t\t\t\treturn true; // valid exponential number in range\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\treturn this.inherited(arguments);\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_isValidSubset: function(){\r\n\t\t\t// Overrides dijit/form/ValidationTextBox._isValidSubset()\r\n\t\t\t//\r\n\t\t\t// The inherited method only checks that the computed regex pattern is valid, which doesn't\r\n\t\t\t// take into account that numbers are a special case. Specifically:\r\n\t\t\t//\r\n\t\t\t//  (1) An arbitrary amount of leading or trailing zero's can be ignored.\r\n\t\t\t//  (2) Since numeric input always occurs in the order of most significant to least significant\r\n\t\t\t//      digits, the maximum and minimum possible values for partially inputted numbers can easily\r\n\t\t\t//      be determined by using the number of remaining digit spaces available.\r\n\t\t\t//\r\n\t\t\t// For example, if an input has a maxLength of 5, and a min value of greater than 100, then the subset\r\n\t\t\t// is invalid if there are 3 leading 0s. It remains valid for the first two.\r\n\t\t\t//\r\n\t\t\t// Another example is if the min value is 1.1. Once a value of 1.0 is entered, no additional trailing digits\r\n\t\t\t// could possibly satisify the min requirement.\r\n\t\t\t//\r\n\t\t\t// See ticket #17923\r\n\t\t\tvar hasMinConstraint = (typeof this.constraints.min == \"number\"),\r\n\t\t\t\thasMaxConstraint = (typeof this.constraints.max == \"number\"),\r\n\t\t\t\tcurVal = this.get('value');\r\n\r\n\t\t\t// If there is no parsable number, or there are no min or max bounds, then we can safely\r\n\t\t\t// skip all remaining checks\r\n\t\t\tif(isNaN(curVal) || (!hasMinConstraint && !hasMaxConstraint)){\r\n\t\t\t\treturn this.inherited(arguments);\r\n\t\t\t}\r\n\r\n\t\t\t// This block picks apart the values in the text box to be used later to compute the min and max possible\r\n\t\t\t// values based on the current value and the remaining available digits.\r\n\t\t\t//\r\n\t\t\t// Warning: The use of a \"num|0\" expression, can be confusing. See the link below\r\n\t\t\t// for an explanation.\r\n\t\t\t//\r\n\t\t\t// http://stackoverflow.com/questions/12125421/why-does-a-shift-by-0-truncate-the-decimal\r\n\t\t\tvar integerDigits = curVal|0,\r\n\t\t\t\tvalNegative = curVal < 0,\r\n\t\t\t\t// Check if the current number has a decimal based on its locale\r\n\t\t\t\thasDecimal = this.textbox.value.indexOf(this._decimalInfo.sep) != -1,\r\n\t\t\t\t// Determine the max digits based on the textbox length. If no length is\r\n\t\t\t\t// specified, chose a huge number to account for crazy formatting.\r\n\t\t\t\tmaxDigits = this.maxLength || 20,\r\n\t\t\t\t// Determine the remaining digits, based on the max digits\r\n\t\t\t\tremainingDigitsCount = maxDigits - this.textbox.value.length,\r\n\t\t\t\t// avoid approximation issues by capturing the decimal portion of the value as the user-entered string\r\n\t\t\t\tfractionalDigitStr = hasDecimal ? this.textbox.value.split(this._decimalInfo.sep)[1].replace(/[^0-9]/g, \"\") : \"\";\r\n\r\n\t\t\t// Create a normalized value string in the form of #.###\r\n\t\t\tvar normalizedValueStr = hasDecimal ? integerDigits+\".\"+fractionalDigitStr : integerDigits+\"\";\r\n\r\n\t\t\t// The min and max values for the field can be determined using the following\r\n\t\t\t// logic:\r\n\t\t\t//\r\n\t\t\t//  If the number is positive:\r\n\t\t\t//      min value = the current value\r\n\t\t\t//      max value = the current value with 9s appended for all remaining possible digits\r\n\t\t\t//  else\r\n\t\t\t//      min value = the current value with 9s appended for all remaining possible digits\r\n\t\t\t//      max value = the current value\r\n\t\t\t//\r\n\t\t\tvar ninePaddingStr = string.rep(\"9\", remainingDigitsCount),\r\n\t\t\t    minPossibleValue = curVal,\r\n\t\t\t    maxPossibleValue = curVal;\r\n\t\t\tif (valNegative){\r\n\t\t\t\tminPossibleValue = Number(normalizedValueStr+ninePaddingStr);\r\n\t\t\t} else{\r\n\t\t\t\tmaxPossibleValue = Number(normalizedValueStr+ninePaddingStr);\r\n\t\t\t}\r\n\r\n\t\t\treturn !((hasMinConstraint && maxPossibleValue < this.constraints.min)\r\n\t\t\t\t\t|| (hasMaxConstraint && minPossibleValue > this.constraints.max));\r\n\t\t}\r\n\t});\r\n\r\n\tvar NumberTextBox = declare(\"dijit.form.NumberTextBox\", [RangeBoundTextBox, NumberTextBoxMixin], {\r\n\t\t// summary:\r\n\t\t//\t\tA TextBox for entering numbers, with formatting and range checking\r\n\t\t// description:\r\n\t\t//\t\tNumberTextBox is a textbox for entering and displaying numbers, supporting\r\n\t\t//\t\tthe following main features:\r\n\t\t//\r\n\t\t//\t\t1. Enforce minimum/maximum allowed values (as well as enforcing that the user types\r\n\t\t//\t\t\ta number rather than a random string)\r\n\t\t//\t\t2. NLS support (altering roles of comma and dot as \"thousands-separator\" and \"decimal-point\"\r\n\t\t//\t\t\tdepending on locale).\r\n\t\t//\t\t3. Separate modes for editing the value and displaying it, specifically that\r\n\t\t//\t\t\tthe thousands separator character (typically comma) disappears when editing\r\n\t\t//\t\t\tbut reappears after the field is blurred.\r\n\t\t//\t\t4. Formatting and constraints regarding the number of places (digits after the decimal point)\r\n\t\t//\t\t\tallowed on input, and number of places displayed when blurred (see `constraints` parameter).\r\n\r\n\t\tbaseClass: \"dijitTextBox dijitNumberTextBox\"\r\n\t});\r\n\r\n\tNumberTextBox.Mixin = NumberTextBoxMixin;\t// for monkey patching\r\n\r\n\t/*=====\r\n\t NumberTextBox.__Constraints = declare([RangeBoundTextBox.__Constraints, number.__FormatOptions, number.__ParseOptions], {\r\n\t\t // summary:\r\n\t\t //\t\tSpecifies both the rules on valid/invalid values (minimum, maximum,\r\n\t\t //\t\tnumber of required decimal places), and also formatting options for\r\n\t\t //\t\tdisplaying the value when the field is not focused.\r\n\t\t // example:\r\n\t\t //\t\tMinimum/maximum:\r\n\t\t //\t\tTo specify a field between 0 and 120:\r\n\t\t //\t|\t\t{min:0,max:120}\r\n\t\t //\t\tTo specify a field that must be an integer:\r\n\t\t //\t|\t\t{fractional:false}\r\n\t\t //\t\tTo specify a field where 0 to 3 decimal places are allowed on input:\r\n\t\t //\t|\t\t{places:'0,3'}\r\n\t });\r\n\t =====*/\r\n\r\n\treturn NumberTextBox;\r\n});\r\n"]}