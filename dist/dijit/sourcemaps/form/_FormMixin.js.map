{"version":3,"sources":["form/_FormMixin.js"],"names":["define","array","declare","kernel","lang","on","winUtils","state","_getDescendantFormWidgets","children","res","forEach","this","getChildren","child","push","concat","reset","widget","validate","didFocus","every","map","_hasBeenBlurred","valid","disabled","scrollIntoView","containerNode","domNode","focus","item","setValues","val","deprecated","declaredClass","set","_setValueAttr","obj","name","hasOwnProperty","widgets","values","getObject","undefined","checked","w","indexOf","_get","multiple","i","getValues","get","_getValueAttr","value","test","setObject","ary","prev","isArray","isValid","onValidStateChange","_getState","states","_descendants","disconnectChildren","connectChildren","inStartup","_started","startup","_onChildChange","attr","_set","_onChangeDelayTimer","remove","defer","inherited","arguments","self","own","evt","target","type","replace","watch","oldVal","newVal","destroy"],"mappings":"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","file":"../../form/_FormMixin.js","sourcesContent":["define([\r\n\t\"dojo/_base/array\", // array.every array.filter array.forEach array.indexOf array.map\r\n\t\"dojo/_base/declare\", // declare\r\n\t\"dojo/_base/kernel\", // kernel.deprecated\r\n\t\"dojo/_base/lang\", // lang.hitch lang.isArray\r\n\t\"dojo/on\",\r\n\t\"dojo/window\" // winUtils.scrollIntoView\r\n], function(array, declare, kernel, lang, on, winUtils){\r\n\r\n\t// module:\r\n\t//\t\tdijit/form/_FormMixin\r\n\r\n\treturn declare(\"dijit.form._FormMixin\", null, {\r\n\t\t// summary:\r\n\t\t//\t\tMixin for containers of form widgets (i.e. widgets that represent a single value\r\n\t\t//\t\tand can be children of a `<form>` node or `dijit/form/Form` widget)\r\n\t\t// description:\r\n\t\t//\t\tCan extract all the form widgets\r\n\t\t//\t\tvalues and combine them into a single javascript object, or alternately\r\n\t\t//\t\ttake such an object and set the values for all the contained\r\n\t\t//\t\tform widgets\r\n\r\n\t/*=====\r\n\t\t// value: Object\r\n\t\t//\t\tName/value hash for each child widget with a name and value.\r\n\t\t//\t\tChild widgets without names are not part of the hash.\r\n\t\t//\r\n\t\t//\t\tIf there are multiple child widgets w/the same name, value is an array,\r\n\t\t//\t\tunless they are radio buttons in which case value is a scalar (since only\r\n\t\t//\t\tone radio button can be checked at a time).\r\n\t\t//\r\n\t\t//\t\tIf a child widget's name is a dot separated list (like a.b.c.d), it's a nested structure.\r\n\t\t//\r\n\t\t//\t\tExample:\r\n\t\t//\t|\t{ name: \"John Smith\", interests: [\"sports\", \"movies\"] }\r\n\t=====*/\r\n\r\n\t\t// state: [readonly] String\r\n\t\t//\t\tWill be \"Error\" if one or more of the child widgets has an invalid value,\r\n\t\t//\t\t\"Incomplete\" if not all of the required child widgets are filled in.  Otherwise, \"\",\r\n\t\t//\t\twhich indicates that the form is ready to be submitted.\r\n\t\tstate: \"\",\r\n\r\n\t\t// TODO:\r\n\t\t//\t* Repeater\r\n\t\t//\t* better handling for arrays.  Often form elements have names with [] like\r\n\t\t//\t* people[3].sex (for a list of people [{name: Bill, sex: M}, ...])\r\n\r\n\r\n\t\t_getDescendantFormWidgets: function(/*dijit/_WidgetBase[]?*/ children){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns all form widget descendants, searching through non-form child widgets like BorderContainer\r\n\t\t\tvar res = [];\r\n\t\t\tarray.forEach(children || this.getChildren(), function(child){\r\n\t\t\t\tif(\"value\" in child){\r\n\t\t\t\t\tres.push(child);\r\n\t\t\t\t}else{\r\n\t\t\t\t\tres = res.concat(this._getDescendantFormWidgets(child.getChildren()));\r\n\t\t\t\t}\r\n\t\t\t}, this);\r\n\t\t\treturn res;\r\n\t\t},\r\n\r\n\t\treset: function(){\r\n\t\t\tarray.forEach(this._getDescendantFormWidgets(), function(widget){\r\n\t\t\t\tif(widget.reset){\r\n\t\t\t\t\twidget.reset();\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\tvalidate: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\treturns if the form is valid - same as isValid - but\r\n\t\t\t//\t\tprovides a few additional (ui-specific) features:\r\n\t\t\t//\r\n\t\t\t//\t\t1. it will highlight any sub-widgets that are not valid\r\n\t\t\t//\t\t2. it will call focus() on the first invalid sub-widget\r\n\t\t\tvar didFocus = false;\r\n\t\t\treturn array.every(array.map(this._getDescendantFormWidgets(), function(widget){\r\n\t\t\t\t// Need to set this so that \"required\" widgets get their\r\n\t\t\t\t// state set.\r\n\t\t\t\twidget._hasBeenBlurred = true;\r\n\t\t\t\tvar valid = widget.disabled || !widget.validate || widget.validate();\r\n\t\t\t\tif(!valid && !didFocus){\r\n\t\t\t\t\t// Set focus of the first non-valid widget\r\n\t\t\t\t\twinUtils.scrollIntoView(widget.containerNode || widget.domNode);\r\n\t\t\t\t\twidget.focus();\r\n\t\t\t\t\tdidFocus = true;\r\n\t\t\t\t}\r\n\t\t\t\treturn valid;\r\n\t\t\t}), function(item){ return item; });\r\n\t\t},\r\n\r\n\t\tsetValues: function(val){\r\n\t\t\tkernel.deprecated(this.declaredClass+\"::setValues() is deprecated. Use set('value', val) instead.\", \"\", \"2.0\");\r\n\t\t\treturn this.set('value', val);\r\n\t\t},\r\n\t\t_setValueAttr: function(/*Object*/ obj){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tFill in form values from according to an Object (in the format returned by get('value'))\r\n\r\n\t\t\t// generate map from name --> [list of widgets with that name]\r\n\t\t\tvar map = { };\r\n\t\t\tarray.forEach(this._getDescendantFormWidgets(), function(widget){\r\n\t\t\t\tif(!widget.name){ return; }\r\n\t\t\t\tvar entry = map[widget.name] || (map[widget.name] = [] );\r\n\t\t\t\tentry.push(widget);\r\n\t\t\t});\r\n\r\n\t\t\tfor(var name in map){\r\n\t\t\t\tif(!map.hasOwnProperty(name)){\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tvar widgets = map[name],\t\t\t\t\t\t// array of widgets w/this name\r\n\t\t\t\t\tvalues = lang.getObject(name, false, obj);\t// list of values for those widgets\r\n\r\n\t\t\t\tif(values === undefined){\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tvalues = [].concat(values);\r\n\t\t\t\tif(typeof widgets[0].checked == 'boolean'){\r\n\t\t\t\t\t// for checkbox/radio, values is a list of which widgets should be checked\r\n\t\t\t\t\tarray.forEach(widgets, function(w){\r\n\t\t\t\t\t\tw.set('value', array.indexOf(values, w._get('value')) != -1);\r\n\t\t\t\t\t});\r\n\t\t\t\t}else if(widgets[0].multiple){\r\n\t\t\t\t\t// it takes an array (e.g. multi-select)\r\n\t\t\t\t\twidgets[0].set('value', values);\r\n\t\t\t\t}else{\r\n\t\t\t\t\t// otherwise, values is a list of values to be assigned sequentially to each widget\r\n\t\t\t\t\tarray.forEach(widgets, function(w, i){\r\n\t\t\t\t\t\tw.set('value', values[i]);\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t/***\r\n\t\t\t *\tTODO: code for plain input boxes (this shouldn't run for inputs that are part of widgets)\r\n\r\n\t\t\tarray.forEach(this.containerNode.elements, function(element){\r\n\t\t\t\tif(element.name == ''){return};\t// like \"continue\"\r\n\t\t\t\tvar namePath = element.name.split(\".\");\r\n\t\t\t\tvar myObj=obj;\r\n\t\t\t\tvar name=namePath[namePath.length-1];\r\n\t\t\t\tfor(var j=1,len2=namePath.length;j<len2;++j){\r\n\t\t\t\t\tvar p=namePath[j - 1];\r\n\t\t\t\t\t// repeater support block\r\n\t\t\t\t\tvar nameA=p.split(\"[\");\r\n\t\t\t\t\tif(nameA.length > 1){\r\n\t\t\t\t\t\tif(typeof(myObj[nameA[0]]) == \"undefined\"){\r\n\t\t\t\t\t\t\tmyObj[nameA[0]]=[ ];\r\n\t\t\t\t\t\t} // if\r\n\r\n\t\t\t\t\t\tnameIndex=parseInt(nameA[1]);\r\n\t\t\t\t\t\tif(typeof(myObj[nameA[0]][nameIndex]) == \"undefined\"){\r\n\t\t\t\t\t\t\tmyObj[nameA[0]][nameIndex] = { };\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tmyObj=myObj[nameA[0]][nameIndex];\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t} // repeater support ends\r\n\r\n\t\t\t\t\tif(typeof(myObj[p]) == \"undefined\"){\r\n\t\t\t\t\t\tmyObj=undefined;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t};\r\n\t\t\t\t\tmyObj=myObj[p];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(typeof(myObj) == \"undefined\"){\r\n\t\t\t\t\treturn;\t\t// like \"continue\"\r\n\t\t\t\t}\r\n\t\t\t\tif(typeof(myObj[name]) == \"undefined\" && this.ignoreNullValues){\r\n\t\t\t\t\treturn;\t\t// like \"continue\"\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// TODO: widget values (just call set('value', ...) on the widget)\r\n\r\n\t\t\t\t// TODO: maybe should call dojo.getNodeProp() instead\r\n\t\t\t\tswitch(element.type){\r\n\t\t\t\t\tcase \"checkbox\":\r\n\t\t\t\t\t\telement.checked = (name in myObj) &&\r\n\t\t\t\t\t\t\tarray.some(myObj[name], function(val){ return val == element.value; });\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"radio\":\r\n\t\t\t\t\t\telement.checked = (name in myObj) && myObj[name] == element.value;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"select-multiple\":\r\n\t\t\t\t\t\telement.selectedIndex=-1;\r\n\t\t\t\t\t\tarray.forEach(element.options, function(option){\r\n\t\t\t\t\t\t\toption.selected = array.some(myObj[name], function(val){ return option.value == val; });\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"select-one\":\r\n\t\t\t\t\t\telement.selectedIndex=\"0\";\r\n\t\t\t\t\t\tarray.forEach(element.options, function(option){\r\n\t\t\t\t\t\t\toption.selected = option.value == myObj[name];\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"hidden\":\r\n\t\t\t\t\tcase \"text\":\r\n\t\t\t\t\tcase \"textarea\":\r\n\t\t\t\t\tcase \"password\":\r\n\t\t\t\t\t\telement.value = myObj[name] || \"\";\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\t*/\r\n\r\n\t\t\t// Note: no need to call this._set(\"value\", ...) as the child updates will trigger onChange events\r\n\t\t\t// which I am monitoring.\r\n\t\t},\r\n\r\n\t\tgetValues: function(){\r\n\t\t\tkernel.deprecated(this.declaredClass+\"::getValues() is deprecated. Use get('value') instead.\", \"\", \"2.0\");\r\n\t\t\treturn this.get('value');\r\n\t\t},\r\n\t\t_getValueAttr: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns Object representing form values.   See description of `value` for details.\r\n\t\t\t// description:\r\n\r\n\t\t\t// The value is updated into this.value every time a child has an onChange event,\r\n\t\t\t// so in the common case this function could just return this.value.   However,\r\n\t\t\t// that wouldn't work when:\r\n\t\t\t//\r\n\t\t\t// 1. User presses return key to submit a form.  That doesn't fire an onchange event,\r\n\t\t\t// and even if it did it would come too late due to the defer(...) in _handleOnChange()\r\n\t\t\t//\r\n\t\t\t// 2. app for some reason calls this.get(\"value\") while the user is typing into a\r\n\t\t\t// form field.   Not sure if that case needs to be supported or not.\r\n\r\n\t\t\t// get widget values\r\n\t\t\tvar obj = { };\r\n\t\t\tarray.forEach(this._getDescendantFormWidgets(), function(widget){\r\n\t\t\t\tvar name = widget.name;\r\n\t\t\t\tif(!name || widget.disabled){ return; }\r\n\r\n\t\t\t\t// Single value widget (checkbox, radio, or plain <input> type widget)\r\n\t\t\t\tvar value = widget.get('value');\r\n\r\n\t\t\t\t// Store widget's value(s) as a scalar, except for checkboxes which are automatically arrays\r\n\t\t\t\tif(typeof widget.checked == 'boolean'){\r\n\t\t\t\t\tif(/Radio/.test(widget.declaredClass)){\r\n\t\t\t\t\t\t// radio button\r\n\t\t\t\t\t\tif(value !== false){\r\n\t\t\t\t\t\t\tlang.setObject(name, value, obj);\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t// give radio widgets a default of null\r\n\t\t\t\t\t\t\tvalue = lang.getObject(name, false, obj);\r\n\t\t\t\t\t\t\tif(value === undefined){\r\n\t\t\t\t\t\t\t\tlang.setObject(name, null, obj);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\t// checkbox/toggle button\r\n\t\t\t\t\t\tvar ary=lang.getObject(name, false, obj);\r\n\t\t\t\t\t\tif(!ary){\r\n\t\t\t\t\t\t\tary=[];\r\n\t\t\t\t\t\t\tlang.setObject(name, ary, obj);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(value !== false){\r\n\t\t\t\t\t\t\tary.push(value);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tvar prev=lang.getObject(name, false, obj);\r\n\t\t\t\t\tif(typeof prev != \"undefined\"){\r\n\t\t\t\t\t\tif(lang.isArray(prev)){\r\n\t\t\t\t\t\t\tprev.push(value);\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\tlang.setObject(name, [prev, value], obj);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\t// unique name\r\n\t\t\t\t\t\tlang.setObject(name, value, obj);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\t/***\r\n\t\t\t * code for plain input boxes (see also domForm.formToObject, can we use that instead of this code?\r\n\t\t\t * but it doesn't understand [] notation, presumably)\r\n\t\t\tvar obj = { };\r\n\t\t\tarray.forEach(this.containerNode.elements, function(elm){\r\n\t\t\t\tif(!elm.name)\t{\r\n\t\t\t\t\treturn;\t\t// like \"continue\"\r\n\t\t\t\t}\r\n\t\t\t\tvar namePath = elm.name.split(\".\");\r\n\t\t\t\tvar myObj=obj;\r\n\t\t\t\tvar name=namePath[namePath.length-1];\r\n\t\t\t\tfor(var j=1,len2=namePath.length;j<len2;++j){\r\n\t\t\t\t\tvar nameIndex = null;\r\n\t\t\t\t\tvar p=namePath[j - 1];\r\n\t\t\t\t\tvar nameA=p.split(\"[\");\r\n\t\t\t\t\tif(nameA.length > 1){\r\n\t\t\t\t\t\tif(typeof(myObj[nameA[0]]) == \"undefined\"){\r\n\t\t\t\t\t\t\tmyObj[nameA[0]]=[ ];\r\n\t\t\t\t\t\t} // if\r\n\t\t\t\t\t\tnameIndex=parseInt(nameA[1]);\r\n\t\t\t\t\t\tif(typeof(myObj[nameA[0]][nameIndex]) == \"undefined\"){\r\n\t\t\t\t\t\t\tmyObj[nameA[0]][nameIndex] = { };\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}else if(typeof(myObj[nameA[0]]) == \"undefined\"){\r\n\t\t\t\t\t\tmyObj[nameA[0]] = { }\r\n\t\t\t\t\t} // if\r\n\r\n\t\t\t\t\tif(nameA.length == 1){\r\n\t\t\t\t\t\tmyObj=myObj[nameA[0]];\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tmyObj=myObj[nameA[0]][nameIndex];\r\n\t\t\t\t\t} // if\r\n\t\t\t\t} // for\r\n\r\n\t\t\t\tif((elm.type != \"select-multiple\" && elm.type != \"checkbox\" && elm.type != \"radio\") || (elm.type == \"radio\" && elm.checked)){\r\n\t\t\t\t\tif(name == name.split(\"[\")[0]){\r\n\t\t\t\t\t\tmyObj[name]=elm.value;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\t// can not set value when there is no name\r\n\t\t\t\t\t}\r\n\t\t\t\t}else if(elm.type == \"checkbox\" && elm.checked){\r\n\t\t\t\t\tif(typeof(myObj[name]) == 'undefined'){\r\n\t\t\t\t\t\tmyObj[name]=[ ];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tmyObj[name].push(elm.value);\r\n\t\t\t\t}else if(elm.type == \"select-multiple\"){\r\n\t\t\t\t\tif(typeof(myObj[name]) == 'undefined'){\r\n\t\t\t\t\t\tmyObj[name]=[ ];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor(var jdx=0,len3=elm.options.length; jdx<len3; ++jdx){\r\n\t\t\t\t\t\tif(elm.options[jdx].selected){\r\n\t\t\t\t\t\t\tmyObj[name].push(elm.options[jdx].value);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} // if\r\n\t\t\t\tname=undefined;\r\n\t\t\t}); // forEach\r\n\t\t\t***/\r\n\t\t\treturn obj;\r\n\t\t},\r\n\r\n\t\tisValid: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns true if all of the widgets are valid.\r\n\t\t\t//\t\tDeprecated, will be removed in 2.0.  Use get(\"state\") instead.\r\n\r\n\t\t\treturn this.state == \"\";\r\n\t\t},\r\n\r\n\t\tonValidStateChange: function(/*Boolean*/ /*===== isValid =====*/){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tStub function to connect to if you want to do something\r\n\t\t\t//\t\t(like disable/enable a submit button) when the valid\r\n\t\t\t//\t\tstate changes on the form as a whole.\r\n\t\t\t//\r\n\t\t\t//\t\tDeprecated.  Will be removed in 2.0.  Use watch(\"state\", ...) instead.\r\n\t\t},\r\n\r\n\t\t_getState: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCompute what this.state should be based on state of children\r\n\t\t\tvar states = array.map(this._descendants, function(w){\r\n\t\t\t\treturn w.get(\"state\") || \"\";\r\n\t\t\t});\r\n\r\n\t\t\treturn array.indexOf(states, \"Error\") >= 0 ? \"Error\" :\r\n\t\t\t\tarray.indexOf(states, \"Incomplete\") >= 0 ? \"Incomplete\" : \"\";\r\n\t\t},\r\n\r\n\t\tdisconnectChildren: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tDeprecated method.   Applications no longer need to call this.   Remove for 2.0.\r\n\t\t},\r\n\r\n\t\tconnectChildren: function(/*Boolean*/ inStartup){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tYou can call this function directly, ex. in the event that you\r\n\t\t\t//\t\tprogrammatically add a widget to the form *after* the form has been\r\n\t\t\t//\t\tinitialized.\r\n\r\n\t\t\t// TODO: rename for 2.0\r\n\r\n\t\t\tthis._descendants = this._getDescendantFormWidgets();\r\n\r\n\t\t\t// To get notifications from children they need to be started.   Children didn't used to need to be started,\r\n\t\t\t// so for back-compat, start them here\r\n\t\t\tarray.forEach(this._descendants, function(child){\r\n\t\t\t\tif(!child._started){ child.startup(); }\r\n\t\t\t});\r\n\r\n\t\t\tif(!inStartup){\r\n\t\t\t\tthis._onChildChange();\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_onChildChange: function(/*String*/ attr){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCalled when child's value or disabled state changes\r\n\r\n\t\t\t// The unit tests expect state update to be synchronous, so update it immediately.\r\n\t\t\tif(!attr || attr == \"state\" || attr == \"disabled\"){\r\n\t\t\t\tthis._set(\"state\", this._getState());\r\n\t\t\t}\r\n\r\n\t\t\t// Use defer() to collapse value changes in multiple children into a single\r\n\t\t\t// update to my value.   Multiple updates will occur on:\r\n\t\t\t//\t1. Form.set()\r\n\t\t\t//\t2. Form.reset()\r\n\t\t\t//\t3. user selecting a radio button (which will de-select another radio button,\r\n\t\t\t//\t\t causing two onChange events)\r\n\t\t\tif(!attr || attr == \"value\" || attr == \"disabled\" || attr == \"checked\"){\r\n\t\t\t\tif(this._onChangeDelayTimer){\r\n\t\t\t\t\tthis._onChangeDelayTimer.remove();\r\n\t\t\t\t}\r\n\t\t\t\tthis._onChangeDelayTimer = this.defer(function(){\r\n\t\t\t\t\tdelete this._onChangeDelayTimer;\r\n\t\t\t\t\tthis._set(\"value\", this.get(\"value\"));\r\n\t\t\t\t}, 10);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tstartup: function(){\r\n\t\t\tthis.inherited(arguments);\r\n\r\n\t\t\t// Set initial this.value and this.state.   Don't emit watch() notifications.\r\n\t\t\tthis._descendants = this._getDescendantFormWidgets();\r\n\t\t\tthis.value = this.get(\"value\");\r\n\t\t\tthis.state = this._getState();\r\n\r\n\t\t\t// Initialize value and valid/invalid state tracking.\r\n\t\t\tvar self = this;\r\n\t\t\tthis.own(\r\n\t\t\t\ton(\r\n\t\t\t\t\tthis.containerNode,\r\n\t\t\t\t\t\"attrmodified-state, attrmodified-disabled, attrmodified-value, attrmodified-checked\",\r\n\t\t\t\t\tfunction(evt){\r\n\t\t\t\t\t\tif(evt.target == self.domNode){\r\n\t\t\t\t\t\t\treturn;\t// ignore events that I fire on myself because my children changed\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tself._onChildChange(evt.type.replace(\"attrmodified-\", \"\"));\r\n\t\t\t\t\t}\r\n\t\t\t\t)\r\n\t\t\t);\r\n\r\n\t\t\t// Make state change call onValidStateChange(), will be removed in 2.0\r\n\t\t\tthis.watch(\"state\", function(attr, oldVal, newVal){ this.onValidStateChange(newVal == \"\"); });\r\n\t\t},\r\n\r\n\t\tdestroy: function(){\r\n\t\t\tthis.inherited(arguments);\r\n\t\t}\r\n\r\n\t});\r\n});\r\n"]}