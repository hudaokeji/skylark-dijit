{"version":3,"sources":["form/_FormWidgetMixin.js"],"names":["define","array","declare","domAttr","domStyle","lang","mouse","on","has","winUtils","a11y","name","alt","value","type","aria-label","tabIndex","_setTabIndexAttr","disabled","intermediateChanges","scrollOnFocus","_setIdAttr","_setDisabledAttr","this","_set","set","focusNode","valueNode","setAttribute","attachPointNames","attributeMap","forEach","isArray","attachPointName","node","hasDefaultTabStop","removeAttribute","_onFocus","by","isFocusable","focusHandle","own","mouseUpHandle","remove","event","ownerDocumentBody","hitch","evt","focused","defer","focus","scrollIntoView","domNode","inherited","arguments","get","e","compare","val1","val2","isNaN","onChange","_onChangeActive","_handleOnChange","newValue","priorityChange","undefined","_lastValueReported","_resetValue","_pendingOnChange","_onChangeHandle","create","destroy"],"mappings":"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","file":"../../form/_FormWidgetMixin.js","sourcesContent":["define([\r\n\t\"dojo/_base/array\", // array.forEach\r\n\t\"dojo/_base/declare\", // declare\r\n\t\"dojo/dom-attr\", // domAttr.set\r\n\t\"dojo/dom-style\", // domStyle.get\r\n\t\"dojo/_base/lang\", // lang.hitch lang.isArray\r\n\t\"dojo/mouse\", // mouse.isLeft\r\n\t\"dojo/on\",\r\n\t\"dojo/sniff\", // has(\"webkit\")\r\n\t\"dojo/window\", // winUtils.scrollIntoView\r\n\t\"../a11y\"    // a11y.hasDefaultTabStop\r\n], function(array, declare, domAttr, domStyle, lang, mouse, on, has, winUtils, a11y){\r\n\r\n\t// module:\r\n\t//\t\tdijit/form/_FormWidgetMixin\r\n\r\n\treturn declare(\"dijit.form._FormWidgetMixin\", null, {\r\n\t\t// summary:\r\n\t\t//\t\tMixin for widgets corresponding to native HTML elements such as `<checkbox>` or `<button>`,\r\n\t\t//\t\twhich can be children of a `<form>` node or a `dijit/form/Form` widget.\r\n\t\t//\r\n\t\t// description:\r\n\t\t//\t\tRepresents a single HTML element.\r\n\t\t//\t\tAll these widgets should have these attributes just like native HTML input elements.\r\n\t\t//\t\tYou can set them during widget construction or afterwards, via `dijit/_WidgetBase.set()`.\r\n\t\t//\r\n\t\t//\t\tThey also share some common methods.\r\n\r\n\t\t// name: [const] String\r\n\t\t//\t\tName used when submitting form; same as \"name\" attribute or plain HTML elements\r\n\t\tname: \"\",\r\n\r\n\t\t// alt: String\r\n\t\t//\t\tCorresponds to the native HTML `<input>` element's attribute.\r\n\t\talt: \"\",\r\n\r\n\t\t// value: String\r\n\t\t//\t\tCorresponds to the native HTML `<input>` element's attribute.\r\n\t\tvalue: \"\",\r\n\r\n\t\t// type: [const] String\r\n\t\t//\t\tCorresponds to the native HTML `<input>` element's attribute.\r\n\t\ttype: \"text\",\r\n\r\n\t\t// type: String\r\n\t\t//\t\tApply aria-label in markup to the widget's focusNode\r\n\t\t\"aria-label\": \"focusNode\",\r\n\r\n\t\t// tabIndex: String\r\n\t\t//\t\tOrder fields are traversed when user hits the tab key\r\n\t\ttabIndex: \"0\",\r\n\t\t_setTabIndexAttr: \"focusNode\", // force copy even when tabIndex default value, needed since Button is <span>\r\n\r\n\t\t// disabled: Boolean\r\n\t\t//\t\tShould this widget respond to user input?\r\n\t\t//\t\tIn markup, this is specified as \"disabled='disabled'\", or just \"disabled\".\r\n\t\tdisabled: false,\r\n\r\n\t\t// intermediateChanges: Boolean\r\n\t\t//\t\tFires onChange for each value change or only on demand\r\n\t\tintermediateChanges: false,\r\n\r\n\t\t// scrollOnFocus: Boolean\r\n\t\t//\t\tOn focus, should this widget scroll into view?\r\n\t\tscrollOnFocus: true,\r\n\r\n\t\t// Override _WidgetBase mapping id to this.domNode, needs to be on focusNode so <label> etc.\r\n\t\t// works with screen reader\r\n\t\t_setIdAttr: \"focusNode\",\r\n\r\n\t\t_setDisabledAttr: function(/*Boolean*/ value){\r\n\t\t\tthis._set(\"disabled\", value);\r\n\t\t\tdomAttr.set(this.focusNode, 'disabled', value);\r\n\t\t\tif(this.valueNode){\r\n\t\t\t\tdomAttr.set(this.valueNode, 'disabled', value);\r\n\t\t\t}\r\n\t\t\tthis.focusNode.setAttribute(\"aria-disabled\", value ? \"true\" : \"false\");\r\n\r\n\t\t\tif(value){\r\n\t\t\t\t// reset these, because after the domNode is disabled, we can no longer receive\r\n\t\t\t\t// mouse related events, see #4200\r\n\t\t\t\tthis._set(\"hovering\", false);\r\n\t\t\t\tthis._set(\"active\", false);\r\n\r\n\t\t\t\t// clear tab stop(s) on this widget's focusable node(s)  (ComboBox has two focusable nodes)\r\n\t\t\t\tvar attachPointNames = \"tabIndex\" in this.attributeMap ? this.attributeMap.tabIndex :\r\n\t\t\t\t\t(\"_setTabIndexAttr\" in this) ? this._setTabIndexAttr : \"focusNode\";\r\n\t\t\t\tarray.forEach(lang.isArray(attachPointNames) ? attachPointNames : [attachPointNames], function(attachPointName){\r\n\t\t\t\t\tvar node = this[attachPointName];\r\n\t\t\t\t\t// complex code because tabIndex=-1 on a <div> doesn't work on FF\r\n\t\t\t\t\tif(has(\"webkit\") || a11y.hasDefaultTabStop(node)){    // see #11064 about webkit bug\r\n\t\t\t\t\t\tnode.setAttribute('tabIndex', \"-1\");\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tnode.removeAttribute('tabIndex');\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this);\r\n\t\t\t}else{\r\n\t\t\t\tif(this.tabIndex != \"\"){\r\n\t\t\t\t\tthis.set('tabIndex', this.tabIndex);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_onFocus: function(/*String*/ by){\r\n\t\t\t// If user clicks on the widget, even if the mouse is released outside of it,\r\n\t\t\t// this widget's focusNode should get focus (to mimic native browser behavior).\r\n\t\t\t// Browsers often need help to make sure the focus via mouse actually gets to the focusNode.\r\n\t\t\t// TODO: consider removing all of this for 2.0 or sooner, see #16622 etc.\r\n\t\t\tif(by == \"mouse\" && this.isFocusable()){\r\n\t\t\t\t// IE exhibits strange scrolling behavior when refocusing a node so only do it when !focused.\r\n\t\t\t\tvar focusHandle = this.own(on(this.focusNode, \"focus\", function(){\r\n\t\t\t\t\tmouseUpHandle.remove();\r\n\t\t\t\t\tfocusHandle.remove();\r\n\t\t\t\t}))[0];\r\n\t\t\t\t// Set a global event to handle mouseup, so it fires properly\r\n\t\t\t\t// even if the cursor leaves this.domNode before the mouse up event.\r\n\t\t\t\tvar event = has(\"pointer-events\") ? \"pointerup\" : has(\"MSPointer\") ? \"MSPointerUp\" :\r\n\t\t\t\t\thas(\"touch-events\") ? \"touchend, mouseup\" :\t\t// seems like overkill but see #16622, #16725\r\n\t\t\t\t\t\"mouseup\";\r\n\t\t\t\tvar mouseUpHandle = this.own(on(this.ownerDocumentBody, event, lang.hitch(this, function(evt){\r\n\t\t\t\t\tmouseUpHandle.remove();\r\n\t\t\t\t\tfocusHandle.remove();\r\n\t\t\t\t\t// if here, then the mousedown did not focus the focusNode as the default action\r\n\t\t\t\t\tif(this.focused){\r\n\t\t\t\t\t\tif(evt.type == \"touchend\"){\r\n\t\t\t\t\t\t\tthis.defer(\"focus\"); // native focus hasn't occurred yet\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\tthis.focus(); // native focus already occurred on mousedown\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})))[0];\r\n\t\t\t}\r\n\t\t\tif(this.scrollOnFocus){\r\n\t\t\t\tthis.defer(function(){\r\n\t\t\t\t\twinUtils.scrollIntoView(this.domNode);\r\n\t\t\t\t}); // without defer, the input caret position can change on mouse click\r\n\t\t\t}\r\n\t\t\tthis.inherited(arguments);\r\n\t\t},\r\n\r\n\t\tisFocusable: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tTells if this widget is focusable or not.  Used internally by dijit.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\t\t\treturn !this.disabled && this.focusNode && (domStyle.get(this.domNode, \"display\") != \"none\");\r\n\t\t},\r\n\r\n\t\tfocus: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tPut focus on this widget\r\n\t\t\tif(!this.disabled && this.focusNode.focus){\r\n\t\t\t\ttry{\r\n\t\t\t\t\tthis.focusNode.focus();\r\n\t\t\t\t}catch(e){\r\n\t\t\t\t}\r\n\t\t\t\t/*squelch errors from hidden nodes*/\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tcompare: function(/*anything*/ val1, /*anything*/ val2){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCompare 2 values (as returned by get('value') for this widget).\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\t\t\tif(typeof val1 == \"number\" && typeof val2 == \"number\"){\r\n\t\t\t\treturn (isNaN(val1) && isNaN(val2)) ? 0 : val1 - val2;\r\n\t\t\t}else if(val1 > val2){\r\n\t\t\t\treturn 1;\r\n\t\t\t}else if(val1 < val2){\r\n\t\t\t\treturn -1;\r\n\t\t\t}else{\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tonChange: function(/*===== newValue =====*/){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCallback when this widget's value is changed.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tcallback\r\n\t\t},\r\n\r\n\t\t// _onChangeActive: [private] Boolean\r\n\t\t//\t\tIndicates that changes to the value should call onChange() callback.\r\n\t\t//\t\tThis is false during widget initialization, to avoid calling onChange()\r\n\t\t//\t\twhen the initial value is set.\r\n\t\t_onChangeActive: false,\r\n\r\n\t\t_handleOnChange: function(/*anything*/ newValue, /*Boolean?*/ priorityChange){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCalled when the value of the widget is set.  Calls onChange() if appropriate\r\n\t\t\t// newValue:\r\n\t\t\t//\t\tthe new value\r\n\t\t\t// priorityChange:\r\n\t\t\t//\t\tFor a slider, for example, dragging the slider is priorityChange==false,\r\n\t\t\t//\t\tbut on mouse up, it's priorityChange==true.  If intermediateChanges==false,\r\n\t\t\t//\t\tonChange is only called form priorityChange=true events.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\tif(this._lastValueReported == undefined && (priorityChange === null || !this._onChangeActive)){\r\n\t\t\t\t// this block executes not for a change, but during initialization,\r\n\t\t\t\t// and is used to store away the original value (or for ToggleButton, the original checked state)\r\n\t\t\t\tthis._resetValue = this._lastValueReported = newValue;\r\n\t\t\t}\r\n\t\t\tthis._pendingOnChange = this._pendingOnChange\r\n\t\t\t\t|| (typeof newValue != typeof this._lastValueReported)\r\n\t\t\t\t|| (this.compare(newValue, this._lastValueReported) != 0);\r\n\t\t\tif((this.intermediateChanges || priorityChange || priorityChange === undefined) && this._pendingOnChange){\r\n\t\t\t\tthis._lastValueReported = newValue;\r\n\t\t\t\tthis._pendingOnChange = false;\r\n\t\t\t\tif(this._onChangeActive){\r\n\t\t\t\t\tif(this._onChangeHandle){\r\n\t\t\t\t\t\tthis._onChangeHandle.remove();\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// defer allows hidden value processing to run and\r\n\t\t\t\t\t// also the onChange handler can safely adjust focus, etc\r\n\t\t\t\t\tthis._onChangeHandle = this.defer(\r\n\t\t\t\t\t\tfunction(){\r\n\t\t\t\t\t\t\tthis._onChangeHandle = null;\r\n\t\t\t\t\t\t\tthis.onChange(newValue);\r\n\t\t\t\t\t\t}); // try to collapse multiple onChange's fired faster than can be processed\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tcreate: function(){\r\n\t\t\t// Overrides _Widget.create()\r\n\t\t\tthis.inherited(arguments);\r\n\t\t\tthis._onChangeActive = true;\r\n\t\t},\r\n\r\n\t\tdestroy: function(){\r\n\t\t\tif(this._onChangeHandle){ // destroy called before last onChange has fired\r\n\t\t\t\tthis._onChangeHandle.remove();\r\n\t\t\t\tthis.onChange(this._lastValueReported);\r\n\t\t\t}\r\n\t\t\tthis.inherited(arguments);\r\n\t\t}\r\n\t});\r\n});\r\n"]}