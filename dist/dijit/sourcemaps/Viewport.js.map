{"version":3,"sources":["Viewport.js"],"names":["define","Evented","on","domReady","has","winUtils","focusedNode","Viewport","oldBox","getBox","_rlh","window","newBox","h","w","emit","deviceXDPI","screen","setInterval","document","evt","target","getEffectiveBox","doc","box","tag","tagName","toLowerCase","readOnly","test","type","orientation","rect","getBoundingClientRect","Math","max","top","height"],"mappings":";;;;;;;AAAAA,QACC,eACA,UACA,gBACA,aACA,eACE,SAASC,EAASC,EAAIC,EAAUC,EAAKC,GAkBvC,IAEIC,EAFAC,EAAW,IAAIN,EA6DnB,OAzDAE,EAAS,WACR,IAAIK,EAASH,EAASI,SAStB,GARAF,EAASG,KAAOR,EAAGS,OAAQ,SAAU,WACpC,IAAIC,EAASP,EAASI,SACnBD,EAAOK,GAAKD,EAAOC,GAAKL,EAAOM,GAAKF,EAAOE,IAC9CN,EAASI,EACTL,EAASQ,KAAK,aAIC,GAAbX,EAAI,MAAW,CACjB,IAAIY,EAAaC,OAAOD,WACxBE,YAAY,WACRD,OAAOD,YAAcA,IACvBA,EAAaC,OAAOD,WACpBT,EAASQ,KAAK,YAEb,KAIDX,EAAI,SACNF,EAAGiB,SAAU,UAAW,SAASC,GAChCd,EAAcc,EAAIC,SAEnBnB,EAAGiB,SAAU,WAAY,SAASC,GACjCd,EAAc,UAKjBC,EAASe,gBAAkB,SAAsBC,GAKhD,IAAIC,EAAMnB,EAASI,OAAOc,GAGtBE,EAAMnB,GAAeA,EAAYoB,SAAWpB,EAAYoB,QAAQC,cACpE,GAAGvB,EAAI,QAAUE,IAAgBA,EAAYsB,WAAoB,YAAPH,GAA6B,SAAPA,GAC/E,sDAAsDI,KAAKvB,EAAYwB,OAAQ,CAI/EN,EAAIX,GAAqB,GAAfkB,aAAmC,KAAfA,YAAqB,IAAO,GAK1D,IAAIC,EAAO1B,EAAY2B,wBACvBT,EAAIX,EAAIqB,KAAKC,IAAIX,EAAIX,EAAGmB,EAAKI,IAAMJ,EAAKK,QAGzC,OAAOb,GAGDjB","file":"../Viewport.js","sourcesContent":["define([\r\n\t\"dojo/Evented\",\r\n\t\"dojo/on\",\r\n\t\"dojo/domReady\",\r\n\t\"dojo/sniff\",\t// has(\"ie\"), has(\"ios\")\r\n\t\"dojo/window\" // getBox()\r\n], function(Evented, on, domReady, has, winUtils){\r\n\r\n\t// module:\r\n\t//\t\tdijit/Viewport\r\n\r\n\t/*=====\r\n\treturn {\r\n\t\t// summary:\r\n\t\t//\t\tUtility singleton to watch for viewport resizes, avoiding duplicate notifications\r\n\t\t//\t\twhich can lead to infinite loops.\r\n\t\t// description:\r\n\t\t//\t\tUsage: Viewport.on(\"resize\", myCallback).\r\n\t\t//\r\n\t\t//\t\tmyCallback() is called without arguments in case it's _WidgetBase.resize(),\r\n\t\t//\t\twhich would interpret the argument as the size to make the widget.\r\n\t};\r\n\t=====*/\r\n\r\n\tvar Viewport = new Evented();\r\n\r\n\tvar focusedNode;\r\n\r\n\tdomReady(function(){\r\n\t\tvar oldBox = winUtils.getBox();\r\n\t\tViewport._rlh = on(window, \"resize\", function(){\r\n\t\t\tvar newBox = winUtils.getBox();\r\n\t\t\tif(oldBox.h == newBox.h && oldBox.w == newBox.w){ return; }\r\n\t\t\toldBox = newBox;\r\n\t\t\tViewport.emit(\"resize\");\r\n\t\t});\r\n\r\n\t\t// Also catch zoom changes on IE8, since they don't naturally generate resize events\r\n\t\tif(has(\"ie\") == 8){\r\n\t\t\tvar deviceXDPI = screen.deviceXDPI;\r\n\t\t\tsetInterval(function(){\r\n\t\t\t\tif(screen.deviceXDPI != deviceXDPI){\r\n\t\t\t\t\tdeviceXDPI = screen.deviceXDPI;\r\n\t\t\t\t\tViewport.emit(\"resize\");\r\n\t\t\t\t}\r\n\t\t\t}, 500);\r\n\t\t}\r\n\r\n\t\t// On iOS, keep track of the focused node so we can guess when the keyboard is/isn't being displayed.\r\n\t\tif(has(\"ios\")){\r\n\t\t\ton(document, \"focusin\", function(evt){\r\n\t\t\t\tfocusedNode = evt.target;\r\n\t\t\t});\r\n\t\t\ton(document, \"focusout\", function(evt){\r\n\t\t\t\tfocusedNode = null;\r\n\t\t\t});\r\n\t\t}\r\n\t});\r\n\r\n\tViewport.getEffectiveBox = function(/*Document*/ doc){\r\n\t\t// summary:\r\n\t\t//\t\tGet the size of the viewport, or on mobile devices, the part of the viewport not obscured by the\r\n\t\t//\t\tvirtual keyboard.\r\n\r\n\t\tvar box = winUtils.getBox(doc);\r\n\r\n\t\t// Account for iOS virtual keyboard, if it's being shown.  Unfortunately no direct way to check or measure.\r\n\t\tvar tag = focusedNode && focusedNode.tagName && focusedNode.tagName.toLowerCase();\r\n\t\tif(has(\"ios\") && focusedNode && !focusedNode.readOnly && (tag == \"textarea\" || (tag == \"input\" &&\r\n\t\t\t/^(color|email|number|password|search|tel|text|url)$/.test(focusedNode.type)))){\r\n\r\n\t\t\t// Box represents the size of the viewport.  Some of the viewport is likely covered by the keyboard.\r\n\t\t\t// Estimate height of visible viewport assuming viewport goes to bottom of screen, but is covered by keyboard.\r\n\t\t\tbox.h *= (orientation == 0 || orientation == 180 ? 0.66 : 0.40);\r\n\r\n\t\t\t// Above measurement will be inaccurate if viewport was scrolled up so far that it ends before the bottom\r\n\t\t\t// of the screen.   In this case, keyboard isn't covering as much of the viewport as we thought.\r\n\t\t\t// We know the visible size is at least the distance from the top of the viewport to the focused node.\r\n\t\t\tvar rect = focusedNode.getBoundingClientRect();\r\n\t\t\tbox.h = Math.max(box.h, rect.top + rect.height);\r\n\t\t}\r\n\r\n\t\treturn box;\r\n\t};\r\n\r\n\treturn Viewport;\r\n});\r\n"]}