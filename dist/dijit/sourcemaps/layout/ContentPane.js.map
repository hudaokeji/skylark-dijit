{"version":3,"sources":["layout/ContentPane.js"],"names":["define","kernel","lang","_Widget","_Container","_ContentPaneResizeMixin","string","html","nlsLoading","array","declare","Deferred","dom","domAttr","domConstruct","xhr","i18n","when","href","content","extractContent","parseOnLoad","parserScope","_scopeName","preventCache","preload","refreshOnShow","loadingMessage","errorMessage","isLoaded","baseClass","ioArgs","onLoadDeferred","_setTitleAttr","stopParser","template","markupFactory","params","node","ctor","self","_contentSetter","parseDeferred","isFulfilled","then","create","srcNodeRef","df","byId","ownerDocument","createDocumentFragment","firstChild","appendChild","delegate","this","inherited","arguments","postMixInProperties","messages","getLocalization","substitute","buildRendering","containerNode","domNode","removeAttribute","startup","forEach","parseResults","obj","_started","_destroyed","isFunction","_startChildren","getChildren","setHref","deprecated","set","_setHrefAttr","cancel","hitch","_set","_created","_isShown","_load","_hrefChanged","setContent","data","_setContentAttr","_setContent","_isDownloaded","_getContentAttr","innerHTML","_xhrDfd","fired","destroy","destroyRecursive","preserveDom","_beingDestroyed","_onShow","refresh","onDownloadStart","getArgs","url","handleAs","isObject","mixin","returnedHtml","hand","ioMethod","get","err","_onError","canceled","onDownloadEnd","_onLoadHandler","resolve","e","console","error","widgetId","message","_onUnloadHandler","onUnload","destroyDescendants","setter","widget","empty","_singleChild","cont","isFakeContent","_ContentSetter","onContentError","errMess","id","setterParams","cleanContent","parseContent","dir","textDir","_contentSetterParams","p","_scheduleLayout","type","consoleText","reject","errText","call","onLoad","onDownloadError"],"mappings":"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","file":"../../layout/ContentPane.js","sourcesContent":["define([\r\n\t\"dojo/_base/kernel\", // kernel.deprecated\r\n\t\"dojo/_base/lang\", // lang.mixin lang.delegate lang.hitch lang.isFunction lang.isObject\r\n\t\"../_Widget\",\r\n\t\"../_Container\",\r\n\t\"./_ContentPaneResizeMixin\",\r\n\t\"dojo/string\", // string.substitute\r\n\t\"dojo/html\", // html._ContentSetter\r\n\t\"dojo/i18n!../nls/loading\",\r\n\t\"dojo/_base/array\", // array.forEach\r\n\t\"dojo/_base/declare\", // declare\r\n\t\"dojo/_base/Deferred\", // Deferred\r\n\t\"dojo/dom\", // dom.byId\r\n\t\"dojo/dom-attr\", // domAttr.attr\r\n\t\"dojo/dom-construct\", // empty()\r\n\t\"dojo/_base/xhr\", // xhr.get\r\n\t\"dojo/i18n\", // i18n.getLocalization\r\n\t\"dojo/when\"\r\n], function(kernel, lang, _Widget, _Container, _ContentPaneResizeMixin, string, html, nlsLoading, array, declare,\r\n\t\t\tDeferred, dom, domAttr, domConstruct, xhr, i18n, when){\r\n\r\n\t// module:\r\n\t//\t\tdijit/layout/ContentPane\r\n\r\n\treturn declare(\"dijit.layout.ContentPane\", [_Widget, _Container, _ContentPaneResizeMixin], {\r\n\t\t// summary:\r\n\t\t//\t\tA widget containing an HTML fragment, specified inline\r\n\t\t//\t\tor by uri.  Fragment may include widgets.\r\n\t\t//\r\n\t\t// description:\r\n\t\t//\t\tThis widget embeds a document fragment in the page, specified\r\n\t\t//\t\teither by uri, javascript generated markup or DOM reference.\r\n\t\t//\t\tAny widgets within this content are instantiated and managed,\r\n\t\t//\t\tbut laid out according to the HTML structure.  Unlike IFRAME,\r\n\t\t//\t\tContentPane embeds a document fragment as would be found\r\n\t\t//\t\tinside the BODY tag of a full HTML document.  It should not\r\n\t\t//\t\tcontain the HTML, HEAD, or BODY tags.\r\n\t\t//\t\tFor more advanced functionality with scripts and\r\n\t\t//\t\tstylesheets, see dojox/layout/ContentPane.  This widget may be\r\n\t\t//\t\tused stand alone or as a base class for other widgets.\r\n\t\t//\t\tContentPane is useful as a child of other layout containers\r\n\t\t//\t\tsuch as BorderContainer or TabContainer, but note that those\r\n\t\t//\t\twidgets can contain any widget as a child.\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\t\tSome quick samples:\r\n\t\t//\t\tTo change the innerHTML:\r\n\t\t// |\t\tcp.set('content', '<b>new content</b>')`\r\n\t\t//\t\tOr you can send it a NodeList:\r\n\t\t// |\t\tcp.set('content', dojo.query('div [class=selected]', userSelection))\r\n\t\t//\t\tTo do an ajax update:\r\n\t\t// |\t\tcp.set('href', url)\r\n\r\n\t\t// href: String\r\n\t\t//\t\tThe href of the content that displays now.\r\n\t\t//\t\tSet this at construction if you want to load data externally when the\r\n\t\t//\t\tpane is shown.  (Set preload=true to load it immediately.)\r\n\t\t//\t\tChanging href after creation doesn't have any effect; Use set('href', ...);\r\n\t\thref: \"\",\r\n\r\n\t\t// content: String|DomNode|NodeList|dijit/_Widget\r\n\t\t//\t\tThe innerHTML of the ContentPane.\r\n\t\t//\t\tNote that the initialization parameter / argument to set(\"content\", ...)\r\n\t\t//\t\tcan be a String, DomNode, Nodelist, or _Widget.\r\n\t\tcontent: \"\",\r\n\r\n\t\t// extractContent: Boolean\r\n\t\t//\t\tExtract visible content from inside of `<body> .... </body>`.\r\n\t\t//\t\tI.e., strip `<html>` and `<head>` (and it's contents) from the href\r\n\t\textractContent: false,\r\n\r\n\t\t// parseOnLoad: Boolean\r\n\t\t//\t\tParse content and create the widgets, if any.\r\n\t\tparseOnLoad: true,\r\n\r\n\t\t// parserScope: String\r\n\t\t//\t\tFlag passed to parser.  Root for attribute names to search for.   If scopeName is dojo,\r\n\t\t//\t\twill search for data-dojo-type (or dojoType).  For backwards compatibility\r\n\t\t//\t\treasons defaults to dojo._scopeName (which is \"dojo\" except when\r\n\t\t//\t\tmulti-version support is used, when it will be something like dojo16, dojo20, etc.)\r\n\t\tparserScope: kernel._scopeName,\r\n\r\n\t\t// preventCache: Boolean\r\n\t\t//\t\tPrevent caching of data from href's by appending a timestamp to the href.\r\n\t\tpreventCache: false,\r\n\r\n\t\t// preload: Boolean\r\n\t\t//\t\tForce load of data on initialization even if pane is hidden.\r\n\t\tpreload: false,\r\n\r\n\t\t// refreshOnShow: Boolean\r\n\t\t//\t\tRefresh (re-download) content when pane goes from hidden to shown\r\n\t\trefreshOnShow: false,\r\n\r\n\t\t// loadingMessage: String\r\n\t\t//\t\tMessage that shows while downloading\r\n\t\tloadingMessage: \"<span class='dijitContentPaneLoading'><span class='dijitInline dijitIconLoading'></span>${loadingState}</span>\",\r\n\r\n\t\t// errorMessage: String\r\n\t\t//\t\tMessage that shows if an error occurs\r\n\t\terrorMessage: \"<span class='dijitContentPaneError'><span class='dijitInline dijitIconError'></span>${errorState}</span>\",\r\n\r\n\t\t// isLoaded: [readonly] Boolean\r\n\t\t//\t\tTrue if the ContentPane has data in it, either specified\r\n\t\t//\t\tduring initialization (via href or inline content), or set\r\n\t\t//\t\tvia set('content', ...) / set('href', ...)\r\n\t\t//\r\n\t\t//\t\tFalse if it doesn't have any content, or if ContentPane is\r\n\t\t//\t\tstill in the process of downloading href.\r\n\t\tisLoaded: false,\r\n\r\n\t\tbaseClass: \"dijitContentPane\",\r\n\r\n\t\t/*======\r\n\t\t // ioMethod: dojo/_base/xhr.get|dojo._base/xhr.post\r\n\t\t //\t\tFunction that should grab the content specified via href.\r\n\t\t ioMethod: dojo.xhrGet,\r\n\t\t ======*/\r\n\r\n\t\t// ioArgs: Object\r\n\t\t//\t\tParameters to pass to xhrGet() request, for example:\r\n\t\t// |\t<div data-dojo-type=\"dijit/layout/ContentPane\" data-dojo-props=\"href: './bar', ioArgs: {timeout: 500}\">\r\n\t\tioArgs: {},\r\n\r\n\t\t// onLoadDeferred: [readonly] dojo.Deferred\r\n\t\t//\t\tThis is the `dojo.Deferred` returned by set('href', ...) and refresh().\r\n\t\t//\t\tCalling onLoadDeferred.then() registers your\r\n\t\t//\t\tcallback to be called only once, when the prior set('href', ...) call or\r\n\t\t//\t\tthe initial href parameter to the constructor finishes loading.\r\n\t\t//\r\n\t\t//\t\tThis is different than an onLoad() handler which gets called any time any href\r\n\t\t//\t\tor content is loaded.\r\n\t\tonLoadDeferred: null,\r\n\r\n\t\t// Cancel _WidgetBase's _setTitleAttr because we don't want the title attribute (used to specify\r\n\t\t// tab labels) to be copied to ContentPane.domNode... otherwise a tooltip shows up over the\r\n\t\t// entire pane.\r\n\t\t_setTitleAttr: null,\r\n\r\n\t\t// Flag to parser that I'll parse my contents, so it shouldn't.\r\n\t\tstopParser: true,\r\n\r\n\t\t// template: [private] Boolean\r\n\t\t//\t\tFlag from the parser that this ContentPane is inside a template\r\n\t\t//\t\tso the contents are pre-parsed.\r\n\t\t// TODO: this declaration can be commented out in 2.0\r\n\t\ttemplate: false,\r\n\r\n\t\tmarkupFactory: function(params, node, ctor){\r\n\t\t\tvar self = new ctor(params, node);\r\n\r\n\t\t\t// If a parse has started but is waiting for modules to load, then return a Promise for when the parser\r\n\t\t\t// finishes.  Don't return a promise though for the case when content hasn't started loading because the\r\n\t\t\t// ContentPane is hidden and it has an href (ex: hidden pane of a TabContainer).   In that case we consider\r\n\t\t\t// that initialization has already finished.\r\n\t\t\treturn !self.href && self._contentSetter && self._contentSetter.parseDeferred && !self._contentSetter.parseDeferred.isFulfilled() ?\r\n\t\t\t\tself._contentSetter.parseDeferred.then(function(){\r\n\t\t\t\t\treturn self;\r\n\t\t\t\t}) : self;\r\n\t\t},\r\n\r\n\t\tcreate: function(params, srcNodeRef){\r\n\t\t\t// Convert a srcNodeRef argument into a content parameter, so that the original contents are\r\n\t\t\t// processed in the same way as contents set via set(\"content\", ...), calling the parser etc.\r\n\t\t\t// Avoid modifying original params object since that breaks NodeList instantiation, see #11906.\r\n\t\t\tif((!params || !params.template) && srcNodeRef && !(\"href\" in params) && !(\"content\" in params)){\r\n\t\t\t\tsrcNodeRef = dom.byId(srcNodeRef);\r\n\t\t\t\tvar df = srcNodeRef.ownerDocument.createDocumentFragment();\r\n\t\t\t\twhile(srcNodeRef.firstChild){\r\n\t\t\t\t\tdf.appendChild(srcNodeRef.firstChild);\r\n\t\t\t\t}\r\n\t\t\t\tparams = lang.delegate(params, {content: df});\r\n\t\t\t}\r\n\t\t\tthis.inherited(arguments, [params, srcNodeRef]);\r\n\t\t},\r\n\r\n\t\tpostMixInProperties: function(){\r\n\t\t\tthis.inherited(arguments);\r\n\t\t\tvar messages = i18n.getLocalization(\"dijit\", \"loading\", this.lang);\r\n\t\t\tthis.loadingMessage = string.substitute(this.loadingMessage, messages);\r\n\t\t\tthis.errorMessage = string.substitute(this.errorMessage, messages);\r\n\t\t},\r\n\r\n\t\tbuildRendering: function(){\r\n\t\t\tthis.inherited(arguments);\r\n\r\n\t\t\t// Since we have no template we need to set this.containerNode ourselves, to make getChildren() work.\r\n\t\t\t// For subclasses of ContentPane that do have a template, does nothing.\r\n\t\t\tif(!this.containerNode){\r\n\t\t\t\tthis.containerNode = this.domNode;\r\n\t\t\t}\r\n\r\n\t\t\t// remove the title attribute so it doesn't show up when hovering\r\n\t\t\t// over a node  (TODO: remove in 2.0, no longer needed after #11490)\r\n\t\t\tthis.domNode.removeAttribute(\"title\");\r\n\t\t},\r\n\r\n\t\tstartup: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCall startup() on all children including non _Widget ones like dojo/dnd/Source objects\r\n\r\n\t\t\t// This starts all the widgets\r\n\t\t\tthis.inherited(arguments);\r\n\r\n\t\t\t// And this catches stuff like dojo/dnd/Source\r\n\t\t\tif(this._contentSetter){\r\n\t\t\t\tarray.forEach(this._contentSetter.parseResults, function(obj){\r\n\t\t\t\t\tif(!obj._started && !obj._destroyed && lang.isFunction(obj.startup)){\r\n\t\t\t\t\t\tobj.startup();\r\n\t\t\t\t\t\tobj._started = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_startChildren: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCalled when content is loaded.   Calls startup on each child widget.   Similar to ContentPane.startup()\r\n\t\t\t//\t\titself, but avoids marking the ContentPane itself as \"restarted\" (see #15581).\r\n\r\n\t\t\t// This starts all the widgets\r\n\t\t\tarray.forEach(this.getChildren(), function(obj){\r\n\t\t\t\tif(!obj._started && !obj._destroyed && lang.isFunction(obj.startup)){\r\n\t\t\t\t\tobj.startup();\r\n\t\t\t\t\tobj._started = true;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\t// And this catches stuff like dojo/dnd/Source\r\n\t\t\tif(this._contentSetter){\r\n\t\t\t\tarray.forEach(this._contentSetter.parseResults, function(obj){\r\n\t\t\t\t\tif(!obj._started && !obj._destroyed && lang.isFunction(obj.startup)){\r\n\t\t\t\t\t\tobj.startup();\r\n\t\t\t\t\t\tobj._started = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tsetHref: function(/*String|Uri*/ href){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tDeprecated.   Use set('href', ...) instead.\r\n\t\t\tkernel.deprecated(\"dijit.layout.ContentPane.setHref() is deprecated. Use set('href', ...) instead.\", \"\", \"2.0\");\r\n\t\t\treturn this.set(\"href\", href);\r\n\t\t},\r\n\t\t_setHrefAttr: function(/*String|Uri*/ href){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tHook so set(\"href\", ...) works.\r\n\t\t\t// description:\r\n\t\t\t//\t\tReset the (external defined) content of this pane and replace with new url\r\n\t\t\t//\t\tNote: It delays the download until widget is shown if preload is false.\r\n\t\t\t// href:\r\n\t\t\t//\t\turl to the page you want to get, must be within the same domain as your mainpage\r\n\r\n\t\t\t// Cancel any in-flight requests (a set('href', ...) will cancel any in-flight set('href', ...))\r\n\t\t\tthis.cancel();\r\n\r\n\t\t\tthis.onLoadDeferred = new Deferred(lang.hitch(this, \"cancel\"));\r\n\t\t\tthis.onLoadDeferred.then(lang.hitch(this, \"onLoad\"));\r\n\r\n\t\t\tthis._set(\"href\", href);\r\n\r\n\t\t\t// _setHrefAttr() is called during creation and by the user, after creation.\r\n\t\t\t// Assuming preload == false, only in the second case do we actually load the URL;\r\n\t\t\t// otherwise it's done in startup(), and only if this widget is shown.\r\n\t\t\tif(this.preload || (this._created && this._isShown())){\r\n\t\t\t\tthis._load();\r\n\t\t\t}else{\r\n\t\t\t\t// Set flag to indicate that href needs to be loaded the next time the\r\n\t\t\t\t// ContentPane is made visible\r\n\t\t\t\tthis._hrefChanged = true;\r\n\t\t\t}\r\n\r\n\t\t\treturn this.onLoadDeferred;\t\t// Deferred\r\n\t\t},\r\n\r\n\t\tsetContent: function(/*String|DomNode|Nodelist*/data){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tDeprecated.   Use set('content', ...) instead.\r\n\t\t\tkernel.deprecated(\"dijit.layout.ContentPane.setContent() is deprecated.  Use set('content', ...) instead.\", \"\", \"2.0\");\r\n\t\t\tthis.set(\"content\", data);\r\n\t\t},\r\n\t\t_setContentAttr: function(/*String|DomNode|Nodelist*/data){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tHook to make set(\"content\", ...) work.\r\n\t\t\t//\t\tReplaces old content with data content, include style classes from old content\r\n\t\t\t// data:\r\n\t\t\t//\t\tthe new Content may be String, DomNode or NodeList\r\n\t\t\t//\r\n\t\t\t//\t\tif data is a NodeList (or an array of nodes) nodes are copied\r\n\t\t\t//\t\tso you can import nodes from another document implicitly\r\n\r\n\t\t\t// clear href so we can't run refresh and clear content\r\n\t\t\t// refresh should only work if we downloaded the content\r\n\t\t\tthis._set(\"href\", \"\");\r\n\r\n\t\t\t// Cancel any in-flight requests (a set('content', ...) will cancel any in-flight set('href', ...))\r\n\t\t\tthis.cancel();\r\n\r\n\t\t\t// Even though user is just setting content directly, still need to define an onLoadDeferred\r\n\t\t\t// because the _onLoadHandler() handler is still getting called from setContent()\r\n\t\t\tthis.onLoadDeferred = new Deferred(lang.hitch(this, \"cancel\"));\r\n\t\t\tif(this._created){\r\n\t\t\t\t// For back-compat reasons, call onLoad() for set('content', ...)\r\n\t\t\t\t// calls but not for content specified in srcNodeRef (ie: <div data-dojo-type=ContentPane>...</div>)\r\n\t\t\t\t// or as initialization parameter (ie: new ContentPane({content: ...})\r\n\t\t\t\tthis.onLoadDeferred.then(lang.hitch(this, \"onLoad\"));\r\n\t\t\t}\r\n\r\n\t\t\tthis._setContent(data || \"\");\r\n\r\n\t\t\tthis._isDownloaded = false; // mark that content is from a set('content') not a set('href')\r\n\r\n\t\t\treturn this.onLoadDeferred;\t// Deferred\r\n\t\t},\r\n\t\t_getContentAttr: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tHook to make get(\"content\") work\r\n\t\t\treturn this.containerNode.innerHTML;\r\n\t\t},\r\n\r\n\t\tcancel: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCancels an in-flight download of content\r\n\t\t\tif(this._xhrDfd && (this._xhrDfd.fired == -1)){\r\n\t\t\t\tthis._xhrDfd.cancel();\r\n\t\t\t}\r\n\t\t\tdelete this._xhrDfd; // garbage collect\r\n\r\n\t\t\tthis.onLoadDeferred = null;\r\n\t\t},\r\n\r\n\t\tdestroy: function(){\r\n\t\t\tthis.cancel();\r\n\t\t\tthis.inherited(arguments);\r\n\t\t},\r\n\r\n\t\tdestroyRecursive: function(/*Boolean*/ preserveDom){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tDestroy the ContentPane and its contents\r\n\r\n\t\t\t// if we have multiple controllers destroying us, bail after the first\r\n\t\t\tif(this._beingDestroyed){\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tthis.inherited(arguments);\r\n\t\t},\r\n\r\n\t\t_onShow: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCalled when the ContentPane is made visible\r\n\t\t\t// description:\r\n\t\t\t//\t\tFor a plain ContentPane, this is called on initialization, from startup().\r\n\t\t\t//\t\tIf the ContentPane is a hidden pane of a TabContainer etc., then it's\r\n\t\t\t//\t\tcalled whenever the pane is made visible.\r\n\t\t\t//\r\n\t\t\t//\t\tDoes necessary processing, including href download and layout/resize of\r\n\t\t\t//\t\tchild widget(s)\r\n\r\n\t\t\tthis.inherited(arguments);\r\n\r\n\t\t\tif(this.href){\r\n\t\t\t\tif(!this._xhrDfd && // if there's an href that isn't already being loaded\r\n\t\t\t\t\t(!this.isLoaded || this._hrefChanged || this.refreshOnShow)\r\n\t\t\t\t\t){\r\n\t\t\t\t\treturn this.refresh();\t// If child has an href, promise that fires when the load is complete\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\trefresh: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\t[Re]download contents of href and display\r\n\t\t\t// description:\r\n\t\t\t//\t\t1. cancels any currently in-flight requests\r\n\t\t\t//\t\t2. posts \"loading...\" message\r\n\t\t\t//\t\t3. sends XHR to download new data\r\n\r\n\t\t\t// Cancel possible prior in-flight request\r\n\t\t\tthis.cancel();\r\n\r\n\t\t\tthis.onLoadDeferred = new Deferred(lang.hitch(this, \"cancel\"));\r\n\t\t\tthis.onLoadDeferred.then(lang.hitch(this, \"onLoad\"));\r\n\t\t\tthis._load();\r\n\t\t\treturn this.onLoadDeferred;\t\t// If child has an href, promise that fires when refresh is complete\r\n\t\t},\r\n\r\n\t\t_load: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tLoad/reload the href specified in this.href\r\n\r\n\t\t\t// display loading message\r\n\t\t\tthis._setContent(this.onDownloadStart(), true);\r\n\r\n\t\t\tvar self = this;\r\n\t\t\tvar getArgs = {\r\n\t\t\t\tpreventCache: (this.preventCache || this.refreshOnShow),\r\n\t\t\t\turl: this.href,\r\n\t\t\t\thandleAs: \"text\"\r\n\t\t\t};\r\n\t\t\tif(lang.isObject(this.ioArgs)){\r\n\t\t\t\tlang.mixin(getArgs, this.ioArgs);\r\n\t\t\t}\r\n\r\n\t\t\tvar hand = (this._xhrDfd = (this.ioMethod || xhr.get)(getArgs)),\r\n\t\t\t\treturnedHtml;\r\n\r\n\t\t\thand.then(\r\n\t\t\t\tfunction(html){\r\n\t\t\t\t\treturnedHtml = html;\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tself._isDownloaded = true;\r\n\t\t\t\t\t\treturn self._setContent(html, false);\r\n\t\t\t\t\t}catch(err){\r\n\t\t\t\t\t\tself._onError('Content', err); // onContentError\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\tfunction(err){\r\n\t\t\t\t\tif(!hand.canceled){\r\n\t\t\t\t\t\t// show error message in the pane\r\n\t\t\t\t\t\tself._onError('Download', err); // onDownloadError\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdelete self._xhrDfd;\r\n\t\t\t\t\treturn err;\r\n\t\t\t\t}\r\n\t\t\t).then(function(){\r\n\t\t\t\t\tself.onDownloadEnd();\r\n\t\t\t\t\tdelete self._xhrDfd;\r\n\t\t\t\t\treturn returnedHtml;\r\n\t\t\t\t});\r\n\r\n\t\t\t// Remove flag saying that a load is needed\r\n\t\t\tdelete this._hrefChanged;\r\n\t\t},\r\n\r\n\t\t_onLoadHandler: function(data){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tThis is called whenever new content is being loaded\r\n\t\t\tthis._set(\"isLoaded\", true);\r\n\t\t\ttry{\r\n\t\t\t\tthis.onLoadDeferred.resolve(data);\r\n\t\t\t}catch(e){\r\n\t\t\t\tconsole.error('Error ' + this.widgetId + ' running custom onLoad code: ' + e.message);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_onUnloadHandler: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tThis is called whenever the content is being unloaded\r\n\t\t\tthis._set(\"isLoaded\", false);\r\n\t\t\ttry{\r\n\t\t\t\tthis.onUnload();\r\n\t\t\t}catch(e){\r\n\t\t\t\tconsole.error('Error ' + this.widgetId + ' running custom onUnload code: ' + e.message);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tdestroyDescendants: function(/*Boolean*/ preserveDom){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tDestroy all the widgets inside the ContentPane and empty containerNode\r\n\r\n\t\t\t// Make sure we call onUnload (but only when the ContentPane has real content)\r\n\t\t\tif(this.isLoaded){\r\n\t\t\t\tthis._onUnloadHandler();\r\n\t\t\t}\r\n\r\n\t\t\t// Even if this.isLoaded == false there might still be a \"Loading...\" message\r\n\t\t\t// to erase, so continue...\r\n\r\n\t\t\t// For historical reasons we need to delete all widgets under this.containerNode,\r\n\t\t\t// even ones that the user has created manually.\r\n\t\t\tvar setter = this._contentSetter;\r\n\t\t\tarray.forEach(this.getChildren(), function(widget){\r\n\t\t\t\tif(widget.destroyRecursive){\r\n\t\t\t\t\t// All widgets will hit this branch\r\n\t\t\t\t\twidget.destroyRecursive(preserveDom);\r\n\t\t\t\t}else if(widget.destroy){\r\n\t\t\t\t\t// Things like dojo/dnd/Source have destroy(), not destroyRecursive()\r\n\t\t\t\t\twidget.destroy(preserveDom);\r\n\t\t\t\t}\r\n\t\t\t\twidget._destroyed = true;\r\n\t\t\t});\r\n\t\t\tif(setter){\r\n\t\t\t\t// Most of the widgets in setter.parseResults have already been destroyed, but\r\n\t\t\t\t// things like Menu that have been moved to <body> haven't yet\r\n\t\t\t\tarray.forEach(setter.parseResults, function(widget){\r\n\t\t\t\t\tif(!widget._destroyed){\r\n\t\t\t\t\t\tif(widget.destroyRecursive){\r\n\t\t\t\t\t\t\t// All widgets will hit this branch\r\n\t\t\t\t\t\t\twidget.destroyRecursive(preserveDom);\r\n\t\t\t\t\t\t}else if(widget.destroy){\r\n\t\t\t\t\t\t\t// Things like dojo/dnd/Source have destroy(), not destroyRecursive()\r\n\t\t\t\t\t\t\twidget.destroy(preserveDom);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\twidget._destroyed = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\tdelete setter.parseResults;\r\n\t\t\t}\r\n\r\n\t\t\t// And then clear away all the DOM nodes\r\n\t\t\tif(!preserveDom){\r\n\t\t\t\tdomConstruct.empty(this.containerNode);\r\n\t\t\t}\r\n\r\n\t\t\t// Delete any state information we have about current contents\r\n\t\t\tdelete this._singleChild;\r\n\t\t},\r\n\r\n\t\t_setContent: function(/*String|DocumentFragment*/ cont, /*Boolean*/ isFakeContent){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tInsert the content into the container node\r\n\t\t\t// returns:\r\n\t\t\t//\t\tReturns a Deferred promise that is resolved when the content is parsed.\r\n\r\n\t\t\t// first get rid of child widgets\r\n\t\t\tthis.destroyDescendants();\r\n\r\n\t\t\t// html.set will take care of the rest of the details\r\n\t\t\t// we provide an override for the error handling to ensure the widget gets the errors\r\n\t\t\t// configure the setter instance with only the relevant widget instance properties\r\n\t\t\t// NOTE: unless we hook into attr, or provide property setters for each property,\r\n\t\t\t// we need to re-configure the ContentSetter with each use\r\n\t\t\tvar setter = this._contentSetter;\r\n\t\t\tif(!(setter && setter instanceof html._ContentSetter)){\r\n\t\t\t\tsetter = this._contentSetter = new html._ContentSetter({\r\n\t\t\t\t\tnode: this.containerNode,\r\n\t\t\t\t\t_onError: lang.hitch(this, this._onError),\r\n\t\t\t\t\tonContentError: lang.hitch(this, function(e){\r\n\t\t\t\t\t\t// fires if a domfault occurs when we are appending this.errorMessage\r\n\t\t\t\t\t\t// like for instance if domNode is a UL and we try append a DIV\r\n\t\t\t\t\t\tvar errMess = this.onContentError(e);\r\n\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\tthis.containerNode.innerHTML = errMess;\r\n\t\t\t\t\t\t}catch(e){\r\n\t\t\t\t\t\t\tconsole.error('Fatal ' + this.id + ' could not change content due to ' + e.message, e);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})/*,\r\n\t\t\t\t\t _onError */\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tvar setterParams = lang.mixin({\r\n\t\t\t\tcleanContent: this.cleanContent,\r\n\t\t\t\textractContent: this.extractContent,\r\n\t\t\t\tparseContent: !cont.domNode && this.parseOnLoad,\r\n\t\t\t\tparserScope: this.parserScope,\r\n\t\t\t\tstartup: false,\r\n\t\t\t\tdir: this.dir,\r\n\t\t\t\tlang: this.lang,\r\n\t\t\t\ttextDir: this.textDir\r\n\t\t\t}, this._contentSetterParams || {});\r\n\r\n\t\t\tvar p = setter.set((lang.isObject(cont) && cont.domNode) ? cont.domNode : cont, setterParams);\r\n\r\n\t\t\t// dojox/layout/html/_base::_ContentSetter.set() returns a Promise that indicates when everything is completed.\r\n\t\t\t// dojo/html::_ContentSetter.set() currently returns the DOMNode, but that will be changed for 2.0.\r\n\t\t\t// So, if set() returns a promise then use it, otherwise fallback to waiting on setter.parseDeferred\r\n\t\t\tvar self = this;\r\n\t\t\treturn when(p && p.then ? p : setter.parseDeferred, function(){\r\n\t\t\t\t// setter params must be pulled afresh from the ContentPane each time\r\n\t\t\t\tdelete self._contentSetterParams;\r\n\r\n\t\t\t\tif(!isFakeContent){\r\n\t\t\t\t\tif(self._started){\r\n\t\t\t\t\t\t// Startup each top level child widget (and they will start their children, recursively)\r\n\t\t\t\t\t\tself._startChildren();\r\n\r\n\t\t\t\t\t\t// Call resize() on each of my child layout widgets,\r\n\t\t\t\t\t\t// or resize() on my single child layout widget...\r\n\t\t\t\t\t\t// either now (if I'm currently visible) or when I become visible\r\n\t\t\t\t\t\tself._scheduleLayout();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tself._onLoadHandler(cont);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t_onError: function(type, err, consoleText){\r\n\t\t\tthis.onLoadDeferred.reject(err);\r\n\r\n\t\t\t// shows user the string that is returned by on[type]Error\r\n\t\t\t// override on[type]Error and return your own string to customize\r\n\t\t\tvar errText = this['on' + type + 'Error'].call(this, err);\r\n\t\t\tif(consoleText){\r\n\t\t\t\tconsole.error(consoleText, err);\r\n\t\t\t}else if(errText){// a empty string won't change current content\r\n\t\t\t\tthis._setContent(errText, true);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t// EVENT's, should be overide-able\r\n\t\tonLoad: function(/*===== data =====*/){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tEvent hook, is called after everything is loaded and widgetified\r\n\t\t\t// tags:\r\n\t\t\t//\t\tcallback\r\n\t\t},\r\n\r\n\t\tonUnload: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tEvent hook, is called before old content is cleared\r\n\t\t\t// tags:\r\n\t\t\t//\t\tcallback\r\n\t\t},\r\n\r\n\t\tonDownloadStart: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCalled before download starts.\r\n\t\t\t// description:\r\n\t\t\t//\t\tThe string returned by this function will be the html\r\n\t\t\t//\t\tthat tells the user we are loading something.\r\n\t\t\t//\t\tOverride with your own function if you want to change text.\r\n\t\t\t// tags:\r\n\t\t\t//\t\textension\r\n\t\t\treturn this.loadingMessage;\r\n\t\t},\r\n\r\n\t\tonContentError: function(/*Error*/ /*===== error =====*/){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCalled on DOM faults, require faults etc. in content.\r\n\t\t\t//\r\n\t\t\t//\t\tIn order to display an error message in the pane, return\r\n\t\t\t//\t\tthe error message from this method, as an HTML string.\r\n\t\t\t//\r\n\t\t\t//\t\tBy default (if this method is not overriden), it returns\r\n\t\t\t//\t\tnothing, so the error message is just printed to the console.\r\n\t\t\t// tags:\r\n\t\t\t//\t\textension\r\n\t\t},\r\n\r\n\t\tonDownloadError: function(/*Error*/ /*===== error =====*/){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCalled when download error occurs.\r\n\t\t\t//\r\n\t\t\t//\t\tIn order to display an error message in the pane, return\r\n\t\t\t//\t\tthe error message from this method, as an HTML string.\r\n\t\t\t//\r\n\t\t\t//\t\tDefault behavior (if this method is not overriden) is to display\r\n\t\t\t//\t\tthe error message inside the pane.\r\n\t\t\t// tags:\r\n\t\t\t//\t\textension\r\n\t\t\treturn this.errorMessage;\r\n\t\t},\r\n\r\n\t\tonDownloadEnd: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCalled when download is finished.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tcallback\r\n\t\t}\r\n\t});\r\n});\r\n"]}