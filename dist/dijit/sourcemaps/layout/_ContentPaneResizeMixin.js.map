{"version":3,"sources":["layout/_ContentPaneResizeMixin.js"],"names":["define","array","declare","domClass","domGeometry","domStyle","lang","query","registry","Viewport","layoutUtils","doLayout","isLayoutContainer","startup","this","_started","parent","getParent","_childOfLayoutWidget","_needLayout","inherited","arguments","_isShown","_onShow","own","on","hitch","_checkIfSingleChild","candidateWidgets","otherVisibleNodes","containerNode","some","node","widget","byNode","resize","push","test","nodeName","offsetHeight","_singleChild","length","toggle","baseClass","changeSize","resultSize","_resizeCalled","_scheduleLayout","_layout","_changeSize","_resultSize","_wasShown","open","setMarginBox","domNode","cn","mb","mixin","getMarginBox","_contentBox","marginBox2contentBox","getContentBox","_layoutChildren","cb","w","h","children","getChildren","i","parentNode","style","display","visibility","contains"],"mappings":"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","file":"../../layout/_ContentPaneResizeMixin.js","sourcesContent":["define([\r\n\t\"dojo/_base/array\", // array.filter array.forEach\r\n\t\"dojo/_base/declare\", // declare\r\n\t\"dojo/dom-class\", // domClass.contains domClass.toggle\r\n\t\"dojo/dom-geometry\", // domGeometry.contentBox domGeometry.marginBox\r\n\t\"dojo/dom-style\",\r\n\t\"dojo/_base/lang\", // lang.mixin\r\n\t\"dojo/query\", // query\r\n\t\"../registry\", // registry.byId\r\n\t\"../Viewport\",\r\n\t\"./utils\" // marginBox2contextBox\r\n], function(array, declare, domClass, domGeometry, domStyle, lang, query,\r\n\t\t\tregistry, Viewport, layoutUtils){\r\n\r\n\t// module:\r\n\t//\t\tdijit/layout/_ContentPaneResizeMixin\r\n\r\n\treturn declare(\"dijit.layout._ContentPaneResizeMixin\", null, {\r\n\t\t// summary:\r\n\t\t//\t\tResize() functionality of ContentPane.   If there's a single layout widget\r\n\t\t//\t\tchild then it will call resize() with the same dimensions as the ContentPane.\r\n\t\t//\t\tOtherwise just calls resize on each child.\r\n\t\t//\r\n\t\t//\t\tAlso implements basic startup() functionality, where starting the parent\r\n\t\t//\t\twill start the children\r\n\r\n\t\t// doLayout: Boolean\r\n\t\t//\t\t- false - don't adjust size of children\r\n\t\t//\t\t- true - if there is a single visible child widget, set it's size to however big the ContentPane is\r\n\t\tdoLayout: true,\r\n\r\n\t\t// isLayoutContainer: [protected] Boolean\r\n\t\t//\t\tIndicates that this widget will call resize() on it's child widgets\r\n\t\t//\t\twhen they become visible.\r\n\t\tisLayoutContainer: true,\r\n\r\n\t\tstartup: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSee `dijit/layout/_LayoutWidget.startup()` for description.\r\n\t\t\t//\t\tAlthough ContentPane doesn't extend _LayoutWidget, it does implement\r\n\t\t\t//\t\tthe same API.\r\n\r\n\t\t\tif(this._started){\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tvar parent = this.getParent();\r\n\t\t\tthis._childOfLayoutWidget = parent && parent.isLayoutContainer;\r\n\r\n\t\t\t// I need to call resize() on my child/children (when I become visible), unless\r\n\t\t\t// I'm the child of a layout widget in which case my parent will call resize() on me and I'll do it then.\r\n\t\t\tthis._needLayout = !this._childOfLayoutWidget;\r\n\r\n\t\t\tthis.inherited(arguments);\r\n\r\n\t\t\tif(this._isShown()){\r\n\t\t\t\tthis._onShow();\r\n\t\t\t}\r\n\r\n\t\t\tif(!this._childOfLayoutWidget){\r\n\t\t\t\t// Since my parent isn't a layout container, and my style *may be* width=height=100%\r\n\t\t\t\t// or something similar (either set directly or via a CSS class),\r\n\t\t\t\t// monitor when viewport size changes so that I can re-layout.\r\n\t\t\t\t// This is more for subclasses of ContentPane than ContentPane itself, although it\r\n\t\t\t\t// could be useful for a ContentPane if it has a single child widget inheriting ContentPane's size.\r\n\t\t\t\tthis.own(Viewport.on(\"resize\", lang.hitch(this, \"resize\")));\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_checkIfSingleChild: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tTest if we have exactly one visible widget as a child,\r\n\t\t\t//\t\tand if so assume that we are a container for that widget,\r\n\t\t\t//\t\tand should propagate startup() and resize() calls to it.\r\n\t\t\t//\t\tSkips over things like data stores since they aren't visible.\r\n\r\n\t\t\tif(!this.doLayout){ return; }\r\n\r\n\t\t\tvar candidateWidgets = [],\r\n\t\t\t\totherVisibleNodes = false;\r\n\r\n\t\t\tquery(\"> *\", this.containerNode).some(function(node){\r\n\t\t\t\tvar widget = registry.byNode(node);\r\n\t\t\t\tif(widget && widget.resize){\r\n\t\t\t\t\tcandidateWidgets.push(widget);\r\n\t\t\t\t}else if(!/script|link|style/i.test(node.nodeName) && node.offsetHeight){\r\n\t\t\t\t\totherVisibleNodes = true;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tthis._singleChild = candidateWidgets.length == 1 && !otherVisibleNodes ?\r\n\t\t\t\tcandidateWidgets[0] : null;\r\n\r\n\t\t\t// So we can set overflow: hidden to avoid a safari bug w/scrollbars showing up (#9449)\r\n\t\t\tdomClass.toggle(this.containerNode, this.baseClass + \"SingleChild\", !!this._singleChild);\r\n\t\t},\r\n\r\n\t\tresize: function(changeSize, resultSize){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSee `dijit/layout/_LayoutWidget.resize()` for description.\r\n\t\t\t//\t\tAlthough ContentPane doesn't extend _LayoutWidget, it does implement\r\n\t\t\t//\t\tthe same API.\r\n\r\n\t\t\tthis._resizeCalled = true;\r\n\r\n\t\t\tthis._scheduleLayout(changeSize, resultSize);\r\n\t\t},\r\n\r\n\t\t_scheduleLayout: function(changeSize, resultSize){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tResize myself, and call resize() on each of my child layout widgets, either now\r\n\t\t\t//\t\t(if I'm currently visible) or when I become visible\r\n\t\t\tif(this._isShown()){\r\n\t\t\t\tthis._layout(changeSize, resultSize);\r\n\t\t\t}else{\r\n\t\t\t\tthis._needLayout = true;\r\n\t\t\t\tthis._changeSize = changeSize;\r\n\t\t\t\tthis._resultSize = resultSize;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_layout: function(changeSize, resultSize){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tResize myself according to optional changeSize/resultSize parameters, like a layout widget.\r\n\t\t\t//\t\tAlso, since I am an isLayoutContainer widget, each of my children expects me to\r\n\t\t\t//\t\tcall resize() or layout() on it.\r\n\t\t\t//\r\n\t\t\t//\t\tShould be called on initialization and also whenever we get new content\r\n\t\t\t//\t\t(from an href, or from set('content', ...))... but deferred until\r\n\t\t\t//\t\tthe ContentPane is visible\r\n\r\n\t\t\tdelete this._needLayout;\r\n\r\n\t\t\t// For the TabContainer --> BorderContainer --> ContentPane case, _onShow() is\r\n\t\t\t// never called directly, so resize() is our trigger to do the initial href download (see [20099]).\r\n\t\t\t// However, don't load href for closed TitlePanes.\r\n\t\t\tif(!this._wasShown && this.open !== false){\r\n\t\t\t\tthis._onShow();\r\n\t\t\t}\r\n\r\n\t\t\t// Set margin box size, unless it wasn't specified, in which case use current size.\r\n\t\t\tif(changeSize){\r\n\t\t\t\tdomGeometry.setMarginBox(this.domNode, changeSize);\r\n\t\t\t}\r\n\r\n\t\t\t// Compute content box size of containerNode in case we [later] need to size our single child.\r\n\t\t\tvar cn = this.containerNode;\r\n\t\t\tif(cn === this.domNode){\r\n\t\t\t\t// If changeSize or resultSize was passed to this method and this.containerNode ==\r\n\t\t\t\t// this.domNode then we can compute the content-box size without querying the node,\r\n\t\t\t\t// which is more reliable (similar to LayoutWidget.resize) (see for example #9449).\r\n\t\t\t\tvar mb = resultSize || {};\r\n\t\t\t\tlang.mixin(mb, changeSize || {}); // changeSize overrides resultSize\r\n\t\t\t\tif(!(\"h\" in mb) || !(\"w\" in mb)){\r\n\t\t\t\t\tmb = lang.mixin(domGeometry.getMarginBox(cn), mb); // just use domGeometry.setMarginBox() to fill in missing values\r\n\t\t\t\t}\r\n\t\t\t\tthis._contentBox = layoutUtils.marginBox2contentBox(cn, mb);\r\n\t\t\t}else{\r\n\t\t\t\tthis._contentBox = domGeometry.getContentBox(cn);\r\n\t\t\t}\r\n\r\n\t\t\tthis._layoutChildren();\r\n\t\t},\r\n\r\n\t\t_layoutChildren: function(){\r\n\t\t\t// Call _checkIfSingleChild() again in case app has manually mucked w/the content\r\n\t\t\t// of the ContentPane (rather than changing it through the set(\"content\", ...) API.\r\n\t\t\tthis._checkIfSingleChild();\r\n\r\n\t\t\tif(this._singleChild && this._singleChild.resize){\r\n\t\t\t\tvar cb = this._contentBox || domGeometry.getContentBox(this.containerNode);\r\n\r\n\t\t\t\t// note: if widget has padding this._contentBox will have l and t set,\r\n\t\t\t\t// but don't pass them to resize() or it will doubly-offset the child\r\n\t\t\t\tthis._singleChild.resize({w: cb.w, h: cb.h});\r\n\t\t\t}else{\r\n\t\t\t\t// All my child widgets are independently sized (rather than matching my size),\r\n\t\t\t\t// but I still need to call resize() on each child to make it layout.\r\n\t\t\t\tvar children = this.getChildren(),\r\n\t\t\t\t\twidget,\r\n\t\t\t\t\ti = 0;\r\n\t\t\t\twhile(widget = children[i++]){\r\n\t\t\t\t\tif(widget.resize){\r\n\t\t\t\t\t\twidget.resize();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_isShown: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns true if the content is currently shown.\r\n\t\t\t// description:\r\n\t\t\t//\t\tIf I am a child of a layout widget then it actually returns true if I've ever been visible,\r\n\t\t\t//\t\tnot whether I'm currently visible, since that's much faster than tracing up the DOM/widget\r\n\t\t\t//\t\ttree every call, and at least solves the performance problem on page load by deferring loading\r\n\t\t\t//\t\thidden ContentPanes until they are first shown\r\n\r\n\t\t\tif(this._childOfLayoutWidget){\r\n\t\t\t\t// If we are TitlePane, etc - we return that only *IF* we've been resized\r\n\t\t\t\tif(this._resizeCalled && \"open\" in this){\r\n\t\t\t\t\treturn this.open;\r\n\t\t\t\t}\r\n\t\t\t\treturn this._resizeCalled;\r\n\t\t\t}else if(\"open\" in this){\r\n\t\t\t\treturn this.open;\t\t// for TitlePane, etc.\r\n\t\t\t}else{\r\n\t\t\t\tvar node = this.domNode, parent = this.domNode.parentNode;\r\n\t\t\t\treturn (node.style.display != 'none') && (node.style.visibility != 'hidden') && !domClass.contains(node, \"dijitHidden\") &&\r\n\t\t\t\t\tparent && parent.style && (parent.style.display != 'none');\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_onShow: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCalled when the ContentPane is made visible\r\n\t\t\t// description:\r\n\t\t\t//\t\tFor a plain ContentPane, this is called on initialization, from startup().\r\n\t\t\t//\t\tIf the ContentPane is a hidden pane of a TabContainer etc., then it's\r\n\t\t\t//\t\tcalled whenever the pane is made visible.\r\n\t\t\t//\r\n\t\t\t//\t\tDoes layout/resize of child widget(s)\r\n\r\n\t\t\t// Need to keep track of whether ContentPane has been shown (which is different than\r\n\t\t\t// whether or not it's currently visible).\r\n\t\t\tthis._wasShown = true;\r\n\r\n\t\t\tif(this._needLayout){\r\n\t\t\t\t// If a layout has been scheduled for when we become visible, do it now\r\n\t\t\t\tthis._layout(this._changeSize, this._resultSize);\r\n\t\t\t}\r\n\r\n\t\t\tthis.inherited(arguments);\r\n\t\t}\r\n\t});\r\n});\r\n"]}