{"version":3,"sources":["registry.js"],"names":["define","array","win","dijit","_widgetTypeCtr","hash","registry","length","add","widget","id","Error","this","remove","byId","byNode","node","getAttribute","toArray","ar","push","getUniqueId","widgetType","_scopeName","findWidgets","root","skipNode","outAry","getChildrenHelper","firstChild","nextSibling","nodeType","widgetId","_destroyAll","_curFocus","_prevFocus","_activeStack","forEach","body","_destroyed","destroyRecursive","destroy","getEnclosingWidget","parentNode","_hash"],"mappings":";;;;;;;AAAAA,QACC,mBACA,oBACA,YACE,SAASC,EAAOC,EAAKC,GAKvB,IAAIC,KAAqBC,KAErBC,GAMHC,OAAQ,EAERC,IAAK,SAASC,GAKb,GAAGJ,EAAKI,EAAOC,IACd,MAAM,IAAIC,MAAM,qCAAuCF,EAAOC,GAAK,sCAEpEL,EAAKI,EAAOC,IAAMD,EAClBG,KAAKL,UAGNM,OAAQ,SAAoBH,GAIxBL,EAAKK,YACAL,EAAKK,GACZE,KAAKL,WAIPO,KAAM,SAA2BJ,GAIhC,MAAoB,iBAANA,EAAiBL,EAAKK,GAAMA,GAG3CK,OAAQ,SAAqBC,GAG5B,OAAOX,EAAKW,EAAKC,aAAa,cAG/BC,QAAS,WAQR,IAAIC,KACJ,IAAI,IAAIT,KAAML,EACbc,EAAGC,KAAKf,EAAKK,IAEd,OAAOS,GAGRE,YAAa,SAAmBC,GAI/B,IAAIZ,EACJ,GACCA,EAAKY,EAAa,KAChBA,KAAclB,IACZA,EAAekB,GAAclB,EAAekB,GAAc,SACxDjB,EAAKK,IACZ,MAA2B,SAApBP,EAAMoB,WAAwBb,EAAKP,EAAMoB,WAAa,IAAMb,GAGpEc,YAAa,SAASC,EAAMC,GAS3B,IAAIC,KAmBJ,OAjBA,SAASC,EAAkBH,GAC1B,IAAI,IAAIT,EAAOS,EAAKI,WAAYb,EAAMA,EAAOA,EAAKc,YACjD,GAAoB,GAAjBd,EAAKe,SAAc,CACrB,IAAIC,EAAWhB,EAAKC,aAAa,YACjC,GAAGe,EAAS,CACX,IAAIvB,EAASJ,EAAK2B,GACfvB,GACFkB,EAAOP,KAAKX,QAELO,IAASU,GACjBE,EAAkBZ,IAMtBY,CAAkBH,GACXE,GAGRM,YAAa,WAKZ9B,EAAM+B,UAAY,KAClB/B,EAAMgC,WAAa,KACnBhC,EAAMiC,gBAGNnC,EAAMoC,QAAQ/B,EAASkB,YAAYtB,EAAIoC,QAAS,SAAS7B,GAGpDA,EAAO8B,aACP9B,EAAO+B,iBACT/B,EAAO+B,mBACC/B,EAAOgC,SACfhC,EAAOgC,cAMXC,mBAAoB,SAAqB1B,GAIxC,KAAMA,GAAK,CACV,IAAIN,EAAsB,GAAjBM,EAAKe,UAAiBf,EAAKC,aAAa,YACjD,GAAGP,EACF,OAAOL,EAAKK,GAEbM,EAAOA,EAAK2B,WAEb,OAAO,MAKRC,MAAOvC,GAKR,OAFAF,EAAMG,SAAWA,EAEVA","file":"../registry.js","sourcesContent":["define([\r\n\t\"dojo/_base/array\", // array.forEach array.map\r\n\t\"dojo/_base/window\", // win.body\r\n\t\"./_dijit\"\t// dijit._scopeName\r\n], function(array, win, dijit){\r\n\r\n\t// module:\r\n\t//\t\tdijit/registry\r\n\r\n\tvar _widgetTypeCtr = {}, hash = {};\r\n\r\n\tvar registry =  {\r\n\t\t// summary:\r\n\t\t//\t\tRegistry of existing widget on page, plus some utility methods.\r\n\r\n\t\t// length: Number\r\n\t\t//\t\tNumber of registered widgets\r\n\t\tlength: 0,\r\n\r\n\t\tadd: function(widget){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tAdd a widget to the registry. If a duplicate ID is detected, a error is thrown.\r\n\t\t\t// widget: dijit/_WidgetBase\r\n\t\t\t//\t\tAny dijit/_WidgetBase subclass.\r\n\t\t\tif(hash[widget.id]){\r\n\t\t\t\tthrow new Error(\"Tried to register widget with id==\" + widget.id + \" but that id is already registered\");\r\n\t\t\t}\r\n\t\t\thash[widget.id] = widget;\r\n\t\t\tthis.length++;\r\n\t\t},\r\n\r\n\t\tremove: function(/*String*/ id){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tRemove a widget from the registry. Does not destroy the widget; simply\r\n\t\t\t//\t\tremoves the reference.\r\n\t\t\tif(hash[id]){\r\n\t\t\t\tdelete hash[id];\r\n\t\t\t\tthis.length--;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tbyId: function(/*String|Widget*/ id){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tFind a widget by it's id.\r\n\t\t\t//\t\tIf passed a widget then just returns the widget.\r\n\t\t\treturn typeof id == \"string\" ? hash[id] : id;\t// dijit/_WidgetBase\r\n\t\t},\r\n\r\n\t\tbyNode: function(/*DOMNode*/ node){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns the widget corresponding to the given DOMNode\r\n\t\t\treturn hash[node.getAttribute(\"widgetId\")]; // dijit/_WidgetBase\r\n\t\t},\r\n\r\n\t\ttoArray: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tConvert registry into a true Array\r\n\t\t\t//\r\n\t\t\t// example:\r\n\t\t\t//\t\tWork with the widget .domNodes in a real Array\r\n\t\t\t//\t\t|\tarray.map(registry.toArray(), function(w){ return w.domNode; });\r\n\r\n\t\t\tvar ar = [];\r\n\t\t\tfor(var id in hash){\r\n\t\t\t\tar.push(hash[id]);\r\n\t\t\t}\r\n\t\t\treturn ar;\t// dijit/_WidgetBase[]\r\n\t\t},\r\n\r\n\t\tgetUniqueId: function(/*String*/widgetType){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tGenerates a unique id for a given widgetType\r\n\r\n\t\t\tvar id;\r\n\t\t\tdo{\r\n\t\t\t\tid = widgetType + \"_\" +\r\n\t\t\t\t\t(widgetType in _widgetTypeCtr ?\r\n\t\t\t\t\t\t++_widgetTypeCtr[widgetType] : _widgetTypeCtr[widgetType] = 0);\r\n\t\t\t}while(hash[id]);\r\n\t\t\treturn dijit._scopeName == \"dijit\" ? id : dijit._scopeName + \"_\" + id; // String\r\n\t\t},\r\n\r\n\t\tfindWidgets: function(root, skipNode){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSearch subtree under root returning widgets found.\r\n\t\t\t//\t\tDoesn't search for nested widgets (ie, widgets inside other widgets).\r\n\t\t\t// root: DOMNode\r\n\t\t\t//\t\tNode to search under.\r\n\t\t\t// skipNode: DOMNode\r\n\t\t\t//\t\tIf specified, don't search beneath this node (usually containerNode).\r\n\r\n\t\t\tvar outAry = [];\r\n\r\n\t\t\tfunction getChildrenHelper(root){\r\n\t\t\t\tfor(var node = root.firstChild; node; node = node.nextSibling){\r\n\t\t\t\t\tif(node.nodeType == 1){\r\n\t\t\t\t\t\tvar widgetId = node.getAttribute(\"widgetId\");\r\n\t\t\t\t\t\tif(widgetId){\r\n\t\t\t\t\t\t\tvar widget = hash[widgetId];\r\n\t\t\t\t\t\t\tif(widget){\t// may be null on page w/multiple dojo's loaded\r\n\t\t\t\t\t\t\t\toutAry.push(widget);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}else if(node !== skipNode){\r\n\t\t\t\t\t\t\tgetChildrenHelper(node);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tgetChildrenHelper(root);\r\n\t\t\treturn outAry;\r\n\t\t},\r\n\r\n\t\t_destroyAll: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCode to destroy all widgets and do other cleanup on page unload\r\n\r\n\t\t\t// Clean up focus manager lingering references to widgets and nodes\r\n\t\t\tdijit._curFocus = null;\r\n\t\t\tdijit._prevFocus = null;\r\n\t\t\tdijit._activeStack = [];\r\n\r\n\t\t\t// Destroy all the widgets, top down\r\n\t\t\tarray.forEach(registry.findWidgets(win.body()), function(widget){\r\n\t\t\t\t// Avoid double destroy of widgets like Menu that are attached to <body>\r\n\t\t\t\t// even though they are logically children of other widgets.\r\n\t\t\t\tif(!widget._destroyed){\r\n\t\t\t\t\tif(widget.destroyRecursive){\r\n\t\t\t\t\t\twidget.destroyRecursive();\r\n\t\t\t\t\t}else if(widget.destroy){\r\n\t\t\t\t\t\twidget.destroy();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\tgetEnclosingWidget: function(/*DOMNode*/ node){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns the widget whose DOM tree contains the specified DOMNode, or null if\r\n\t\t\t//\t\tthe node is not contained within the DOM tree of any widget\r\n\t\t\twhile(node){\r\n\t\t\t\tvar id = node.nodeType == 1 && node.getAttribute(\"widgetId\");\r\n\t\t\t\tif(id){\r\n\t\t\t\t\treturn hash[id];\r\n\t\t\t\t}\r\n\t\t\t\tnode = node.parentNode;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t},\r\n\r\n\t\t// In case someone needs to access hash.\r\n\t\t// Actually, this is accessed from WidgetSet back-compatibility code\r\n\t\t_hash: hash\r\n\t};\r\n\r\n\tdijit.registry = registry;\r\n\r\n\treturn registry;\r\n});\r\n"]}