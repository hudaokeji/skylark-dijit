{"version":3,"sources":["_base/place.js"],"names":["define","array","lang","windowUtils","place","dijit","exports","getViewport","getBox","placeOnScreen","at","placeOnScreenAroundElement","node","aroundNode","aroundCorners","layoutNode","positions","isArray","key","push","aroundCorner","corner","around","placeOnScreenAroundNode","placeOnScreenAroundRectangle","getPopupAroundAlignment","position","leftToRight","align","forEach","pos","ltr","mixin"],"mappings":";;;;;;;AAAAA,QACC,mBACA,kBACA,cACA,WACA,WACE,SAASC,EAAOC,EAAMC,EAAaC,EAAOC,GAM5C,IAAIC,GAKJC,YAAsB,WAKrB,OAAOJ,EAAYK,WA2GpB,OAxGAF,EAAQG,cAAgBL,EAAMM,GAE9BJ,EAAQK,2BAA6B,SAASC,EAAMC,EAAYC,EAAeC,GAY9E,IAAIC,EACJ,GAAGd,EAAKe,QAAQH,GACfE,EAAYF,OAGZ,IAAI,IAAII,KADRF,KACeF,EACdE,EAAUG,MAAMC,aAAcF,EAAKG,OAAQP,EAAcI,KAI3D,OAAOd,EAAMkB,OAAOV,EAAMC,EAAYG,GAAW,EAAMD,IAGxDT,EAAQiB,wBAA0BjB,EAAQK,2BAU1CL,EAAQkB,6BAA+BlB,EAAQK,2BAW/CL,EAAQmB,wBAA0B,SAAmBC,EAAsBC,GAqB1E,IAAIC,KA6BJ,OA5BA3B,EAAM4B,QAAQH,EAAU,SAASI,GAChC,IAAIC,EAAMJ,EACV,OAAOG,GACN,IAAK,QACJF,EAAMD,EAAc,KAAO,MAAQA,EAAc,KAAO,KACxD,MACD,IAAK,SACJC,EAAMD,EAAc,KAAO,MAAQA,EAAc,KAAO,KACxD,MACD,IAAK,YACJI,GAAOA,EAER,IAAK,QAEJH,EAAMG,EAAM,KAAO,MAAQA,EAAM,KAAO,KACxCH,EAAMG,EAAM,KAAO,MAAQA,EAAM,KAAO,KACxC,MACD,IAAK,YACJA,GAAOA,EAER,IAAK,QACL,QAECH,EAAMG,EAAM,KAAO,MAAQA,EAAM,KAAO,KACxCH,EAAMG,EAAM,KAAO,MAAQA,EAAM,KAAO,QAIpCH,GAGR1B,EAAK8B,MAAM3B,EAAOC,GAGXD","file":"../../_base/place.js","sourcesContent":["define([\r\n\t\"dojo/_base/array\", // array.forEach\r\n\t\"dojo/_base/lang\", // lang.isArray, lang.mixin\r\n\t\"dojo/window\", // windowUtils.getBox\r\n\t\"../place\",\r\n\t\"../main\"\t// export to dijit namespace\r\n], function(array, lang, windowUtils, place, dijit){\r\n\r\n\t// module:\r\n\t//\t\tdijit/_base/place\r\n\r\n\r\n\tvar exports = {\r\n\t\t// summary:\r\n\t\t//\t\tDeprecated back compatibility module, new code should use dijit/place directly instead of using this module.\r\n\t};\r\n\r\n\texports.getViewport = function(){\r\n\t\t// summary:\r\n\t\t//\t\tDeprecated method to return the dimensions and scroll position of the viewable area of a browser window.\r\n\t\t//\t\tNew code should use windowUtils.getBox()\r\n\r\n\t\treturn windowUtils.getBox();\r\n\t};\r\n\r\n\texports.placeOnScreen = place.at;\r\n\r\n\texports.placeOnScreenAroundElement = function(node, aroundNode, aroundCorners, layoutNode){\r\n\t\t// summary:\r\n\t\t//\t\tLike dijit.placeOnScreenAroundNode(), except it accepts an arbitrary object\r\n\t\t//\t\tfor the \"around\" argument and finds a proper processor to place a node.\r\n\t\t//\t\tDeprecated, new code should use dijit/place.around() instead.\r\n\r\n\t\t// Convert old style {\"BL\": \"TL\", \"BR\": \"TR\"} type argument\r\n\t\t// to style needed by dijit.place code:\r\n\t\t//\t\t[\r\n\t\t//\t\t\t{aroundCorner: \"BL\", corner: \"TL\" },\r\n\t\t//\t\t\t{aroundCorner: \"BR\", corner: \"TR\" }\r\n\t\t//\t\t]\r\n\t\tvar positions;\r\n\t\tif(lang.isArray(aroundCorners)){\r\n\t\t\tpositions = aroundCorners;\r\n\t\t}else{\r\n\t\t\tpositions = [];\r\n\t\t\tfor(var key in aroundCorners){\r\n\t\t\t\tpositions.push({aroundCorner: key, corner: aroundCorners[key]});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn place.around(node, aroundNode, positions, true, layoutNode);\r\n\t};\r\n\r\n\texports.placeOnScreenAroundNode = exports.placeOnScreenAroundElement;\r\n\t/*=====\r\n\texports.placeOnScreenAroundNode = function(node, aroundNode, aroundCorners, layoutNode){\r\n\t\t// summary:\r\n\t\t//\t\tPosition node adjacent or kitty-corner to aroundNode\r\n\t\t//\t\tsuch that it's fully visible in viewport.\r\n\t\t//\t\tDeprecated, new code should use dijit/place.around() instead.\r\n\t};\r\n\t=====*/\r\n\r\n\texports.placeOnScreenAroundRectangle = exports.placeOnScreenAroundElement;\r\n\t/*=====\r\n\texports.placeOnScreenAroundRectangle = function(node, aroundRect, aroundCorners, layoutNode){\r\n\t\t// summary:\r\n\t\t//\t\tLike dijit.placeOnScreenAroundNode(), except that the \"around\"\r\n\t\t//\t\tparameter is an arbitrary rectangle on the screen (x, y, width, height)\r\n\t\t//\t\tinstead of a dom node.\r\n\t\t//\t\tDeprecated, new code should use dijit/place.around() instead.\r\n\t};\r\n\t=====*/\r\n\r\n\texports.getPopupAroundAlignment = function(/*Array*/ position, /*Boolean*/ leftToRight){\r\n\t\t// summary:\r\n\t\t//\t\tDeprecated method, unneeded when using dijit/place directly.\r\n\t\t//\t\tTransforms the passed array of preferred positions into a format suitable for\r\n\t\t//\t\tpassing as the aroundCorners argument to dijit/place.placeOnScreenAroundElement.\r\n\t\t// position: String[]\r\n\t\t//\t\tThis variable controls the position of the drop down.\r\n\t\t//\t\tIt's an array of strings with the following values:\r\n\t\t//\r\n\t\t//\t\t- before: places drop down to the left of the target node/widget, or to the right in\r\n\t\t//\t\t  the case of RTL scripts like Hebrew and Arabic\r\n\t\t//\t\t- after: places drop down to the right of the target node/widget, or to the left in\r\n\t\t//\t\t  the case of RTL scripts like Hebrew and Arabic\r\n\t\t//\t\t- above: drop down goes above target node\r\n\t\t//\t\t- below: drop down goes below target node\r\n\t\t//\r\n\t\t//\t\tThe list is positions is tried, in order, until a position is found where the drop down fits\r\n\t\t//\t\twithin the viewport.\r\n\t\t// leftToRight: Boolean\r\n\t\t//\t\tWhether the popup will be displaying in leftToRight mode.\r\n\r\n\t\tvar align = {};\r\n\t\tarray.forEach(position, function(pos){\r\n\t\t\tvar ltr = leftToRight;\r\n\t\t\tswitch(pos){\r\n\t\t\t\tcase \"after\":\r\n\t\t\t\t\talign[leftToRight ? \"BR\" : \"BL\"] = leftToRight ? \"BL\" : \"BR\";\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"before\":\r\n\t\t\t\t\talign[leftToRight ? \"BL\" : \"BR\"] = leftToRight ? \"BR\" : \"BL\";\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"below-alt\":\r\n\t\t\t\t\tltr = !ltr;\r\n\t\t\t\t\t// fall through\r\n\t\t\t\tcase \"below\":\r\n\t\t\t\t\t// first try to align left borders, next try to align right borders (or reverse for RTL mode)\r\n\t\t\t\t\talign[ltr ? \"BL\" : \"BR\"] = ltr ? \"TL\" : \"TR\";\r\n\t\t\t\t\talign[ltr ? \"BR\" : \"BL\"] = ltr ? \"TR\" : \"TL\";\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"above-alt\":\r\n\t\t\t\t\tltr = !ltr;\r\n\t\t\t\t\t// fall through\r\n\t\t\t\tcase \"above\":\r\n\t\t\t\tdefault:\r\n\t\t\t\t\t// first try to align left borders, next try to align right borders (or reverse for RTL mode)\r\n\t\t\t\t\talign[ltr ? \"TL\" : \"TR\"] = ltr ? \"BL\" : \"BR\";\r\n\t\t\t\t\talign[ltr ? \"TR\" : \"TL\"] = ltr ? \"BR\" : \"BL\";\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn align;\r\n\t};\r\n\r\n\tlang.mixin(dijit, exports);\r\n\r\n\t/*===== return exports; =====*/\r\n\treturn dijit;\t// for back compat :-(\r\n});\r\n"]}