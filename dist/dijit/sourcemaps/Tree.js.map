{"version":3,"sources":["Tree.js"],"names":["define","array","aspect","cookie","declare","Deferred","all","dom","domClass","domGeometry","domStyle","createError","fxUtils","has","kernel","keys","lang","on","topic","touch","when","a11yclick","focus","registry","manager","_Widget","_TemplatedMixin","_Container","_Contained","_CssStateMixin","_KeyNavMixin","treeNodeTemplate","treeTemplate","TreeStoreModel","ForestStoreModel","_dndSelector","shimmedPromise","d","delegate","promise","addCallback","callback","this","then","addErrback","errback","otherwise","TreeNode","item","isTreeNode","label","_setLabelAttr","val","labelNode","labelType","_set","isExpandable","isExpanded","state","templateString","baseClass","cssStateNodes","rowNode","_setTooltipAttr","node","type","attribute","buildRendering","inherited","arguments","_setExpando","_updateItemClasses","setAttribute","setSelected","_setIndentAttr","indent","pixels","Math","max","tree","_nodePixelIndent","set","domNode","isLeftToRight","forEach","getChildren","child","markProcessing","unmarkProcessing","model","_v10Compat","root","_applyClassAndStyle","_startPaint","lower","upper","clsName","nodeName","oldCls","replace","_updateLayout","parent","getParent","markAsRoot","style","display","toggle","getNextSibling","processing","styles","idx","expandoNode","expandoNodeText","innerHTML","expand","_expandDeferred","_collapseDeferred","cancel","showRoot","rootNode","containerNode","add","contentNode","wipeIn","duration","defaultDuration","def","stop","after","resolve","play","collapse","remove","wipeOut","setChildItems","items","defs","focusedChild","oldChildren","prototype","removeChild","call","defer","_destroyed","dndController","removeTreeNode","id","getIdentity","ary","_itemNodesMap","length","index","indexOf","splice","persist","destroyedPath","map","getTreePath","join","path","_openedNodes","substr","_saveExpandedNodes","lastFocusedChild","isDescendant","destroyRecursive","existingNodes","i","_createTreeNode","mayHaveChildren","getLabel","tooltip","getTooltip","ownerDocument","dir","textDir","push","addChild","autoExpand","_state","_expandNode","unshift","children","makeExpandable","selected","focusNode","extend","_setTextDirAttr","_created","applyTextDir","childNode","Tree","store","query","childrenAttr","paths","selectedItems","selectedItem","openOnClick","openOnDblClick","dndParams","onDndDrop","itemCreator","onDndCancel","checkAcceptance","checkItemAcceptance","dragThreshold","betweenThreshold","_publish","topicName","message","publish","mixin","event","postMixInProperties","cookieName","expandChildrenDeferred","pendingCommandsPromise","postCreate","_initState","self","own","selector","enter","evt","_onNodeMouseEnter","byNode","leave","_onNodeMouseLeave","press","_onNodePress","getEnclosingWidget","_onClick","_onDblClick","_store2model","hitch","isString","getObject","params","_load","onLoadDeferred","deprecated","modelParams","childrenAttrs","getItemChildren","onComplete","onError","Boolean","onLoad","getRoot","rn","singular","rootLoadingIndicator","removeAttribute","appendChild","identity","err","console","error","getNodesByItem","concat","_setSelectedItemAttr","_setSelectedItemsAttr","always","identities","nodes","_setPathAttr","_setPathsAttr","selectPath","nextPath","shift","nextNode","filter","PathError","newNodes","_setSelectedNodeAttr","_setSelectedNodesAttr","setSelection","expandAll","_this","childBranches","collapseAll","_collapseNode","getIconClass","opened","getLabelClass","getRowClass","getIconStyle","getLabelStyle","getRowStyle","_onDownArrow","_getNext","_onUpArrow","previousSibling","getPreviousSibling","hasChildren","_onRightArrow","_onLeftArrow","focusLastChild","_getLast","_getFirst","c","returnNode","childSelector","isExpandoNode","widget","nodeWidget","e","__click","doOpen","func","domElement","target","isExpandoClick","_onExpandoClick","stopPropagation","preventDefault","onClick","onDblClick","onOpen","onClose","_getNextNode","declaredClass","_getRootOrFirstNode","_expandNodeDeferred","ret","_loadDeferred","reject","def2","scrollLeft","focusChild","_onItemChange","_onItemChildrenChange","newChildrenList","parentNodes","parentNode","_onItemDelete","oreo","split","expanded","expires","destroy","_curSearch","timer","resize","changeSize","setMarginBox","position","indentDetector","w","_adjustWidths","_outstandingPaintOperations","p","_adjustWidthsTimer","oc","_started","width","scrollWidth","offsetWidth","args","focusFirstChild","_TreeNode"],"mappings":"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","file":"../Tree.js","sourcesContent":["define([\r\n\t\"dojo/_base/array\", // array.filter array.forEach array.map\r\n\t\"dojo/aspect\",\r\n\t\"dojo/cookie\", // cookie\r\n\t\"dojo/_base/declare\", // declare\r\n\t\"dojo/Deferred\", // Deferred\r\n\t\"dojo/promise/all\",\r\n\t\"dojo/dom\", // dom.isDescendant\r\n\t\"dojo/dom-class\", // domClass.add domClass.remove domClass.replace domClass.toggle\r\n\t\"dojo/dom-geometry\", // domGeometry.setMarginBox domGeometry.position\r\n\t\"dojo/dom-style\", // domStyle.set\r\n\t\"dojo/errors/create\", // createError\r\n\t\"dojo/fx\", // fxUtils.wipeIn fxUtils.wipeOut\r\n\t\"dojo/has\",\r\n\t\"dojo/_base/kernel\", // kernel.deprecated\r\n\t\"dojo/keys\", // arrows etc.\r\n\t\"dojo/_base/lang\", // lang.getObject lang.mixin lang.hitch\r\n\t\"dojo/on\", // on(), on.selector()\r\n\t\"dojo/topic\",\r\n\t\"dojo/touch\",\r\n\t\"dojo/when\",\r\n\t\"./a11yclick\",\r\n\t\"./focus\",\r\n\t\"./registry\", // registry.byNode(), registry.getEnclosingWidget()\r\n\t\"./_base/manager\", // manager.defaultDuration\r\n\t\"./_Widget\",\r\n\t\"./_TemplatedMixin\",\r\n\t\"./_Container\",\r\n\t\"./_Contained\",\r\n\t\"./_CssStateMixin\",\r\n\t\"./_KeyNavMixin\",\r\n\t\"dojo/text!./templates/TreeNode.html\",\r\n\t\"dojo/text!./templates/Tree.html\",\r\n\t\"./tree/TreeStoreModel\",\r\n\t\"./tree/ForestStoreModel\",\r\n\t\"./tree/_dndSelector\",\r\n\t\"dojo/query!css2\"\t// needed when on.selector() used with a string for the selector\r\n], function(array, aspect, cookie, declare, Deferred, all,\r\n\t\t\tdom, domClass, domGeometry, domStyle, createError, fxUtils, has, kernel, keys, lang, on, topic, touch, when,\r\n\t\t\ta11yclick, focus, registry, manager, _Widget, _TemplatedMixin, _Container, _Contained, _CssStateMixin, _KeyNavMixin,\r\n\t\t\ttreeNodeTemplate, treeTemplate, TreeStoreModel, ForestStoreModel, _dndSelector){\r\n\r\n\t// module:\r\n\t//\t\tdijit/Tree\r\n\r\n\tfunction shimmedPromise(/*Deferred|Promise*/ d){\r\n\t\t// summary:\r\n\t\t//\t\tReturn a Promise based on given Deferred or Promise, with back-compat addCallback() and addErrback() shims\r\n\t\t//\t\tadded (TODO: remove those back-compat shims, and this method, for 2.0)\r\n\r\n\t\treturn lang.delegate(d.promise || d, {\r\n\t\t\taddCallback: function(callback){\r\n\t\t\t\tthis.then(callback);\r\n\t\t\t},\r\n\t\t\taddErrback: function(errback){\r\n\t\t\t\tthis.otherwise(errback);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tvar TreeNode = declare(\"dijit._TreeNode\", [_Widget, _TemplatedMixin, _Container, _Contained, _CssStateMixin], {\r\n\t\t// summary:\r\n\t\t//\t\tSingle node within a tree.   This class is used internally\r\n\t\t//\t\tby Tree and should not be accessed directly.\r\n\t\t// tags:\r\n\t\t//\t\tprivate\r\n\r\n\t\t// item: [const] Item\r\n\t\t//\t\tthe dojo.data entry this tree represents\r\n\t\titem: null,\r\n\r\n\t\t// isTreeNode: [protected] Boolean\r\n\t\t//\t\tIndicates that this is a TreeNode.   Used by `dijit.Tree` only,\r\n\t\t//\t\tshould not be accessed directly.\r\n\t\tisTreeNode: true,\r\n\r\n\t\t// label: String\r\n\t\t//\t\tText of this tree node\r\n\t\tlabel: \"\",\r\n\t\t_setLabelAttr: function(val){\r\n\t\t\tthis.labelNode[this.labelType == \"html\" ? \"innerHTML\" : \"innerText\" in this.labelNode ?\r\n\t\t\t\t\"innerText\" : \"textContent\"] = val;\r\n\t\t\tthis._set(\"label\", val);\r\n\t\t},\r\n\r\n\t\t// labelType: [const] String\r\n\t\t//\t\tSpecifies how to interpret the label.  Can be \"html\" or \"text\".\r\n\t\tlabelType: \"text\",\r\n\r\n\t\t// isExpandable: [private] Boolean\r\n\t\t//\t\tThis node has children, so show the expando node (+ sign)\r\n\t\tisExpandable: null,\r\n\r\n\t\t// isExpanded: [readonly] Boolean\r\n\t\t//\t\tThis node is currently expanded (ie, opened)\r\n\t\tisExpanded: false,\r\n\r\n\t\t// state: [private] String\r\n\t\t//\t\tDynamic loading-related stuff.\r\n\t\t//\t\tWhen an empty folder node appears, it is \"NotLoaded\" first,\r\n\t\t//\t\tthen after dojo.data query it becomes \"Loading\" and, finally \"Loaded\"\r\n\t\tstate: \"NotLoaded\",\r\n\r\n\t\ttemplateString: treeNodeTemplate,\r\n\r\n\t\tbaseClass: \"dijitTreeNode\",\r\n\r\n\t\t// For hover effect for tree node, and focus effect for label\r\n\t\tcssStateNodes: {\r\n\t\t\trowNode: \"dijitTreeRow\"\r\n\t\t},\r\n\r\n\t\t// Tooltip is defined in _WidgetBase but we need to handle the mapping to DOM here\r\n\t\t_setTooltipAttr: {node: \"rowNode\", type: \"attribute\", attribute: \"title\"},\r\n\r\n\t\tbuildRendering: function(){\r\n\t\t\tthis.inherited(arguments);\r\n\r\n\t\t\t// set expand icon for leaf\r\n\t\t\tthis._setExpando();\r\n\r\n\t\t\t// set icon and label class based on item\r\n\t\t\tthis._updateItemClasses(this.item);\r\n\r\n\t\t\tif(this.isExpandable){\r\n\t\t\t\tthis.labelNode.setAttribute(\"aria-expanded\", this.isExpanded);\r\n\t\t\t}\r\n\r\n\t\t\t//aria-selected should be false on all selectable elements.\r\n\t\t\tthis.setSelected(false);\r\n\t\t},\r\n\r\n\t\t_setIndentAttr: function(indent){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tTell this node how many levels it should be indented\r\n\t\t\t// description:\r\n\t\t\t//\t\t0 for top level nodes, 1 for their children, 2 for their\r\n\t\t\t//\t\tgrandchildren, etc.\r\n\r\n\t\t\t// Math.max() is to prevent negative padding on hidden root node (when indent == -1)\r\n\t\t\tvar pixels = (Math.max(indent, 0) * this.tree._nodePixelIndent) + \"px\";\r\n\r\n\t\t\tdomStyle.set(this.domNode, \"backgroundPosition\", pixels + \" 0px\");\t// TODOC: what is this for???\r\n\t\t\tdomStyle.set(this.rowNode, this.isLeftToRight() ? \"paddingLeft\" : \"paddingRight\", pixels);\r\n\r\n\t\t\tarray.forEach(this.getChildren(), function(child){\r\n\t\t\t\tchild.set(\"indent\", indent + 1);\r\n\t\t\t});\r\n\r\n\t\t\tthis._set(\"indent\", indent);\r\n\t\t},\r\n\r\n\t\tmarkProcessing: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tVisually denote that tree is loading data, etc.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\tthis.state = \"Loading\";\r\n\t\t\tthis._setExpando(true);\r\n\t\t},\r\n\r\n\t\tunmarkProcessing: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tClear markup from markProcessing() call\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\tthis._setExpando(false);\r\n\t\t},\r\n\r\n\t\t_updateItemClasses: function(item){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSet appropriate CSS classes for icon and label dom node\r\n\t\t\t//\t\t(used to allow for item updates to change respective CSS)\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\tvar tree = this.tree, model = tree.model;\r\n\t\t\tif(tree._v10Compat && item === model.root){\r\n\t\t\t\t// For back-compat with 1.0, need to use null to specify root item (TODO: remove in 2.0)\r\n\t\t\t\titem = null;\r\n\t\t\t}\r\n\t\t\tthis._applyClassAndStyle(item, \"icon\", \"Icon\");\r\n\t\t\tthis._applyClassAndStyle(item, \"label\", \"Label\");\r\n\t\t\tthis._applyClassAndStyle(item, \"row\", \"Row\");\r\n\r\n\t\t\tthis.tree._startPaint(true);\t\t// signifies paint started and finished (synchronously)\r\n\t\t},\r\n\r\n\t\t_applyClassAndStyle: function(item, lower, upper){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSet the appropriate CSS classes and styles for labels, icons and rows.\r\n\t\t\t//\r\n\t\t\t// item:\r\n\t\t\t//\t\tThe data item.\r\n\t\t\t//\r\n\t\t\t// lower:\r\n\t\t\t//\t\tThe lower case attribute to use, e.g. 'icon', 'label' or 'row'.\r\n\t\t\t//\r\n\t\t\t// upper:\r\n\t\t\t//\t\tThe upper case attribute to use, e.g. 'Icon', 'Label' or 'Row'.\r\n\t\t\t//\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\r\n\t\t\tvar clsName = \"_\" + lower + \"Class\";\r\n\t\t\tvar nodeName = lower + \"Node\";\r\n\t\t\tvar oldCls = this[clsName];\r\n\r\n\t\t\tthis[clsName] = this.tree[\"get\" + upper + \"Class\"](item, this.isExpanded);\r\n\t\t\tdomClass.replace(this[nodeName], this[clsName] || \"\", oldCls || \"\");\r\n\r\n\t\t\tdomStyle.set(this[nodeName], this.tree[\"get\" + upper + \"Style\"](item, this.isExpanded) || {});\r\n\t\t},\r\n\r\n\t\t_updateLayout: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSet appropriate CSS classes for this.domNode\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\r\n\t\t\t// if we are hiding the root node then make every first level child look like a root node\r\n\t\t\tvar parent = this.getParent(),\r\n\t\t\t\tmarkAsRoot = !parent || !parent.rowNode || parent.rowNode.style.display == \"none\";\r\n\t\t\tdomClass.toggle(this.domNode, \"dijitTreeIsRoot\", markAsRoot);\r\n\r\n\t\t\tdomClass.toggle(this.domNode, \"dijitTreeIsLast\", !markAsRoot && !this.getNextSibling());\r\n\t\t},\r\n\r\n\t\t_setExpando: function(/*Boolean*/ processing){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSet the right image for the expando node\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\r\n\t\t\tvar styles = [\"dijitTreeExpandoLoading\", \"dijitTreeExpandoOpened\",\r\n\t\t\t\t\t\"dijitTreeExpandoClosed\", \"dijitTreeExpandoLeaf\"],\r\n\t\t\t\t_a11yStates = [\"*\", \"-\", \"+\", \"*\"],\r\n\t\t\t\tidx = processing ? 0 : (this.isExpandable ? (this.isExpanded ? 1 : 2) : 3);\r\n\r\n\t\t\t// apply the appropriate class to the expando node\r\n\t\t\tdomClass.replace(this.expandoNode, styles[idx], styles);\r\n\r\n\t\t\t// provide a non-image based indicator for images-off mode\r\n\t\t\tthis.expandoNodeText.innerHTML = _a11yStates[idx];\r\n\r\n\t\t},\r\n\r\n\t\texpand: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tShow my children\r\n\t\t\t// returns:\r\n\t\t\t//\t\tPromise that resolves when expansion is complete\r\n\r\n\t\t\t// If there's already an expand in progress or we are already expanded, just return\r\n\t\t\tif(this._expandDeferred){\r\n\t\t\t\treturn shimmedPromise(this._expandDeferred);\t\t// dojo/promise/Promise\r\n\t\t\t}\r\n\r\n\t\t\t// cancel in progress collapse operation\r\n\t\t\tif(this._collapseDeferred){\r\n\t\t\t\tthis._collapseDeferred.cancel();\r\n\t\t\t\tdelete this._collapseDeferred;\r\n\t\t\t}\r\n\r\n\t\t\t// All the state information for when a node is expanded, maybe this should be\r\n\t\t\t// set when the animation completes instead\r\n\t\t\tthis.isExpanded = true;\r\n\t\t\tthis.labelNode.setAttribute(\"aria-expanded\", \"true\");\r\n\t\t\tif(this.tree.showRoot || this !== this.tree.rootNode){\r\n\t\t\t\tthis.containerNode.setAttribute(\"role\", \"group\");\r\n\t\t\t}\r\n\t\t\tdomClass.add(this.contentNode, 'dijitTreeContentExpanded');\r\n\t\t\tthis._setExpando();\r\n\t\t\tthis._updateItemClasses(this.item);\r\n\r\n\t\t\tif(this == this.tree.rootNode && this.tree.showRoot){\r\n\t\t\t\tthis.tree.domNode.setAttribute(\"aria-expanded\", \"true\");\r\n\t\t\t}\r\n\r\n\t\t\tvar wipeIn = fxUtils.wipeIn({\r\n\t\t\t\tnode: this.containerNode,\r\n\t\t\t\tduration: manager.defaultDuration\r\n\t\t\t});\r\n\r\n\t\t\t// Deferred that fires when expand is complete\r\n\t\t\tvar def = (this._expandDeferred = new Deferred(function(){\r\n\t\t\t\t// Canceller\r\n\t\t\t\twipeIn.stop();\r\n\t\t\t}));\r\n\r\n\t\t\taspect.after(wipeIn, \"onEnd\", function(){\r\n\t\t\t\tdef.resolve(true);\r\n\t\t\t}, true);\r\n\r\n\t\t\twipeIn.play();\r\n\r\n\t\t\treturn shimmedPromise(def);\t\t// dojo/promise/Promise\r\n\t\t},\r\n\r\n\t\tcollapse: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCollapse this node (if it's expanded)\r\n\t\t\t// returns:\r\n\t\t\t//\t\tPromise that resolves when collapse is complete\r\n\r\n\t\t\tif(this._collapseDeferred){\r\n\t\t\t\t// Node is already collapsed, or there's a collapse in progress, just return that Deferred\r\n\t\t\t\treturn shimmedPromise(this._collapseDeferred);\r\n\t\t\t}\r\n\r\n\t\t\t// cancel in progress expand operation\r\n\t\t\tif(this._expandDeferred){\r\n\t\t\t\tthis._expandDeferred.cancel();\r\n\t\t\t\tdelete this._expandDeferred;\r\n\t\t\t}\r\n\r\n\t\t\tthis.isExpanded = false;\r\n\t\t\tthis.labelNode.setAttribute(\"aria-expanded\", \"false\");\r\n\t\t\tif(this == this.tree.rootNode && this.tree.showRoot){\r\n\t\t\t\tthis.tree.domNode.setAttribute(\"aria-expanded\", \"false\");\r\n\t\t\t}\r\n\t\t\tdomClass.remove(this.contentNode, 'dijitTreeContentExpanded');\r\n\t\t\tthis._setExpando();\r\n\t\t\tthis._updateItemClasses(this.item);\r\n\r\n\t\t\tvar wipeOut = fxUtils.wipeOut({\r\n\t\t\t\tnode: this.containerNode,\r\n\t\t\t\tduration: manager.defaultDuration\r\n\t\t\t});\r\n\r\n\t\t\t// Deferred that fires when expand is complete\r\n\t\t\tvar def = (this._collapseDeferred = new Deferred(function(){\r\n\t\t\t\t// Canceller\r\n\t\t\t\twipeOut.stop();\r\n\t\t\t}));\r\n\r\n\t\t\taspect.after(wipeOut, \"onEnd\", function(){\r\n\t\t\t\tdef.resolve(true);\r\n\t\t\t}, true);\r\n\r\n\t\t\twipeOut.play();\r\n\r\n\t\t\treturn shimmedPromise(def);\t\t// dojo/promise/Promise\r\n\t\t},\r\n\r\n\t\t// indent: Integer\r\n\t\t//\t\tLevels from this node to the root node\r\n\t\tindent: 0,\r\n\r\n\t\tsetChildItems: function(/* Object[] */ items){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSets the child items of this node, removing/adding nodes\r\n\t\t\t//\t\tfrom current children to match specified items[] array.\r\n\t\t\t//\t\tAlso, if this.persist == true, expands any children that were previously\r\n\t\t\t//\t\topened.\r\n\t\t\t// returns:\r\n\t\t\t//\t\tPromise that resolves after all previously opened children\r\n\t\t\t//\t\thave been expanded again (or fires instantly if there are no such children).\r\n\r\n\t\t\tvar tree = this.tree,\r\n\t\t\t\tmodel = tree.model,\r\n\t\t\t\tdefs = [];\t// list of deferreds that need to fire before I am complete\r\n\r\n\r\n\t\t\tvar focusedChild = tree.focusedChild;\r\n\r\n\t\t\t// Orphan all my existing children.\r\n\t\t\t// If items contains some of the same items as before then we will reattach them.\r\n\t\t\t// Don't call this.removeChild() because that will collapse the tree etc.\r\n\t\t\tvar oldChildren = this.getChildren();\r\n\t\t\tarray.forEach(oldChildren, function(child){\r\n\t\t\t\t_Container.prototype.removeChild.call(this, child);\r\n\t\t\t}, this);\r\n\r\n\t\t\t// All the old children of this TreeNode are subject for destruction if\r\n\t\t\t//\t\t1) they aren't listed in the new children array (items)\r\n\t\t\t//\t\t2) they aren't immediately adopted by another node (DnD)\r\n\t\t\tthis.defer(function(){\r\n\t\t\t\tarray.forEach(oldChildren, function(node){\r\n\t\t\t\t\tif(!node._destroyed && !node.getParent()){\r\n\t\t\t\t\t\t// If node is in selection then remove it.\r\n\t\t\t\t\t\ttree.dndController.removeTreeNode(node);\r\n\r\n\t\t\t\t\t\t// Deregister mapping from item id --> this node and its descendants\r\n\t\t\t\t\t\tfunction remove(node){\r\n\t\t\t\t\t\t\tvar id = model.getIdentity(node.item),\r\n\t\t\t\t\t\t\t\tary = tree._itemNodesMap[id];\r\n\t\t\t\t\t\t\tif(ary.length == 1){\r\n\t\t\t\t\t\t\t\tdelete tree._itemNodesMap[id];\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\tvar index = array.indexOf(ary, node);\r\n\t\t\t\t\t\t\t\tif(index != -1){\r\n\t\t\t\t\t\t\t\t\tary.splice(index, 1);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tarray.forEach(node.getChildren(), remove);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tremove(node);\r\n\r\n\t\t\t\t\t\t// Remove any entries involving this node from cookie tracking expanded nodes\r\n\t\t\t\t\t\tif(tree.persist){\r\n\t\t\t\t\t\t\tvar destroyedPath = array.map(node.getTreePath(),function(item){\r\n\t\t\t\t\t\t\t\treturn tree.model.getIdentity(item);\r\n\t\t\t\t\t\t\t}).join(\"/\");\r\n\t\t\t\t\t\t\tfor(var path in tree._openedNodes){\r\n\t\t\t\t\t\t\t\tif(path.substr(0, destroyedPath.length) == destroyedPath){\r\n\t\t\t\t\t\t\t\t\tdelete tree._openedNodes[path];\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttree._saveExpandedNodes();\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// If we've orphaned the focused node then move focus to the root node\r\n\t\t\t\t\t\tif(tree.lastFocusedChild && !dom.isDescendant(tree.lastFocusedChild, tree.domNode)){\r\n\t\t\t\t\t\t\tdelete tree.lastFocusedChild;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(focusedChild && !dom.isDescendant(focusedChild, tree.domNode)){\r\n\t\t\t\t\t\t\ttree.focus();\t// could alternately focus this node (parent of the deleted node)\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// And finally we can destroy the node\r\n\t\t\t\t\t\tnode.destroyRecursive();\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t});\r\n\r\n\t\t\tthis.state = \"Loaded\";\r\n\r\n\t\t\tif(items && items.length > 0){\r\n\t\t\t\tthis.isExpandable = true;\r\n\r\n\t\t\t\t// Create _TreeNode widget for each specified tree node, unless one already\r\n\t\t\t\t// exists and isn't being used (presumably it's from a DnD move and was recently\r\n\t\t\t\t// released\r\n\t\t\t\tarray.forEach(items, function(item){    // MARKER: REUSE NODE\r\n\t\t\t\t\tvar id = model.getIdentity(item),\r\n\t\t\t\t\t\texistingNodes = tree._itemNodesMap[id],\r\n\t\t\t\t\t\tnode;\r\n\t\t\t\t\tif(existingNodes){\r\n\t\t\t\t\t\tfor(var i = 0; i < existingNodes.length; i++){\r\n\t\t\t\t\t\t\tif(existingNodes[i] && !existingNodes[i].getParent()){\r\n\t\t\t\t\t\t\t\tnode = existingNodes[i];\r\n\t\t\t\t\t\t\t\tnode.set('indent', this.indent + 1);\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(!node){\r\n\t\t\t\t\t\tnode = this.tree._createTreeNode({\r\n\t\t\t\t\t\t\titem: item,\r\n\t\t\t\t\t\t\ttree: tree,\r\n\t\t\t\t\t\t\tisExpandable: model.mayHaveChildren(item),\r\n\t\t\t\t\t\t\tlabel: tree.getLabel(item),\r\n\t\t\t\t\t\t\tlabelType: (tree.model && tree.model.labelType) || \"text\",\r\n\t\t\t\t\t\t\ttooltip: tree.getTooltip(item),\r\n\t\t\t\t\t\t\townerDocument: tree.ownerDocument,\r\n\t\t\t\t\t\t\tdir: tree.dir,\r\n\t\t\t\t\t\t\tlang: tree.lang,\r\n\t\t\t\t\t\t\ttextDir: tree.textDir,\r\n\t\t\t\t\t\t\tindent: this.indent + 1\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tif(existingNodes){\r\n\t\t\t\t\t\t\texistingNodes.push(node);\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\ttree._itemNodesMap[id] = [node];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.addChild(node);\r\n\r\n\t\t\t\t\t// If node was previously opened then open it again now (this may trigger\r\n\t\t\t\t\t// more data store accesses, recursively)\r\n\t\t\t\t\tif(this.tree.autoExpand || this.tree._state(node)){\r\n\t\t\t\t\t\tdefs.push(tree._expandNode(node));\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this);\r\n\r\n\t\t\t\t// note that updateLayout() needs to be called on each child after\r\n\t\t\t\t// _all_ the children exist\r\n\t\t\t\tarray.forEach(this.getChildren(), function(child){\r\n\t\t\t\t\tchild._updateLayout();\r\n\t\t\t\t});\r\n\t\t\t}else{\r\n\t\t\t\tthis.isExpandable = false;\r\n\t\t\t}\r\n\r\n\t\t\tif(this._setExpando){\r\n\t\t\t\t// change expando to/from dot or + icon, as appropriate\r\n\t\t\t\tthis._setExpando(false);\r\n\t\t\t}\r\n\r\n\t\t\t// Set leaf icon or folder icon, as appropriate\r\n\t\t\tthis._updateItemClasses(this.item);\r\n\r\n\t\t\tvar def = all(defs);\r\n\t\t\tthis.tree._startPaint(def);\t\t// to reset TreeNode widths after an item is added/removed from the Tree\r\n\t\t\treturn shimmedPromise(def);\t\t// dojo/promise/Promise\r\n\t\t},\r\n\r\n\t\tgetTreePath: function(){\r\n\t\t\tvar node = this;\r\n\t\t\tvar path = [];\r\n\t\t\twhile(node && node !== this.tree.rootNode){\r\n\t\t\t\tpath.unshift(node.item);\r\n\t\t\t\tnode = node.getParent();\r\n\t\t\t}\r\n\t\t\tpath.unshift(this.tree.rootNode.item);\r\n\r\n\t\t\treturn path;\r\n\t\t},\r\n\r\n\t\tgetIdentity: function(){\r\n\t\t\treturn this.tree.model.getIdentity(this.item);\r\n\t\t},\r\n\r\n\t\tremoveChild: function(/* treeNode */ node){\r\n\t\t\tthis.inherited(arguments);\r\n\r\n\t\t\tvar children = this.getChildren();\r\n\t\t\tif(children.length == 0){\r\n\t\t\t\tthis.isExpandable = false;\r\n\t\t\t\tthis.collapse();\r\n\t\t\t}\r\n\r\n\t\t\tarray.forEach(children, function(child){\r\n\t\t\t\tchild._updateLayout();\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\tmakeExpandable: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tif this node wasn't already showing the expando node,\r\n\t\t\t//\t\tturn it into one and call _setExpando()\r\n\r\n\t\t\t// TODO: hmm this isn't called from anywhere, maybe should remove it for 2.0\r\n\r\n\t\t\tthis.isExpandable = true;\r\n\t\t\tthis._setExpando(false);\r\n\t\t},\r\n\r\n\t\tsetSelected: function(/*Boolean*/ selected){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tA Tree has a (single) currently selected node.\r\n\t\t\t//\t\tMark that this node is/isn't that currently selected node.\r\n\t\t\t// description:\r\n\t\t\t//\t\tIn particular, setting a node as selected involves setting tabIndex\r\n\t\t\t//\t\tso that when user tabs to the tree, focus will go to that node (only).\r\n\t\t\tthis.labelNode.setAttribute(\"aria-selected\", selected ? \"true\" : \"false\");\r\n\t\t\tdomClass.toggle(this.rowNode, \"dijitTreeRowSelected\", selected);\r\n\t\t},\r\n\r\n\t\tfocus: function(){\r\n\t\t\tfocus.focus(this.focusNode);\r\n\t\t}\r\n\t});\r\n\r\n\tif(has(\"dojo-bidi\")){\r\n\t\tTreeNode.extend({\r\n\t\t\t_setTextDirAttr: function(textDir){\r\n\t\t\t\tif(textDir && ((this.textDir != textDir) || !this._created)){\r\n\t\t\t\t\tthis._set(\"textDir\", textDir);\r\n\t\t\t\t\tthis.applyTextDir(this.labelNode);\r\n\t\t\t\t\tarray.forEach(this.getChildren(), function(childNode){\r\n\t\t\t\t\t\tchildNode.set(\"textDir\", textDir);\r\n\t\t\t\t\t}, this);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tvar Tree = declare(\"dijit.Tree\", [_Widget, _KeyNavMixin, _TemplatedMixin, _CssStateMixin], {\r\n\t\t// summary:\r\n\t\t//\t\tThis widget displays hierarchical data from a store.\r\n\r\n\t\tbaseClass: \"dijitTree\",\r\n\r\n\t\t// store: [deprecated] String|dojo/data/Store\r\n\t\t//\t\tDeprecated.  Use \"model\" parameter instead.\r\n\t\t//\t\tThe store to get data to display in the tree.\r\n\t\tstore: null,\r\n\r\n\t\t// model: [const] dijit/tree/model\r\n\t\t//\t\tInterface to read tree data, get notifications of changes to tree data,\r\n\t\t//\t\tand for handling drop operations (i.e drag and drop onto the tree)\r\n\t\tmodel: null,\r\n\r\n\t\t// query: [deprecated] anything\r\n\t\t//\t\tDeprecated.  User should specify query to the model directly instead.\r\n\t\t//\t\tSpecifies datastore query to return the root item or top items for the tree.\r\n\t\tquery: null,\r\n\r\n\t\t// label: [deprecated] String\r\n\t\t//\t\tDeprecated.  Use dijit/tree/ForestStoreModel directly instead.\r\n\t\t//\t\tUsed in conjunction with query parameter.\r\n\t\t//\t\tIf a query is specified (rather than a root node id), and a label is also specified,\r\n\t\t//\t\tthen a fake root node is created and displayed, with this label.\r\n\t\tlabel: \"\",\r\n\r\n\t\t// showRoot: [const] Boolean\r\n\t\t//\t\tShould the root node be displayed, or hidden?\r\n\t\tshowRoot: true,\r\n\r\n\t\t// childrenAttr: [deprecated] String[]\r\n\t\t//\t\tDeprecated.   This information should be specified in the model.\r\n\t\t//\t\tOne ore more attributes that holds children of a tree node\r\n\t\tchildrenAttr: [\"children\"],\r\n\r\n\t\t// paths: String[][] or Item[][]\r\n\t\t//\t\tFull paths from rootNode to selected nodes expressed as array of items or array of ids.\r\n\t\t//\t\tSince setting the paths may be asynchronous (because of waiting on dojo.data), set(\"paths\", ...)\r\n\t\t//\t\treturns a Promise to indicate when the set is complete.\r\n\t\tpaths: [],\r\n\r\n\t\t// path: String[] or Item[]\r\n\t\t//\t\tBackward compatible singular variant of paths.\r\n\t\tpath: [],\r\n\r\n\t\t// selectedItems: [readonly] Item[]\r\n\t\t//\t\tThe currently selected items in this tree.\r\n\t\t//\t\tThis property can only be set (via set('selectedItems', ...)) when that item is already\r\n\t\t//\t\tvisible in the tree.   (I.e. the tree has already been expanded to show that node.)\r\n\t\t//\t\tShould generally use `paths` attribute to set the selected items instead.\r\n\t\tselectedItems: null,\r\n\r\n\t\t// selectedItem: [readonly] Item\r\n\t\t//\t\tBackward compatible singular variant of selectedItems.\r\n\t\tselectedItem: null,\r\n\r\n\t\t// openOnClick: Boolean\r\n\t\t//\t\tIf true, clicking a folder node's label will open it, rather than calling onClick()\r\n\t\topenOnClick: false,\r\n\r\n\t\t// openOnDblClick: Boolean\r\n\t\t//\t\tIf true, double-clicking a folder node's label will open it, rather than calling onDblClick()\r\n\t\topenOnDblClick: false,\r\n\r\n\t\ttemplateString: treeTemplate,\r\n\r\n\t\t// persist: Boolean\r\n\t\t//\t\tEnables/disables use of cookies for state saving.\r\n\t\tpersist: false,\r\n\r\n\t\t// autoExpand: Boolean\r\n\t\t//\t\tFully expand the tree on load.   Overrides `persist`.\r\n\t\tautoExpand: false,\r\n\r\n\t\t// dndController: [protected] Function|String\r\n\t\t//\t\tClass to use as as the dnd controller.  Specifying this class enables DnD.\r\n\t\t//\t\tGenerally you should specify this as dijit/tree/dndSource.\r\n\t\t//\t\tSetting of dijit/tree/_dndSelector handles selection only (no actual DnD).\r\n\t\tdndController: _dndSelector,\r\n\r\n\t\t// parameters to pull off of the tree and pass on to the dndController as its params\r\n\t\tdndParams: [\"onDndDrop\", \"itemCreator\", \"onDndCancel\", \"checkAcceptance\", \"checkItemAcceptance\", \"dragThreshold\", \"betweenThreshold\"],\r\n\r\n\t\t//declare the above items so they can be pulled from the tree's markup\r\n\r\n\t\t// onDndDrop: [protected] Function\r\n\t\t//\t\tParameter to dndController, see `dijit/tree/dndSource.onDndDrop()`.\r\n\t\t//\t\tGenerally this doesn't need to be set.\r\n\t\tonDndDrop: null,\r\n\r\n\t\titemCreator: null,\r\n\t\t/*=====\r\n\t\titemCreator: function(nodes, target, source){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns objects passed to `Tree.model.newItem()` based on DnD nodes\r\n\t\t\t//\t\tdropped onto the tree.   Developer must override this method to enable\r\n\t\t\t//\t\tdropping from external sources onto this Tree, unless the Tree.model's items\r\n\t\t\t//\t\thappen to look like {id: 123, name: \"Apple\" } with no other attributes.\r\n\t\t\t//\r\n\t\t\t//\t\tFor each node in nodes[], which came from source, create a hash of name/value\r\n\t\t\t//\t\tpairs to be passed to Tree.model.newItem().  Returns array of those hashes.\r\n\t\t\t// nodes: DomNode[]\r\n\t\t\t//\t\tThe DOMNodes dragged from the source container\r\n\t\t\t// target: DomNode\r\n\t\t\t//\t\tThe target TreeNode.rowNode\r\n\t\t\t// source: dojo/dnd/Source\r\n\t\t\t//\t\tThe source container the nodes were dragged from, perhaps another Tree or a plain dojo/dnd/Source\r\n\t\t\t// returns: Object[]\r\n\t\t\t//\t\tArray of name/value hashes for each new item to be added to the Tree, like:\r\n\t\t\t// |\t[\r\n\t\t\t// |\t\t{ id: 123, label: \"apple\", foo: \"bar\" },\r\n\t\t\t// |\t\t{ id: 456, label: \"pear\", zaz: \"bam\" }\r\n\t\t\t// |\t]\r\n\t\t\t// tags:\r\n\t\t\t//\t\textension\r\n\t\t\treturn [{}];\r\n\t\t},\r\n\t\t=====*/\r\n\r\n\t\t// onDndCancel: [protected] Function\r\n\t\t//\t\tParameter to dndController, see `dijit/tree/dndSource.onDndCancel()`.\r\n\t\t//\t\tGenerally this doesn't need to be set.\r\n\t\tonDndCancel: null,\r\n\r\n\t\t/*=====\r\n\t\tcheckAcceptance: function(source, nodes){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tChecks if the Tree itself can accept nodes from this source\r\n\t\t\t// source: dijit/tree/dndSource\r\n\t\t\t//\t\tThe source which provides items\r\n\t\t\t// nodes: DOMNode[]\r\n\t\t\t//\t\tArray of DOM nodes corresponding to nodes being dropped, dijitTreeRow nodes if\r\n\t\t\t//\t\tsource is a dijit/Tree.\r\n\t\t\t// tags:\r\n\t\t\t//\t\textension\r\n\t\t\treturn true;\t// Boolean\r\n\t\t},\r\n\t\t=====*/\r\n\t\tcheckAcceptance: null,\r\n\r\n\t\t/*=====\r\n\t\tcheckItemAcceptance: function(target, source, position){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tStub function to be overridden if one wants to check for the ability to drop at the node/item level\r\n\t\t\t// description:\r\n\t\t\t//\t\tIn the base case, this is called to check if target can become a child of source.\r\n\t\t\t//\t\tWhen betweenThreshold is set, position=\"before\" or \"after\" means that we\r\n\t\t\t//\t\tare asking if the source node can be dropped before/after the target node.\r\n\t\t\t// target: DOMNode\r\n\t\t\t//\t\tThe dijitTreeRoot DOM node inside of the TreeNode that we are dropping on to\r\n\t\t\t//\t\tUse registry.getEnclosingWidget(target) to get the TreeNode.\r\n\t\t\t// source: dijit/tree/dndSource\r\n\t\t\t//\t\tThe (set of) nodes we are dropping\r\n\t\t\t// position: String\r\n\t\t\t//\t\t\"over\", \"before\", or \"after\"\r\n\t\t\t// tags:\r\n\t\t\t//\t\textension\r\n\t\t\treturn true;\t// Boolean\r\n\t\t},\r\n\t\t=====*/\r\n\t\tcheckItemAcceptance: null,\r\n\r\n\t\t// dragThreshold: Integer\r\n\t\t//\t\tNumber of pixels mouse moves before it's considered the start of a drag operation\r\n\t\tdragThreshold: 5,\r\n\r\n\t\t// betweenThreshold: Integer\r\n\t\t//\t\tSet to a positive value to allow drag and drop \"between\" nodes.\r\n\t\t//\r\n\t\t//\t\tIf during DnD mouse is over a (target) node but less than betweenThreshold\r\n\t\t//\t\tpixels from the bottom edge, dropping the the dragged node will make it\r\n\t\t//\t\tthe next sibling of the target node, rather than the child.\r\n\t\t//\r\n\t\t//\t\tSimilarly, if mouse is over a target node but less that betweenThreshold\r\n\t\t//\t\tpixels from the top edge, dropping the dragged node will make it\r\n\t\t//\t\tthe target node's previous sibling rather than the target node's child.\r\n\t\tbetweenThreshold: 0,\r\n\r\n\t\t// _nodePixelIndent: Integer\r\n\t\t//\t\tNumber of pixels to indent tree nodes (relative to parent node).\r\n\t\t//\t\tDefault is 19 but can be overridden by setting CSS class dijitTreeIndent\r\n\t\t//\t\tand calling resize() or startup() on tree after it's in the DOM.\r\n\t\t_nodePixelIndent: 19,\r\n\r\n\t\t_publish: function(/*String*/ topicName, /*Object*/ message){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tPublish a message for this widget/topic\r\n\t\t\ttopic.publish(this.id, lang.mixin({tree: this, event: topicName}, message || {}));\t// publish\r\n\t\t},\r\n\r\n\t\tpostMixInProperties: function(){\r\n\t\t\tthis.tree = this;\r\n\r\n\t\t\tif(this.autoExpand){\r\n\t\t\t\t// There's little point in saving opened/closed state of nodes for a Tree\r\n\t\t\t\t// that initially opens all it's nodes.\r\n\t\t\t\tthis.persist = false;\r\n\t\t\t}\r\n\r\n\t\t\tthis._itemNodesMap = {};\r\n\r\n\t\t\tif(!this.cookieName && this.id){\r\n\t\t\t\tthis.cookieName = this.id + \"SaveStateCookie\";\r\n\t\t\t}\r\n\r\n\t\t\t// Deferred that resolves when all the children have loaded.\r\n\t\t\tthis.expandChildrenDeferred = new Deferred();\r\n\r\n\t\t\t// Promise that resolves when all pending operations complete.\r\n\t\t\tthis.pendingCommandsPromise = this.expandChildrenDeferred.promise;\r\n\r\n\t\t\tthis.inherited(arguments);\r\n\t\t},\r\n\r\n\t\tpostCreate: function(){\r\n\t\t\tthis._initState();\r\n\r\n\t\t\t// Catch events on TreeNodes\r\n\t\t\tvar self = this;\r\n\t\t\tthis.own(\r\n\t\t\t\ton(this.containerNode, on.selector(\".dijitTreeNode\", touch.enter), function(evt){\r\n\t\t\t\t\tself._onNodeMouseEnter(registry.byNode(this), evt);\r\n\t\t\t\t}),\r\n\t\t\t\ton(this.containerNode, on.selector(\".dijitTreeNode\", touch.leave), function(evt){\r\n\t\t\t\t\tself._onNodeMouseLeave(registry.byNode(this), evt);\r\n\t\t\t\t}),\r\n\t\t\t\ton(this.containerNode, on.selector(\".dijitTreeRow\", a11yclick.press), function(evt){\r\n\t\t\t\t\tself._onNodePress(registry.getEnclosingWidget(this), evt);\r\n\t\t\t\t}),\r\n\t\t\t\ton(this.containerNode, on.selector(\".dijitTreeRow\", a11yclick), function(evt){\r\n\t\t\t\t\tself._onClick(registry.getEnclosingWidget(this), evt);\r\n\t\t\t\t}),\r\n\t\t\t\ton(this.containerNode, on.selector(\".dijitTreeRow\", \"dblclick\"), function(evt){\r\n\t\t\t\t\tself._onDblClick(registry.getEnclosingWidget(this), evt);\r\n\t\t\t\t})\r\n\t\t\t);\r\n\r\n\t\t\t// Create glue between store and Tree, if not specified directly by user\r\n\t\t\tif(!this.model){\r\n\t\t\t\tthis._store2model();\r\n\t\t\t}\r\n\r\n\t\t\t// monitor changes to items\r\n\t\t\tthis.own(\r\n\t\t\t\taspect.after(this.model, \"onChange\", lang.hitch(this, \"_onItemChange\"), true),\r\n\t\t\t\taspect.after(this.model, \"onChildrenChange\", lang.hitch(this, \"_onItemChildrenChange\"), true),\r\n\t\t\t\taspect.after(this.model, \"onDelete\", lang.hitch(this, \"_onItemDelete\"), true)\r\n\t\t\t);\r\n\r\n\t\t\tthis.inherited(arguments);\r\n\r\n\t\t\tif(this.dndController){\r\n\t\t\t\t// TODO: remove string support in 2.0.\r\n\t\t\t\tif(lang.isString(this.dndController)){\r\n\t\t\t\t\tthis.dndController = lang.getObject(this.dndController);\r\n\t\t\t\t}\r\n\t\t\t\tvar params = {};\r\n\t\t\t\tfor(var i = 0; i < this.dndParams.length; i++){\r\n\t\t\t\t\tif(this[this.dndParams[i]]){\r\n\t\t\t\t\t\tparams[this.dndParams[i]] = this[this.dndParams[i]];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthis.dndController = new this.dndController(this, params);\r\n\t\t\t}\r\n\r\n\t\t\tthis._load();\r\n\r\n\t\t\t// onLoadDeferred should fire when all commands that are part of initialization have completed.\r\n\t\t\t// It will include all the set(\"paths\", ...) commands that happen during initialization.\r\n\t\t\tthis.onLoadDeferred = shimmedPromise(this.pendingCommandsPromise);\r\n\r\n\t\t\tthis.onLoadDeferred.then(lang.hitch(this, \"onLoad\"));\r\n\t\t},\r\n\r\n\t\t_store2model: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tUser specified a store&query rather than model, so create model from store/query\r\n\t\t\tthis._v10Compat = true;\r\n\t\t\tkernel.deprecated(\"Tree: from version 2.0, should specify a model object rather than a store/query\");\r\n\r\n\t\t\tvar modelParams = {\r\n\t\t\t\tid: this.id + \"_ForestStoreModel\",\r\n\t\t\t\tstore: this.store,\r\n\t\t\t\tquery: this.query,\r\n\t\t\t\tchildrenAttrs: this.childrenAttr\r\n\t\t\t};\r\n\r\n\t\t\t// Only override the model's mayHaveChildren() method if the user has specified an override\r\n\t\t\tif(this.params.mayHaveChildren){\r\n\t\t\t\tmodelParams.mayHaveChildren = lang.hitch(this, \"mayHaveChildren\");\r\n\t\t\t}\r\n\r\n\t\t\tif(this.params.getItemChildren){\r\n\t\t\t\tmodelParams.getChildren = lang.hitch(this, function(item, onComplete, onError){\r\n\t\t\t\t\tthis.getItemChildren((this._v10Compat && item === this.model.root) ? null : item, onComplete, onError);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tthis.model = new ForestStoreModel(modelParams);\r\n\r\n\t\t\t// For backwards compatibility, the visibility of the root node is controlled by\r\n\t\t\t// whether or not the user has specified a label\r\n\t\t\tthis.showRoot = Boolean(this.label);\r\n\t\t},\r\n\r\n\t\tonLoad: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCalled when tree finishes loading and expanding.\r\n\t\t\t// description:\r\n\t\t\t//\t\tIf persist == true the loading may encompass many levels of fetches\r\n\t\t\t//\t\tfrom the data store, each asynchronous.   Waits for all to finish.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tcallback\r\n\t\t},\r\n\r\n\t\t_load: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tInitial load of the tree.\r\n\t\t\t//\t\tLoad root node (possibly hidden) and it's children.\r\n\t\t\tthis.model.getRoot(\r\n\t\t\t\tlang.hitch(this, function(item){\r\n\t\t\t\t\tvar rn = (this.rootNode = this.tree._createTreeNode({\r\n\t\t\t\t\t\titem: item,\r\n\t\t\t\t\t\ttree: this,\r\n\t\t\t\t\t\tisExpandable: true,\r\n\t\t\t\t\t\tlabel: this.label || this.getLabel(item),\r\n\t\t\t\t\t\tlabelType: this.model.labelType || \"text\",\r\n\t\t\t\t\t\ttextDir: this.textDir,\r\n\t\t\t\t\t\tindent: this.showRoot ? 0 : -1\r\n\t\t\t\t\t}));\r\n\r\n\t\t\t\t\tif(!this.showRoot){\r\n\t\t\t\t\t\trn.rowNode.style.display = \"none\";\r\n\t\t\t\t\t\t// if root is not visible, move tree role to the invisible\r\n\t\t\t\t\t\t// root node's containerNode, see #12135\r\n\t\t\t\t\t\tthis.domNode.setAttribute(\"role\", \"presentation\");\r\n\t\t\t\t\t\tthis.domNode.removeAttribute(\"aria-expanded\");\r\n\t\t\t\t\t\tthis.domNode.removeAttribute(\"aria-multiselectable\");\r\n\r\n\t\t\t\t\t\t// move the aria-label or aria-labelledby to the element with the role\r\n\t\t\t\t\t\tif(this[\"aria-label\"]){\r\n\t\t\t\t\t\t\trn.containerNode.setAttribute(\"aria-label\", this[\"aria-label\"]);\r\n\t\t\t\t\t\t\tthis.domNode.removeAttribute(\"aria-label\");\r\n\t\t\t\t\t\t}else if(this[\"aria-labelledby\"]){\r\n\t\t\t\t\t\t\trn.containerNode.setAttribute(\"aria-labelledby\", this[\"aria-labelledby\"]);\r\n\t\t\t\t\t\t\tthis.domNode.removeAttribute(\"aria-labelledby\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\trn.labelNode.setAttribute(\"role\", \"presentation\");\r\n\t\t\t\t\t\trn.containerNode.setAttribute(\"role\", \"tree\");\r\n\t\t\t\t\t\trn.containerNode.setAttribute(\"aria-expanded\", \"true\");\r\n\t\t\t\t\t\trn.containerNode.setAttribute(\"aria-multiselectable\", !this.dndController.singular);\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tthis.domNode.setAttribute(\"aria-multiselectable\", !this.dndController.singular);\r\n\t\t\t\t\t\tthis.rootLoadingIndicator.style.display = \"none\";\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis.containerNode.appendChild(rn.domNode);\r\n\t\t\t\t\tvar identity = this.model.getIdentity(item);\r\n\t\t\t\t\tif(this._itemNodesMap[identity]){\r\n\t\t\t\t\t\tthis._itemNodesMap[identity].push(rn);\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tthis._itemNodesMap[identity] = [rn];\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\trn._updateLayout();\t\t// sets \"dijitTreeIsRoot\" CSS classname\r\n\r\n\t\t\t\t\t// Load top level children, and if persist==true, all nodes that were previously opened\r\n\t\t\t\t\tthis._expandNode(rn).then(lang.hitch(this, function(){\r\n\t\t\t\t\t\t// Then, select the nodes specified by params.paths[], assuming Tree hasn't been deleted.\r\n\t\t\t\t\t\tif(!this._destroyed){\r\n\t\t\t\t\t\t\tthis.rootLoadingIndicator.style.display = \"none\";\r\n\t\t\t\t\t\t\tthis.expandChildrenDeferred.resolve(true);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}));\r\n\t\t\t\t}),\r\n\t\t\t\tlang.hitch(this, function(err){\r\n\t\t\t\t\tconsole.error(this, \": error loading root: \", err);\r\n\t\t\t\t})\r\n\t\t\t);\r\n\t\t},\r\n\r\n\t\tgetNodesByItem: function(/*Item or id*/ item){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns all tree nodes that refer to an item\r\n\t\t\t// returns:\r\n\t\t\t//\t\tArray of tree nodes that refer to passed item\r\n\r\n\t\t\tif(!item){\r\n\t\t\t\treturn [];\r\n\t\t\t}\r\n\t\t\tvar identity = lang.isString(item) ? item : this.model.getIdentity(item);\r\n\t\t\t// return a copy so widget don't get messed up by changes to returned array\r\n\t\t\treturn [].concat(this._itemNodesMap[identity]);\r\n\t\t},\r\n\r\n\t\t_setSelectedItemAttr: function(/*Item or id*/ item){\r\n\t\t\tthis.set('selectedItems', [item]);\r\n\t\t},\r\n\r\n\t\t_setSelectedItemsAttr: function(/*Items or ids*/ items){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSelect tree nodes related to passed items.\r\n\t\t\t//\t\tWARNING: if model use multi-parented items or desired tree node isn't already loaded\r\n\t\t\t//\t\tbehavior is undefined. Use set('paths', ...) instead.\r\n\t\t\tvar tree = this;\r\n\t\t\treturn this.pendingCommandsPromise = this.pendingCommandsPromise.always(lang.hitch(this, function(){\r\n\t\t\t\tvar identities = array.map(items, function(item){\r\n\t\t\t\t\treturn (!item || lang.isString(item)) ? item : tree.model.getIdentity(item);\r\n\t\t\t\t});\r\n\t\t\t\tvar nodes = [];\r\n\t\t\t\tarray.forEach(identities, function(id){\r\n\t\t\t\t\tnodes = nodes.concat(tree._itemNodesMap[id] || []);\r\n\t\t\t\t});\r\n\t\t\t\tthis.set('selectedNodes', nodes);\r\n\t\t\t}));\r\n\t\t},\r\n\r\n\t\t_setPathAttr: function(/*Item[]|String[]*/ path){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSingular variant of _setPathsAttr\r\n\t\t\tif(path.length){\r\n\t\t\t\treturn shimmedPromise(this.set(\"paths\", [path]).then(function(paths){ return paths[0]; }));\r\n\t\t\t}else{\r\n\t\t\t\t// Empty list is interpreted as \"select nothing\"\r\n\t\t\t\treturn shimmedPromise(this.set(\"paths\", []).then(function(paths){ return paths[0]; }));\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_setPathsAttr: function(/*Item[][]|String[][]*/ paths){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSelect the tree nodes identified by passed paths.\r\n\t\t\t// paths:\r\n\t\t\t//\t\tArray of arrays of items or item id's\r\n\t\t\t// returns:\r\n\t\t\t//\t\tPromise to indicate when the set is complete\r\n\r\n\t\t\tvar tree = this;\r\n\r\n\t\t\tfunction selectPath(path, nodes){\r\n\t\t\t\t// Traverse path, returning Promise for node at the end of the path.\r\n\t\t\t\t// The next path component should be among \"nodes\".\r\n\t\t\t\tvar nextPath = path.shift();\r\n\t\t\t\tvar nextNode = array.filter(nodes, function(node){\r\n\t\t\t\t\treturn node.getIdentity() == nextPath;\r\n\t\t\t\t})[0];\r\n\t\t\t\tif(!!nextNode){\r\n\t\t\t\t\tif(path.length){\r\n\t\t\t\t\t\treturn tree._expandNode(nextNode).then(function(){\r\n\t\t\t\t\t\t\treturn selectPath(path, nextNode.getChildren());\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\t// Successfully reached the end of this path\r\n\t\t\t\t\t\treturn nextNode;\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthrow new Tree.PathError(\"Could not expand path at \" + nextPath);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Let any previous set(\"path\", ...) commands complete before this one starts.\r\n\t\t\t// TODO for 2.0: make the user do this wait themselves?\r\n\t\t\treturn shimmedPromise(this.pendingCommandsPromise = this.pendingCommandsPromise.always(function(){\r\n\t\t\t\t// We may need to wait for some nodes to expand, so setting\r\n\t\t\t\t// each path will involve a Deferred. We bring those deferreds\r\n\t\t\t\t// together with a dojo/promise/all.\r\n\t\t\t\treturn all(array.map(paths, function(path){\r\n\t\t\t\t\t// normalize path to use identity\r\n\t\t\t\t\tpath = array.map(path, function(item){\r\n\t\t\t\t\t\treturn lang.isString(item) ? item : tree.model.getIdentity(item);\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\tif(path.length){\r\n\t\t\t\t\t\treturn selectPath(path, [tree.rootNode]);\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tthrow new Tree.PathError(\"Empty path\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}));\r\n\t\t\t}).then(function setNodes(newNodes){\r\n\t\t\t\t// After all expansion is finished, set the selection to last element from each path\r\n\t\t\t\ttree.set(\"selectedNodes\", newNodes);\r\n\t\t\t\treturn tree.paths;\r\n\t\t\t}));\r\n\t\t},\r\n\r\n\t\t_setSelectedNodeAttr: function(node){\r\n\t\t\tthis.set('selectedNodes', [node]);\r\n\t\t},\r\n\t\t_setSelectedNodesAttr: function(nodes){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tMarks the specified TreeNodes as selected.\r\n\t\t\t// nodes: TreeNode[]\r\n\t\t\t//\t\tTreeNodes to mark.\r\n\t\t\tthis.dndController.setSelection(nodes);\r\n\t\t},\r\n\r\n\r\n\t\texpandAll: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tExpand all nodes in the tree\r\n\t\t\t// returns:\r\n\t\t\t//\t\tPromise that resolves when all nodes have expanded\r\n\r\n\t\t\tvar _this = this;\r\n\r\n\t\t\tfunction expand(node){\r\n\t\t\t\t// Expand the node\r\n\t\t\t\treturn _this._expandNode(node).then(function(){\r\n\t\t\t\t\t// When node has expanded, call expand() recursively on each non-leaf child\r\n\t\t\t\t\tvar childBranches = array.filter(node.getChildren() || [], function(node){\r\n\t\t\t\t\t\treturn node.isExpandable;\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\t// And when all those recursive calls finish, signal that I'm finished\r\n\t\t\t\t\treturn all(array.map(childBranches, expand));\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\treturn shimmedPromise(expand(this.rootNode));\r\n\t\t},\r\n\r\n\t\tcollapseAll: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCollapse all nodes in the tree\r\n\t\t\t// returns:\r\n\t\t\t//\t\tPromise that resolves when all nodes have collapsed\r\n\r\n\t\t\tvar _this = this;\r\n\r\n\t\t\tfunction collapse(node){\r\n\t\t\t\t// Collapse children first\r\n\t\t\t\tvar childBranches = array.filter(node.getChildren() || [], function(node){\r\n\t\t\t\t\t\treturn node.isExpandable;\r\n\t\t\t\t\t}),\r\n\t\t\t\t\tdefs = all(array.map(childBranches, collapse));\r\n\r\n\t\t\t\t// And when all those recursive calls finish, collapse myself, unless I'm the invisible root node,\r\n\t\t\t\t// in which case collapseAll() is finished\r\n\t\t\t\tif(!node.isExpanded || (node == _this.rootNode && !_this.showRoot)){\r\n\t\t\t\t\treturn defs;\r\n\t\t\t\t}else{\r\n\t\t\t\t\t// When node has collapsed, signal that call is finished\r\n\t\t\t\t\treturn defs.then(function(){\r\n\t\t\t\t\t\treturn _this._collapseNode(node);\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn shimmedPromise(collapse(this.rootNode));\r\n\t\t},\r\n\r\n\t\t////////////// Data store related functions //////////////////////\r\n\t\t// These just get passed to the model; they are here for back-compat\r\n\r\n\t\tmayHaveChildren: function(/*dojo/data/Item*/ /*===== item =====*/){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tDeprecated.   This should be specified on the model itself.\r\n\t\t\t//\r\n\t\t\t//\t\tOverridable function to tell if an item has or may have children.\r\n\t\t\t//\t\tControls whether or not +/- expando icon is shown.\r\n\t\t\t//\t\t(For efficiency reasons we may not want to check if an element actually\r\n\t\t\t//\t\thas children until user clicks the expando node)\r\n\t\t\t// tags:\r\n\t\t\t//\t\tdeprecated\r\n\t\t},\r\n\r\n\t\tgetItemChildren: function(/*===== parentItem, onComplete =====*/){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tDeprecated.   This should be specified on the model itself.\r\n\t\t\t//\r\n\t\t\t//\t\tOverridable function that return array of child items of given parent item,\r\n\t\t\t//\t\tor if parentItem==null then return top items in tree\r\n\t\t\t// tags:\r\n\t\t\t//\t\tdeprecated\r\n\t\t},\r\n\r\n\t\t///////////////////////////////////////////////////////\r\n\t\t// Functions for converting an item to a TreeNode\r\n\t\tgetLabel: function(/*dojo/data/Item*/ item){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tOverridable function to get the label for a tree node (given the item)\r\n\t\t\t// tags:\r\n\t\t\t//\t\textension\r\n\t\t\treturn this.model.getLabel(item);\t// String\r\n\t\t},\r\n\r\n\t\tgetIconClass: function(/*dojo/data/Item*/ item, /*Boolean*/ opened){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tOverridable function to return CSS class name to display icon\r\n\t\t\t// tags:\r\n\t\t\t//\t\textension\r\n\t\t\treturn (!item || this.model.mayHaveChildren(item)) ? (opened ? \"dijitFolderOpened\" : \"dijitFolderClosed\") : \"dijitLeaf\"\r\n\t\t},\r\n\r\n\t\tgetLabelClass: function(/*===== item, opened =====*/){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tOverridable function to return CSS class name to display label\r\n\t\t\t// item: dojo/data/Item\r\n\t\t\t// opened: Boolean\r\n\t\t\t// returns: String\r\n\t\t\t//\t\tCSS class name\r\n\t\t\t// tags:\r\n\t\t\t//\t\textension\r\n\t\t},\r\n\r\n\t\tgetRowClass: function(/*===== item, opened =====*/){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tOverridable function to return CSS class name to display row\r\n\t\t\t// item: dojo/data/Item\r\n\t\t\t// opened: Boolean\r\n\t\t\t// returns: String\r\n\t\t\t//\t\tCSS class name\r\n\t\t\t// tags:\r\n\t\t\t//\t\textension\r\n\t\t},\r\n\r\n\t\tgetIconStyle: function(/*===== item, opened =====*/){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tOverridable function to return CSS styles to display icon\r\n\t\t\t// item: dojo/data/Item\r\n\t\t\t// opened: Boolean\r\n\t\t\t// returns: Object\r\n\t\t\t//\t\tObject suitable for input to dojo.style() like {backgroundImage: \"url(...)\"}\r\n\t\t\t// tags:\r\n\t\t\t//\t\textension\r\n\t\t},\r\n\r\n\t\tgetLabelStyle: function(/*===== item, opened =====*/){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tOverridable function to return CSS styles to display label\r\n\t\t\t// item: dojo/data/Item\r\n\t\t\t// opened: Boolean\r\n\t\t\t// returns:\r\n\t\t\t//\t\tObject suitable for input to dojo.style() like {color: \"red\", background: \"green\"}\r\n\t\t\t// tags:\r\n\t\t\t//\t\textension\r\n\t\t},\r\n\r\n\t\tgetRowStyle: function(/*===== item, opened =====*/){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tOverridable function to return CSS styles to display row\r\n\t\t\t// item: dojo/data/Item\r\n\t\t\t// opened: Boolean\r\n\t\t\t// returns:\r\n\t\t\t//\t\tObject suitable for input to dojo.style() like {background-color: \"#bbb\"}\r\n\t\t\t// tags:\r\n\t\t\t//\t\textension\r\n\t\t},\r\n\r\n\t\tgetTooltip: function(/*dojo/data/Item*/ /*===== item =====*/){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tOverridable function to get the tooltip for a tree node (given the item)\r\n\t\t\t// tags:\r\n\t\t\t//\t\textension\r\n\t\t\treturn \"\";\t// String\r\n\t\t},\r\n\r\n\t\t/////////// Keyboard and Mouse handlers ////////////////////\r\n\r\n\r\n\t\t_onDownArrow: function(/*Event*/ evt, /*TreeNode*/ node){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tdown arrow pressed; get next visible node, set focus there\r\n\r\n\t\t\tvar nextNode = this._getNext(node);\r\n\t\t\tif(nextNode && nextNode.isTreeNode){\r\n\t\t\t\tthis.focusNode(nextNode);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_onUpArrow: function(/*Event*/ evt, /*TreeNode*/ node){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tUp arrow pressed; move to previous visible node\r\n\r\n\t\t\t// if younger siblings\r\n\t\t\tvar previousSibling = node.getPreviousSibling();\r\n\t\t\tif(previousSibling){\r\n\t\t\t\tnode = previousSibling;\r\n\t\t\t\t// if the previous node is expanded, dive in deep\r\n\t\t\t\twhile(node.isExpandable && node.isExpanded && node.hasChildren()){\r\n\t\t\t\t\t// move to the last child\r\n\t\t\t\t\tvar children = node.getChildren();\r\n\t\t\t\t\tnode = children[children.length - 1];\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\t// if this is the first child, return the parent\r\n\t\t\t\t// unless the parent is the root of a tree with a hidden root\r\n\t\t\t\tvar parent = node.getParent();\r\n\t\t\t\tif(!(!this.showRoot && parent === this.rootNode)){\r\n\t\t\t\t\tnode = parent;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif(node && node.isTreeNode){\r\n\t\t\t\tthis.focusNode(node);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_onRightArrow: function(/*Event*/ evt, /*TreeNode*/ node){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tRight arrow pressed; go to child node\r\n\r\n\t\t\t// if not expanded, expand, else move to 1st child\r\n\t\t\tif(node.isExpandable && !node.isExpanded){\r\n\t\t\t\tthis._expandNode(node);\r\n\t\t\t}else if(node.hasChildren()){\r\n\t\t\t\tnode = node.getChildren()[0];\r\n\t\t\t\tif(node && node.isTreeNode){\r\n\t\t\t\t\tthis.focusNode(node);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_onLeftArrow: function(/*Event*/ evt, /*TreeNode*/ node){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tLeft arrow pressed.\r\n\t\t\t//\t\tIf not collapsed, collapse, else move to parent.\r\n\r\n\t\t\tif(node.isExpandable && node.isExpanded){\r\n\t\t\t\tthis._collapseNode(node);\r\n\t\t\t}else{\r\n\t\t\t\tvar parent = node.getParent();\r\n\t\t\t\tif(parent && parent.isTreeNode && !(!this.showRoot && parent === this.rootNode)){\r\n\t\t\t\t\tthis.focusNode(parent);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tfocusLastChild: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tEnd key pressed; go to last visible node.\r\n\r\n\t\t\tvar node = this._getLast();\r\n\t\t\tif(node && node.isTreeNode){\r\n\t\t\t\tthis.focusNode(node);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_getFirst: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns the first child.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tabstract extension\r\n\t\t\treturn this.showRoot ? this.rootNode : this.rootNode.getChildren()[0];\r\n\t\t},\r\n\r\n\t\t_getLast: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns the last descendant.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tabstract extension\r\n\t\t\tvar node = this.rootNode;\r\n\t\t\twhile(node.isExpanded){\r\n\t\t\t\tvar c = node.getChildren();\r\n\t\t\t\tif(!c.length){\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tnode = c[c.length - 1];\r\n\t\t\t}\r\n\t\t\treturn node;\r\n\t\t},\r\n\r\n\t\t// Tree only searches forward so dir parameter is unused\r\n\t\t_getNext: function(node){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns the next descendant, compared to \"child\".\r\n\t\t\t// node: Widget\r\n\t\t\t//\t\tThe current widget\r\n\t\t\t// tags:\r\n\t\t\t//\t\tabstract extension\r\n\r\n\t\t\tif(node.isExpandable && node.isExpanded && node.hasChildren()){\r\n\t\t\t\t// if this is an expanded node, get the first child\r\n\t\t\t\treturn node.getChildren()[0];\t\t// TreeNode\r\n\t\t\t}else{\r\n\t\t\t\t// find a parent node with a sibling\r\n\t\t\t\twhile(node && node.isTreeNode){\r\n\t\t\t\t\tvar returnNode = node.getNextSibling();\r\n\t\t\t\t\tif(returnNode){\r\n\t\t\t\t\t\treturn returnNode;\t\t// TreeNode\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnode = node.getParent();\r\n\t\t\t\t}\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t// Implement _KeyNavContainer.childSelector, to identify which nodes are navigable\r\n\t\tchildSelector: \".dijitTreeRow\",\r\n\r\n\t\tisExpandoNode: function(node, widget){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tcheck whether a dom node is the expandoNode for a particular TreeNode widget\r\n\t\t\treturn dom.isDescendant(node, widget.expandoNode) || dom.isDescendant(node, widget.expandoNodeText);\r\n\t\t},\r\n\r\n\t\t_onNodePress: function(/*TreeNode*/ nodeWidget, /*Event*/ e){\r\n\t\t\t// Touching a node should focus it, even if you touch the expando node or the edges rather than the label.\r\n\t\t\t// Especially important to avoid _KeyNavMixin._onContainerFocus() causing the previously focused TreeNode\r\n\t\t\t// to get focus\r\n\t\t\tthis.focusNode(nodeWidget);\r\n\t\t},\r\n\r\n\t\t__click: function(/*TreeNode*/ nodeWidget, /*Event*/ e, /*Boolean*/doOpen, /*String*/func){\r\n\t\t\tvar domElement = e.target,\r\n\t\t\t\tisExpandoClick = this.isExpandoNode(domElement, nodeWidget);\r\n\r\n\t\t\tif(nodeWidget.isExpandable && (doOpen || isExpandoClick)){\r\n\t\t\t\t// expando node was clicked, or label of a folder node was clicked; open it\r\n\t\t\t\tthis._onExpandoClick({node: nodeWidget});\r\n\t\t\t}else{\r\n\t\t\t\tthis._publish(\"execute\", { item: nodeWidget.item, node: nodeWidget, evt: e });\r\n\t\t\t\tthis[func](nodeWidget.item, nodeWidget, e);\r\n\t\t\t\tthis.focusNode(nodeWidget);\r\n\t\t\t}\r\n\t\t\te.stopPropagation();\r\n\t\t\te.preventDefault();\r\n\t\t},\r\n\t\t_onClick: function(/*TreeNode*/ nodeWidget, /*Event*/ e){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tTranslates click events into commands for the controller to process\r\n\t\t\tthis.__click(nodeWidget, e, this.openOnClick, 'onClick');\r\n\t\t},\r\n\t\t_onDblClick: function(/*TreeNode*/ nodeWidget, /*Event*/ e){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tTranslates double-click events into commands for the controller to process\r\n\t\t\tthis.__click(nodeWidget, e, this.openOnDblClick, 'onDblClick');\r\n\t\t},\r\n\r\n\t\t_onExpandoClick: function(/*Object*/ message){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tUser clicked the +/- icon; expand or collapse my children.\r\n\t\t\tvar node = message.node;\r\n\r\n\t\t\t// If we are collapsing, we might be hiding the currently focused node.\r\n\t\t\t// Also, clicking the expando node might have erased focus from the current node.\r\n\t\t\t// For simplicity's sake just focus on the node with the expando.\r\n\t\t\tthis.focusNode(node);\r\n\r\n\t\t\tif(node.isExpanded){\r\n\t\t\t\tthis._collapseNode(node);\r\n\t\t\t}else{\r\n\t\t\t\tthis._expandNode(node);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tonClick: function(/*===== item, node, evt =====*/){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCallback when a tree node is clicked\r\n\t\t\t// item: Object\r\n\t\t\t//\t\tObject from the dojo/store corresponding to this TreeNode\r\n\t\t\t// node: TreeNode\r\n\t\t\t//\t\tThe TreeNode itself\r\n\t\t\t// evt: Event\r\n\t\t\t//\t\tThe event\r\n\t\t\t// tags:\r\n\t\t\t//\t\tcallback\r\n\t\t},\r\n\t\tonDblClick: function(/*===== item, node, evt =====*/){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCallback when a tree node is double-clicked\r\n\t\t\t// item: Object\r\n\t\t\t//\t\tObject from the dojo/store corresponding to this TreeNode\r\n\t\t\t// node: TreeNode\r\n\t\t\t//\t\tThe TreeNode itself\r\n\t\t\t// evt: Event\r\n\t\t\t//\t\tThe event\r\n\t\t\t// tags:\r\n\t\t\t//\t\tcallback\r\n\t\t},\r\n\t\tonOpen: function(/*===== item, node =====*/){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCallback when a node is opened\r\n\t\t\t// item: dojo/data/Item\r\n\t\t\t// node: TreeNode\r\n\t\t\t// tags:\r\n\t\t\t//\t\tcallback\r\n\t\t},\r\n\t\tonClose: function(/*===== item, node =====*/){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCallback when a node is closed\r\n\t\t\t// item: Object\r\n\t\t\t//\t\tObject from the dojo/store corresponding to this TreeNode\r\n\t\t\t// node: TreeNode\r\n\t\t\t//\t\tThe TreeNode itself\r\n\t\t\t// tags:\r\n\t\t\t//\t\tcallback\r\n\t\t},\r\n\r\n\t\t_getNextNode: function(node){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tGet next visible node\r\n\r\n\t\t\tkernel.deprecated(this.declaredClass + \"::_getNextNode(node) is deprecated. Use _getNext(node) instead.\", \"\", \"2.0\");\r\n\t\t\treturn this._getNext(node);\r\n\t\t},\r\n\r\n\t\t_getRootOrFirstNode: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tGet first visible node\r\n\t\t\tkernel.deprecated(this.declaredClass + \"::_getRootOrFirstNode() is deprecated. Use _getFirst() instead.\", \"\", \"2.0\");\r\n\t\t\treturn this._getFirst();\r\n\t\t},\r\n\r\n\t\t_collapseNode: function(/*TreeNode*/ node){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCalled when the user has requested to collapse the node\r\n\t\t\t// returns:\r\n\t\t\t//\t\tPromise that resolves when the node has finished closing\r\n\r\n\t\t\tif(node._expandNodeDeferred){\r\n\t\t\t\tdelete node._expandNodeDeferred;\r\n\t\t\t}\r\n\r\n\t\t\tif(node.state == \"Loading\"){\r\n\t\t\t\t// ignore clicks while we are in the process of loading data\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif(node.isExpanded){\r\n\t\t\t\tvar ret = node.collapse();\r\n\r\n\t\t\t\tthis.onClose(node.item, node);\r\n\t\t\t\tthis._state(node, false);\r\n\r\n\t\t\t\tthis._startPaint(ret);\t// after this finishes, need to reset widths of TreeNodes\r\n\r\n\t\t\t\treturn ret;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_expandNode: function(/*TreeNode*/ node){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCalled when the user has requested to expand the node\r\n\t\t\t// returns:\r\n\t\t\t//\t\tPromise that resolves when the node is loaded and opened and (if persist=true) all it's descendants\r\n\t\t\t//\t\tthat were previously opened too\r\n\r\n\t\t\tif(node._expandNodeDeferred){\r\n\t\t\t\t// there's already an expand in progress, or completed, so just return\r\n\t\t\t\treturn node._expandNodeDeferred;\t// dojo/Deferred\r\n\t\t\t}\r\n\r\n\t\t\tvar model = this.model,\r\n\t\t\t\titem = node.item,\r\n\t\t\t\t_this = this;\r\n\r\n\t\t\t// Load data if it's not already loaded\r\n\t\t\tif(!node._loadDeferred){\r\n\t\t\t\t// need to load all the children before expanding\r\n\t\t\t\tnode.markProcessing();\r\n\r\n\t\t\t\t// Setup deferred to signal when the load and expand are finished.\r\n\t\t\t\t// Save that deferred in this._expandDeferred as a flag that operation is in progress.\r\n\t\t\t\tnode._loadDeferred = new Deferred();\r\n\r\n\t\t\t\t// Get the children\r\n\t\t\t\tmodel.getChildren(\r\n\t\t\t\t\titem,\r\n\t\t\t\t\tfunction(items){\r\n\t\t\t\t\t\tnode.unmarkProcessing();\r\n\r\n\t\t\t\t\t\t// Display the children and also start expanding any children that were previously expanded\r\n\t\t\t\t\t\t// (if this.persist == true).   The returned Deferred will fire when those expansions finish.\r\n\t\t\t\t\t\tnode.setChildItems(items).then(function(){\r\n\t\t\t\t\t\t\tnode._loadDeferred.resolve(items);\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t},\r\n\t\t\t\t\tfunction(err){\r\n\t\t\t\t\t\tconsole.error(_this, \": error loading \" + node.label + \" children: \", err);\r\n\t\t\t\t\t\tnode._loadDeferred.reject(err);\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\t// Expand the node after data has loaded\r\n\t\t\tvar def = node._loadDeferred.then(lang.hitch(this, function(){\r\n\t\t\t\tvar def2 = node.expand();\r\n\r\n\t\t\t\t// seems like these should delayed until node.expand() completes, but left here for back-compat about\r\n\t\t\t\t// when this.isOpen flag gets set (ie, at the beginning of the animation)\r\n\t\t\t\tthis.onOpen(node.item, node);\r\n\t\t\t\tthis._state(node, true);\r\n\r\n\t\t\t\treturn def2;\r\n\t\t\t}));\r\n\r\n\t\t\tthis._startPaint(def);\t// after this finishes, need to reset widths of TreeNodes\r\n\r\n\t\t\treturn def;\t// dojo/promise/Promise\r\n\t\t},\r\n\r\n\t\t////////////////// Miscellaneous functions ////////////////\r\n\r\n\t\tfocusNode: function(/* _tree.Node */ node){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tFocus on the specified node (which must be visible)\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\r\n\t\t\tvar scrollLeft = this.domNode.scrollLeft;\r\n\t\t\tthis.focusChild(node);\r\n\t\t\tthis.domNode.scrollLeft = scrollLeft;\r\n\t\t},\r\n\r\n\t\t_onNodeMouseEnter: function(/*dijit/_WidgetBase*/ /*===== node =====*/){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCalled when mouse is over a node (onmouseenter event),\r\n\t\t\t//\t\tthis is monitored by the DND code\r\n\t\t},\r\n\r\n\t\t_onNodeMouseLeave: function(/*dijit/_WidgetBase*/ /*===== node =====*/){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCalled when mouse leaves a node (onmouseleave event),\r\n\t\t\t//\t\tthis is monitored by the DND code\r\n\t\t},\r\n\r\n\t\t//////////////// Events from the model //////////////////////////\r\n\r\n\t\t_onItemChange: function(/*Item*/ item){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tProcesses notification of a change to an item's scalar values like label\r\n\t\t\tvar model = this.model,\r\n\t\t\t\tidentity = model.getIdentity(item),\r\n\t\t\t\tnodes = this._itemNodesMap[identity];\r\n\r\n\t\t\tif(nodes){\r\n\t\t\t\tvar label = this.getLabel(item),\r\n\t\t\t\t\ttooltip = this.getTooltip(item);\r\n\t\t\t\tarray.forEach(nodes, function(node){\r\n\t\t\t\t\tnode.set({\r\n\t\t\t\t\t\titem: item, // theoretically could be new JS Object representing same item\r\n\t\t\t\t\t\tlabel: label,\r\n\t\t\t\t\t\ttooltip: tooltip\r\n\t\t\t\t\t});\r\n\t\t\t\t\tnode._updateItemClasses(item);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_onItemChildrenChange: function(/*dojo/data/Item*/ parent, /*dojo/data/Item[]*/ newChildrenList){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tProcesses notification of a change to an item's children\r\n\t\t\tvar model = this.model,\r\n\t\t\t\tidentity = model.getIdentity(parent),\r\n\t\t\t\tparentNodes = this._itemNodesMap[identity];\r\n\r\n\t\t\tif(parentNodes){\r\n\t\t\t\tarray.forEach(parentNodes, function(parentNode){\r\n\t\t\t\t\tparentNode.setChildItems(newChildrenList);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_onItemDelete: function(/*Item*/ item){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tProcesses notification of a deletion of an item.\r\n\t\t\t//\t\tNot called from new dojo.store interface but there's cleanup code in setChildItems() instead.\r\n\r\n\t\t\tvar model = this.model,\r\n\t\t\t\tidentity = model.getIdentity(item),\r\n\t\t\t\tnodes = this._itemNodesMap[identity];\r\n\r\n\t\t\tif(nodes){\r\n\t\t\t\tarray.forEach(nodes, function(node){\r\n\t\t\t\t\t// Remove node from set of selected nodes (if it's selected)\r\n\t\t\t\t\tthis.dndController.removeTreeNode(node);\r\n\r\n\t\t\t\t\tvar parent = node.getParent();\r\n\t\t\t\t\tif(parent){\r\n\t\t\t\t\t\t// if node has not already been orphaned from a _onSetItem(parent, \"children\", ..) call...\r\n\t\t\t\t\t\tparent.removeChild(node);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// If we've orphaned the focused node then move focus to the root node\r\n\t\t\t\t\tif(this.lastFocusedChild && !dom.isDescendant(this.lastFocusedChild, this.domNode)){\r\n\t\t\t\t\t\tdelete this.lastFocusedChild;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(this.focusedChild && !dom.isDescendant(this.focusedChild, this.domNode)){\r\n\t\t\t\t\t\tthis.focus();\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tnode.destroyRecursive();\r\n\t\t\t\t}, this);\r\n\t\t\t\tdelete this._itemNodesMap[identity];\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/////////////// Miscellaneous funcs\r\n\r\n\t\t_initState: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tLoad in which nodes should be opened automatically\r\n\t\t\tthis._openedNodes = {};\r\n\t\t\tif(this.persist && this.cookieName){\r\n\t\t\t\tvar oreo = cookie(this.cookieName);\r\n\t\t\t\tif(oreo){\r\n\t\t\t\t\tarray.forEach(oreo.split(','), function(item){\r\n\t\t\t\t\t\tthis._openedNodes[item] = true;\r\n\t\t\t\t\t}, this);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_state: function(node, expanded){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tQuery or set expanded state for an node\r\n\t\t\tif(!this.persist){\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tvar path = array.map(node.getTreePath(),function(item){\r\n\t\t\t\treturn this.model.getIdentity(item);\r\n\t\t\t}, this).join(\"/\");\r\n\t\t\tif(arguments.length === 1){\r\n\t\t\t\treturn this._openedNodes[path];\r\n\t\t\t}else{\r\n\t\t\t\tif(expanded){\r\n\t\t\t\t\tthis._openedNodes[path] = true;\r\n\t\t\t\t}else{\r\n\t\t\t\t\tdelete this._openedNodes[path];\r\n\t\t\t\t}\r\n\t\t\t\tthis._saveExpandedNodes();\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_saveExpandedNodes: function(){\r\n\t\t\tif(this.persist && this.cookieName){\r\n\t\t\t\tvar ary = [];\r\n\t\t\t\tfor(var id in this._openedNodes){\r\n\t\t\t\t\tary.push(id);\r\n\t\t\t\t}\r\n\t\t\t\tcookie(this.cookieName, ary.join(\",\"), {expires: 365});\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tdestroy: function(){\r\n\t\t\tif(this._curSearch){\r\n\t\t\t\tthis._curSearch.timer.remove();\r\n\t\t\t\tdelete this._curSearch;\r\n\t\t\t}\r\n\t\t\tif(this.rootNode){\r\n\t\t\t\tthis.rootNode.destroyRecursive();\r\n\t\t\t}\r\n\t\t\tif(this.dndController && !lang.isString(this.dndController)){\r\n\t\t\t\tthis.dndController.destroy();\r\n\t\t\t}\r\n\t\t\tthis.rootNode = null;\r\n\t\t\tthis.inherited(arguments);\r\n\t\t},\r\n\r\n\t\tdestroyRecursive: function(){\r\n\t\t\t// A tree is treated as a leaf, not as a node with children (like a grid),\r\n\t\t\t// but defining destroyRecursive for back-compat.\r\n\t\t\tthis.destroy();\r\n\t\t},\r\n\r\n\t\tresize: function(changeSize){\r\n\t\t\tif(changeSize){\r\n\t\t\t\tdomGeometry.setMarginBox(this.domNode, changeSize);\r\n\t\t\t}\r\n\r\n\t\t\t// The main JS sizing involved w/tree is the indentation, which is specified\r\n\t\t\t// in CSS and read in through this dummy indentDetector node (tree must be\r\n\t\t\t// visible and attached to the DOM to read this).\r\n\t\t\t// If the Tree is hidden domGeometry.position(this.tree.indentDetector).w will return 0, in which case just\r\n\t\t\t// keep the default value.\r\n\t\t\tthis._nodePixelIndent = domGeometry.position(this.tree.indentDetector).w || this._nodePixelIndent;\r\n\r\n\t\t\t// resize() may be called before this.rootNode is created, so wait until it's available\r\n\t\t\tthis.expandChildrenDeferred.then(lang.hitch(this, function(){\r\n\t\t\t\t// If tree has already loaded, then reset indent for all the nodes\r\n\t\t\t\tthis.rootNode.set('indent', this.showRoot ? 0 : -1);\r\n\r\n\t\t\t\t// Also, adjust widths of all rows to match width of Tree\r\n\t\t\t\tthis._adjustWidths();\r\n\t\t\t}));\r\n\t\t},\r\n\r\n\t\t_outstandingPaintOperations: 0,\r\n\t\t_startPaint: function(/*Promise|Boolean*/ p){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCalled at the start of an operation that will change what's displayed.\r\n\t\t\t// p:\r\n\t\t\t//\t\tPromise that tells when the operation will complete.  Alternately, if it's just a Boolean, it signifies\r\n\t\t\t//\t\tthat the operation was synchronous, and already completed.\r\n\r\n\t\t\tthis._outstandingPaintOperations++;\r\n\t\t\tif(this._adjustWidthsTimer){\r\n\t\t\t\tthis._adjustWidthsTimer.remove();\r\n\t\t\t\tdelete this._adjustWidthsTimer;\r\n\t\t\t}\r\n\r\n\t\t\tvar oc = lang.hitch(this, function(){\r\n\t\t\t\tthis._outstandingPaintOperations--;\r\n\r\n\t\t\t\tif(this._outstandingPaintOperations <= 0 && !this._adjustWidthsTimer && this._started){\r\n\t\t\t\t\t// Use defer() to avoid a width adjustment when another operation will immediately follow,\r\n\t\t\t\t\t// such as a sequence of opening a node, then it's children, then it's grandchildren, etc.\r\n\t\t\t\t\tthis._adjustWidthsTimer = this.defer(\"_adjustWidths\");\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\twhen(p, oc, oc);\r\n\t\t},\r\n\r\n\t\t_adjustWidths: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSize container to match widest TreeNode, so that highlighting with scrolling works (#13141, #16132)\r\n\r\n\t\t\tif(this._adjustWidthsTimer){\r\n\t\t\t\tthis._adjustWidthsTimer.remove();\r\n\t\t\t\tdelete this._adjustWidthsTimer;\r\n\t\t\t}\r\n\r\n\t\t\tthis.containerNode.style.width = \"auto\";\r\n\t\t\tthis.containerNode.style.width = this.domNode.scrollWidth > this.domNode.offsetWidth ? \"auto\" : \"100%\";\r\n\t\t},\r\n\r\n\t\t_createTreeNode: function(/*Object*/ args){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tcreates a TreeNode\r\n\t\t\t// description:\r\n\t\t\t//\t\tDevelopers can override this method to define their own TreeNode class;\r\n\t\t\t//\t\tHowever it will probably be removed in a future release in favor of a way\r\n\t\t\t//\t\tof just specifying a widget for the label, rather than one that contains\r\n\t\t\t//\t\tthe children too.\r\n\t\t\treturn new TreeNode(args);\r\n\t\t},\r\n\r\n\t\tfocus: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tDefault focus() implementation: focus the previously focused child, or first child.\r\n\t\t\t//\t\tSome applications may want to change this method to focus the [first] selected child.\r\n\r\n\t\t\tif(this.lastFocusedChild){\r\n\t\t\t\tthis.focusNode(this.lastFocusedChild);\r\n\t\t\t}else{\r\n\t\t\t\tthis.focusFirstChild();\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\r\n\tif(has(\"dojo-bidi\")){\r\n\t\tTree.extend({\r\n\t\t\t_setTextDirAttr: function(textDir){\r\n\t\t\t\tif(textDir && this.textDir != textDir){\r\n\t\t\t\t\tthis._set(\"textDir\", textDir);\r\n\t\t\t\t\tthis.rootNode.set(\"textDir\", textDir);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tTree.PathError = createError(\"TreePathError\");\r\n\tTree._TreeNode = TreeNode;\t// for monkey patching or creating subclasses of TreeNode\r\n\r\n\treturn Tree;\r\n});\r\n"]}