{"version":3,"sources":["_Container.js"],"names":["define","array","declare","domConstruct","kernel","buildRendering","this","inherited","arguments","containerNode","domNode","addChild","widget","insertIndex","refNode","firstChild","nodeType","nextSibling","place","_started","startup","removeChild","getChildren","node","parentNode","hasChildren","length","_getSiblingOfChild","child","dir","deprecated","declaredClass","children","indexOf","getIndexOfChild"],"mappings":";;;;;;;AAAAA,QACC,mBACA,qBACA,qBACA,qBACE,SAASC,EAAOC,EAASC,EAAcC,GAKzC,OAAOF,EAAQ,mBAAoB,MAIlCG,eAAgB,WACfC,KAAKC,UAAUC,WACXF,KAAKG,gBAKRH,KAAKG,cAAgBH,KAAKI,UAI5BC,SAAU,SAA+BC,EAAiBC,GAUzD,IAAIC,EAAUR,KAAKG,cACnB,GAAGI,EAAc,EAAE,CAIlB,IADAC,EAAUA,EAAQC,WACZF,EAAc,GACI,GAApBC,EAAQE,UAAgBH,IAC3BC,EAAUA,EAAQG,YAEhBH,EACFD,EAAc,UAGdC,EAAUR,KAAKG,cACfI,EAAc,QAIhBV,EAAae,MAAMN,EAAOF,QAASI,EAASD,GAMzCP,KAAKa,WAAaP,EAAOO,UAC3BP,EAAOQ,WAITC,YAAa,SAAwBT,GAUpC,GAJoB,iBAAVA,IACTA,EAASN,KAAKgB,cAAcV,IAG1BA,EAAO,CACT,IAAIW,EAAOX,EAAOF,QACfa,GAAQA,EAAKC,YACfD,EAAKC,WAAWH,YAAYE,KAK/BE,YAAa,WAGZ,OAAOnB,KAAKgB,cAAcI,OAAS,GAGpCC,mBAAoB,SAA+BC,EAAeC,GAQjEzB,EAAO0B,WAAWxB,KAAKyB,cAAc,8EAA+E,GAAI,OACxH,IAAIC,EAAW1B,KAAKgB,cAEpB,OAAOU,EADA/B,EAAMgC,QAAQD,EAAUJ,GACTC,IAGvBK,gBAAiB,SAA+BN,GAG/C,OAAO3B,EAAMgC,QAAQ3B,KAAKgB,cAAeM","file":"../_Container.js","sourcesContent":["define([\r\n\t\"dojo/_base/array\", // array.forEach array.indexOf\r\n\t\"dojo/_base/declare\", // declare\r\n\t\"dojo/dom-construct\", // domConstruct.place\r\n\t\"dojo/_base/kernel\" // kernel.deprecated\r\n], function(array, declare, domConstruct, kernel){\r\n\r\n\t// module:\r\n\t//\t\tdijit/_Container\r\n\r\n\treturn declare(\"dijit._Container\", null, {\r\n\t\t// summary:\r\n\t\t//\t\tMixin for widgets that contain HTML and/or a set of widget children.\r\n\r\n\t\tbuildRendering: function(){\r\n\t\t\tthis.inherited(arguments);\r\n\t\t\tif(!this.containerNode){\r\n\t\t\t\t// All widgets with descendants must set containerNode.\r\n\t\t\t\t// NB: this code doesn't quite work right because for TabContainer it runs before\r\n\t\t\t\t// _TemplatedMixin::buildRendering(), and thus\r\n\t\t\t\t// sets this.containerNode to this.domNode, later to be overridden by the assignment in the template.\r\n\t\t\t\tthis.containerNode = this.domNode;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\taddChild: function(/*dijit/_WidgetBase*/ widget, /*int?*/ insertIndex){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tMakes the given widget a child of this widget.\r\n\t\t\t// description:\r\n\t\t\t//\t\tInserts specified child widget's dom node as a child of this widget's\r\n\t\t\t//\t\tcontainer node, and possibly does other processing (such as layout).\r\n\r\n\t\t\t// I want to just call domConstruct.place(widget.domNode, this.containerNode, insertIndex), but the counting\r\n\t\t\t// is thrown off by text nodes and comment nodes that show up when constructed by markup.\r\n\t\t\t// In the future consider stripping those nodes on construction, either in the parser or this widget code.\r\n\t\t\tvar refNode = this.containerNode;\r\n\t\t\tif(insertIndex > 0){\r\n\t\t\t\t// Old-school way to get nth child; dojo.query would be easier but _Container was weened from dojo.query\r\n\t\t\t\t// in #10087 to minimize download size.   Not sure if that's still and issue with new smaller dojo/query.\r\n\t\t\t\trefNode = refNode.firstChild;\r\n\t\t\t\twhile(insertIndex > 0){\r\n\t\t\t\t\tif(refNode.nodeType == 1){ insertIndex--; }\r\n\t\t\t\t\trefNode = refNode.nextSibling;\r\n\t\t\t\t}\r\n\t\t\t\tif(refNode){\r\n\t\t\t\t\tinsertIndex = \"before\";\r\n\t\t\t\t}else{\r\n\t\t\t\t\t// to support addChild(child, n-1) where there are n children (should add child at end)\r\n\t\t\t\t\trefNode = this.containerNode;\r\n\t\t\t\t\tinsertIndex = \"last\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tdomConstruct.place(widget.domNode, refNode, insertIndex);\r\n\r\n\t\t\t// If I've been started but the child widget hasn't been started,\r\n\t\t\t// start it now.  Make sure to do this after widget has been\r\n\t\t\t// inserted into the DOM tree, so it can see that it's being controlled by me,\r\n\t\t\t// so it doesn't try to size itself.\r\n\t\t\tif(this._started && !widget._started){\r\n\t\t\t\twidget.startup();\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tremoveChild: function(/*Widget|int*/ widget){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tRemoves the passed widget instance from this widget but does\r\n\t\t\t//\t\tnot destroy it.  You can also pass in an integer indicating\r\n\t\t\t//\t\tthe index within the container to remove (ie, removeChild(5) removes the sixth widget).\r\n\r\n\t\t\tif(typeof widget == \"number\"){\r\n\t\t\t\twidget = this.getChildren()[widget];\r\n\t\t\t}\r\n\r\n\t\t\tif(widget){\r\n\t\t\t\tvar node = widget.domNode;\r\n\t\t\t\tif(node && node.parentNode){\r\n\t\t\t\t\tnode.parentNode.removeChild(node); // detach but don't destroy\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\thasChildren: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns true if widget has child widgets, i.e. if this.containerNode contains widgets.\r\n\t\t\treturn this.getChildren().length > 0;\t// Boolean\r\n\t\t},\r\n\r\n\t\t_getSiblingOfChild: function(/*dijit/_WidgetBase*/ child, /*int*/ dir){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tGet the next or previous widget sibling of child\r\n\t\t\t// dir:\r\n\t\t\t//\t\tif 1, get the next sibling\r\n\t\t\t//\t\tif -1, get the previous sibling\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\tkernel.deprecated(this.declaredClass+\"::_getSiblingOfChild() is deprecated. Use _KeyNavMixin::_getNext() instead.\", \"\", \"2.0\");\r\n\t\t\tvar children = this.getChildren(),\r\n\t\t\t\tidx = array.indexOf(children, child);\t// int\r\n\t\t\treturn children[idx + dir];\r\n\t\t},\r\n\r\n\t\tgetIndexOfChild: function(/*dijit/_WidgetBase*/ child){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tGets the index of the child in this container or -1 if not found\r\n\t\t\treturn array.indexOf(this.getChildren(), child);\t// int\r\n\t\t}\r\n\t});\r\n});\r\n"]}