{"version":3,"sources":["_KeyNavMixin.js"],"names":["define","array","declare","domAttr","keys","lang","on","registry","_FocusMixin","tabIndex","childSelector","postCreate","this","inherited","arguments","set","domNode","_keyNavCodes","keyCodes","HOME","hitch","END","isLeftToRight","LEFT_ARROW","RIGHT_ARROW","UP_ARROW","DOWN_ARROW","self","own","containerNode","selector","evt","_onChildFocus","getEnclosingWidget","_onLeftArrow","_onRightArrow","_onUpArrow","_onDownArrow","focus","focusFirstChild","_getFirstFocusableChild","_getNextFocusableChild","_getLastFocusableChild","focusChild","focusLastChild","widget","last","focusedChild","_onChildBlur","_onContainerFocus","target","_onFocus","_onBlur","lastFocusedChild","_set","child","_destroyed","lastFocused","_searchString","multiCharSearchDuration","onKeyboardSearch","item","searchString","numMatches","_keyboardSearchCompare","element","currentString","label","focusNode","innerText","textContent","replace","substr","length","toLowerCase","_onContainerKeydown","func","keyCode","stopPropagation","preventDefault","SPACE","_searchTimer","ctrlKey","altKey","metaKey","stopImmediatePropagation","_keyboardSearch","_onContainerKeypress","charCode","String","fromCharCode","keyChar","matchedItem","remove","searchLen","test","defer","currentItem","stop","rc","search","dir","wrappedValue","_getNext","isFocusable","_getFirst","_getLast","w","byNode"],"mappings":"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","file":"../_KeyNavMixin.js","sourcesContent":["define([\r\n\t\"dojo/_base/array\", // array.forEach\r\n\t\"dojo/_base/declare\", // declare\r\n\t\"dojo/dom-attr\", // domAttr.set\r\n\t\"dojo/keys\", // keys.END keys.HOME, keys.LEFT_ARROW etc.\r\n\t\"dojo/_base/lang\", // lang.hitch\r\n\t\"dojo/on\",\r\n\t\"dijit/registry\",\r\n\t\"dijit/_FocusMixin\"        // to make _onBlur() work\r\n], function(array, declare, domAttr, keys, lang, on, registry, _FocusMixin){\r\n\r\n\t// module:\r\n\t//\t\tdijit/_KeyNavMixin\r\n\r\n\treturn declare(\"dijit._KeyNavMixin\", _FocusMixin, {\r\n\t\t// summary:\r\n\t\t//\t\tA mixin to allow arrow key and letter key navigation of child or descendant widgets.\r\n\t\t//\t\tIt can be used by dijit/_Container based widgets with a flat list of children,\r\n\t\t//\t\tor more complex widgets like dijit/Tree.\r\n\t\t//\r\n\t\t//\t\tTo use this mixin, the subclass must:\r\n\t\t//\r\n\t\t//\t\t\t- Implement  _getNext(), _getFirst(), _getLast(), _onLeftArrow(), _onRightArrow()\r\n\t\t//\t\t\t  _onDownArrow(), _onUpArrow() methods to handle home/end/left/right/up/down keystrokes.\r\n\t\t//\t\t\t  Next and previous in this context refer to a linear ordering of the descendants used\r\n\t\t//\t\t\t  by letter key search.\r\n\t\t//\t\t\t- Set all descendants' initial tabIndex to \"-1\"; both initial descendants and any\r\n\t\t//\t\t\t  descendants added later, by for example addChild()\r\n\t\t//\t\t\t- Define childSelector to a function or string that identifies focusable descendant widgets\r\n\t\t//\r\n\t\t//\t\tAlso, child widgets must implement a focus() method.\r\n\r\n\t\t/*=====\r\n\t\t // focusedChild: [protected readonly] Widget\r\n\t\t //\t\tThe currently focused child widget, or null if there isn't one\r\n\t\t focusedChild: null,\r\n\r\n\t\t // _keyNavCodes: Object\r\n\t\t //\t\tHash mapping key code (arrow keys and home/end key) to functions to handle those keys.\r\n\t\t //\t\tUsually not used directly, as subclasses can instead override _onLeftArrow() etc.\r\n\t\t _keyNavCodes: {},\r\n\t\t =====*/\r\n\r\n\t\t// tabIndex: String\r\n\t\t//\t\tTab index of the container; same as HTML tabIndex attribute.\r\n\t\t//\t\tNote then when user tabs into the container, focus is immediately\r\n\t\t//\t\tmoved to the first item in the container.\r\n\t\ttabIndex: \"0\",\r\n\r\n\t\t// childSelector: [protected abstract] Function||String\r\n\t\t//\t\tSelector (passed to on.selector()) used to identify what to treat as a child widget.   Used to monitor\r\n\t\t//\t\tfocus events and set this.focusedChild.   Must be set by implementing class.   If this is a string\r\n\t\t//\t\t(ex: \"> *\") then the implementing class must require dojo/query.\r\n\t\tchildSelector: null,\r\n\r\n\t\tpostCreate: function(){\r\n\t\t\tthis.inherited(arguments);\r\n\r\n\t\t\t// Set tabIndex on this.domNode.  Will be automatic after #7381 is fixed.\r\n\t\t\tdomAttr.set(this.domNode, \"tabIndex\", this.tabIndex);\r\n\r\n\t\t\tif(!this._keyNavCodes){\r\n\t\t\t\tvar keyCodes = this._keyNavCodes = {};\r\n\t\t\t\tkeyCodes[keys.HOME] = lang.hitch(this, \"focusFirstChild\");\r\n\t\t\t\tkeyCodes[keys.END] = lang.hitch(this, \"focusLastChild\");\r\n\t\t\t\tkeyCodes[this.isLeftToRight() ? keys.LEFT_ARROW : keys.RIGHT_ARROW] = lang.hitch(this, \"_onLeftArrow\");\r\n\t\t\t\tkeyCodes[this.isLeftToRight() ? keys.RIGHT_ARROW : keys.LEFT_ARROW] = lang.hitch(this, \"_onRightArrow\");\r\n\t\t\t\tkeyCodes[keys.UP_ARROW] = lang.hitch(this, \"_onUpArrow\");\r\n\t\t\t\tkeyCodes[keys.DOWN_ARROW] = lang.hitch(this, \"_onDownArrow\");\r\n\t\t\t}\r\n\r\n\t\t\tvar self = this,\r\n\t\t\t\tchildSelector = typeof this.childSelector == \"string\"\r\n\t\t\t\t\t? this.childSelector\r\n\t\t\t\t\t: lang.hitch(this, \"childSelector\");\r\n\t\t\tthis.own(\r\n\t\t\t\ton(this.domNode, \"keypress\", lang.hitch(this, \"_onContainerKeypress\")),\r\n\t\t\t\ton(this.domNode, \"keydown\", lang.hitch(this, \"_onContainerKeydown\")),\r\n\t\t\t\ton(this.domNode, \"focus\", lang.hitch(this, \"_onContainerFocus\")),\r\n\t\t\t\ton(this.containerNode, on.selector(childSelector, \"focusin\"), function(evt){\r\n\t\t\t\t\tself._onChildFocus(registry.getEnclosingWidget(this), evt);\r\n\t\t\t\t})\r\n\t\t\t);\r\n\t\t},\r\n\r\n\t\t_onLeftArrow: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCalled on left arrow key, or right arrow key if widget is in RTL mode.\r\n\t\t\t//\t\tShould go back to the previous child in horizontal container widgets like Toolbar.\r\n\t\t\t// tags:\r\n\t\t\t//\t\textension\r\n\t\t},\r\n\r\n\t\t_onRightArrow: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCalled on right arrow key, or left arrow key if widget is in RTL mode.\r\n\t\t\t//\t\tShould go to the next child in horizontal container widgets like Toolbar.\r\n\t\t\t// tags:\r\n\t\t\t//\t\textension\r\n\t\t},\r\n\r\n\t\t_onUpArrow: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCalled on up arrow key. Should go to the previous child in vertical container widgets like Menu.\r\n\t\t\t// tags:\r\n\t\t\t//\t\textension\r\n\t\t},\r\n\r\n\t\t_onDownArrow: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCalled on down arrow key. Should go to the next child in vertical container widgets like Menu.\r\n\t\t\t// tags:\r\n\t\t\t//\t\textension\r\n\t\t},\r\n\r\n\t\tfocus: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tDefault focus() implementation: focus the first child.\r\n\t\t\tthis.focusFirstChild();\r\n\t\t},\r\n\r\n\t\t_getFirstFocusableChild: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns first child that can be focused.\r\n\r\n\t\t\t// Leverage _getNextFocusableChild() to skip disabled children\r\n\t\t\treturn this._getNextFocusableChild(null, 1);\t// dijit/_WidgetBase\r\n\t\t},\r\n\r\n\t\t_getLastFocusableChild: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns last child that can be focused.\r\n\r\n\t\t\t// Leverage _getNextFocusableChild() to skip disabled children\r\n\t\t\treturn this._getNextFocusableChild(null, -1);\t// dijit/_WidgetBase\r\n\t\t},\r\n\r\n\t\tfocusFirstChild: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tFocus the first focusable child in the container.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\r\n\t\t\tthis.focusChild(this._getFirstFocusableChild());\r\n\t\t},\r\n\r\n\t\tfocusLastChild: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tFocus the last focusable child in the container.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\r\n\t\t\tthis.focusChild(this._getLastFocusableChild());\r\n\t\t},\r\n\r\n\t\tfocusChild: function(/*dijit/_WidgetBase*/ widget, /*Boolean*/ last){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tFocus specified child widget.\r\n\t\t\t// widget:\r\n\t\t\t//\t\tReference to container's child widget\r\n\t\t\t// last:\r\n\t\t\t//\t\tIf true and if widget has multiple focusable nodes, focus the\r\n\t\t\t//\t\tlast one instead of the first one\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\r\n\t\t\tif(!widget){\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif(this.focusedChild && widget !== this.focusedChild){\r\n\t\t\t\tthis._onChildBlur(this.focusedChild);\t// used to be used by _MenuBase\r\n\t\t\t}\r\n\t\t\twidget.set(\"tabIndex\", this.tabIndex);\t// for IE focus outline to appear, must set tabIndex before focus\r\n\t\t\twidget.focus(last ? \"end\" : \"start\");\r\n\r\n\t\t\t// Don't set focusedChild here, because the focus event should trigger a call to _onChildFocus(), which will\r\n\t\t\t// set it.   More importantly, _onChildFocus(), which may be executed asynchronously (after this function\r\n\t\t\t// returns) needs to know the old focusedChild to set its tabIndex to -1.\r\n\t\t},\r\n\r\n\t\t_onContainerFocus: function(evt){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tHandler for when the container itself gets focus.\r\n\t\t\t// description:\r\n\t\t\t//\t\tInitially the container itself has a tabIndex, but when it gets\r\n\t\t\t//\t\tfocus, switch focus to first child.\r\n\t\t\t//\r\n\t\t\t//\t\tTODO for 2.0 (or earlier): Instead of having the container tabbable, always maintain a single child\r\n\t\t\t//\t\twidget as tabbable, Requires code in startup(), addChild(), and removeChild().\r\n\t\t\t//\t\tThat would avoid various issues like #17347.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\r\n\t\t\t// Note that we can't use _onFocus() because switching focus from the\r\n\t\t\t// _onFocus() handler confuses the focus.js code\r\n\t\t\t// (because it causes _onFocusNode() to be called recursively).\r\n\t\t\t// Also, _onFocus() would fire when focus went directly to a child widget due to mouse click.\r\n\r\n\t\t\t// Ignore spurious focus events:\r\n\t\t\t//\t1. focus on a child widget bubbles on FF\r\n\t\t\t//\t2. on IE, clicking the scrollbar of a select dropdown moves focus from the focused child item to me\r\n\t\t\tif(evt.target !== this.domNode || this.focusedChild){\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tthis.focus();\r\n\t\t},\r\n\r\n\t\t_onFocus: function(){\r\n\t\t\t// When the container gets focus by being tabbed into, or a descendant gets focus by being clicked,\r\n\t\t\t// set the container's tabIndex to -1 (don't remove as that breaks Safari 4) so that tab or shift-tab\r\n\t\t\t// will go to the fields after/before the container, rather than the container itself\r\n\t\t\tdomAttr.set(this.domNode, \"tabIndex\", \"-1\");\r\n\r\n\t\t\tthis.inherited(arguments);\r\n\t\t},\r\n\r\n\t\t_onBlur: function(evt){\r\n\t\t\t// When focus is moved away the container, and its descendant (popup) widgets,\r\n\t\t\t// then restore the container's tabIndex so that user can tab to it again.\r\n\t\t\t// Note that using _onBlur() so that this doesn't happen when focus is shifted\r\n\t\t\t// to one of my child widgets (typically a popup)\r\n\r\n\t\t\t// TODO: for 2.0 consider changing this to blur whenever the container blurs, to be truthful that there is\r\n\t\t\t// no focused child at that time.\r\n\r\n\t\t\tdomAttr.set(this.domNode, \"tabIndex\", this.tabIndex);\r\n\t\t\tif(this.focusedChild){\r\n\t\t\t\tthis.focusedChild.set(\"tabIndex\", \"-1\");\r\n\t\t\t\tthis.lastFocusedChild = this.focusedChild;\r\n\t\t\t\tthis._set(\"focusedChild\", null);\r\n\t\t\t}\r\n\t\t\tthis.inherited(arguments);\r\n\t\t},\r\n\r\n\t\t_onChildFocus: function(/*dijit/_WidgetBase*/ child){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCalled when a child widget gets focus, either by user clicking\r\n\t\t\t//\t\tit, or programatically by arrow key handling code.\r\n\t\t\t// description:\r\n\t\t\t//\t\tIt marks that the current node is the selected one, and the previously\r\n\t\t\t//\t\tselected node no longer is.\r\n\r\n\t\t\tif(child && child != this.focusedChild){\r\n\t\t\t\tif(this.focusedChild && !this.focusedChild._destroyed){\r\n\t\t\t\t\t// mark that the previously focusable node is no longer focusable\r\n\t\t\t\t\tthis.focusedChild.set(\"tabIndex\", \"-1\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// mark that the new node is the currently selected one\r\n\t\t\t\tchild.set(\"tabIndex\", this.tabIndex);\r\n\t\t\t\tthis.lastFocused = child;\t\t// back-compat for Tree, remove for 2.0\r\n\t\t\t\tthis._set(\"focusedChild\", child);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_searchString: \"\",\r\n\t\t// multiCharSearchDuration: Number\r\n\t\t//\t\tIf multiple characters are typed where each keystroke happens within\r\n\t\t//\t\tmultiCharSearchDuration of the previous keystroke,\r\n\t\t//\t\tsearch for nodes matching all the keystrokes.\r\n\t\t//\r\n\t\t//\t\tFor example, typing \"ab\" will search for entries starting with\r\n\t\t//\t\t\"ab\" unless the delay between \"a\" and \"b\" is greater than multiCharSearchDuration.\r\n\t\tmultiCharSearchDuration: 1000,\r\n\r\n\t\tonKeyboardSearch: function(/*dijit/_WidgetBase*/ item, /*Event*/ evt, /*String*/ searchString, /*Number*/ numMatches){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tWhen a key is pressed that matches a child item,\r\n\t\t\t//\t\tthis method is called so that a widget can take appropriate action is necessary.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\t\t\tif(item){\r\n\t\t\t\tthis.focusChild(item);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_keyboardSearchCompare: function(/*dijit/_WidgetBase*/ item, /*String*/ searchString){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCompares the searchString to the widget's text label, returning:\r\n\t\t\t//\r\n\t\t\t//\t\t\t* -1: a high priority match  and stop searching\r\n\t\t\t//\t\t \t* 0: not a match\r\n\t\t\t//\t\t \t* 1: a match but keep looking for a higher priority match\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\r\n\t\t\tvar element = item.domNode,\r\n\t\t\t\ttext = item.label || (element.focusNode ? element.focusNode.label : '') || element.innerText || element.textContent || \"\",\r\n\t\t\t\tcurrentString = text.replace(/^\\s+/, '').substr(0, searchString.length).toLowerCase();\r\n\r\n\t\t\treturn (!!searchString.length && currentString == searchString) ? -1 : 0; // stop searching after first match by default\r\n\t\t},\r\n\r\n\t\t_onContainerKeydown: function(evt){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tWhen a key is pressed, if it's an arrow key etc. then it's handled here.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\r\n\t\t\tvar func = this._keyNavCodes[evt.keyCode];\r\n\t\t\tif(func){\r\n\t\t\t\tfunc(evt, this.focusedChild);\r\n\t\t\t\tevt.stopPropagation();\r\n\t\t\t\tevt.preventDefault();\r\n\t\t\t\tthis._searchString = ''; // so a DOWN_ARROW b doesn't search for ab\r\n\t\t\t}else if(evt.keyCode == keys.SPACE && this._searchTimer && !(evt.ctrlKey || evt.altKey || evt.metaKey)){\r\n\t\t\t\tevt.stopImmediatePropagation(); // stop a11yclick and _HasDropdown from seeing SPACE if we're doing keyboard searching\r\n\t\t\t\tevt.preventDefault(); // stop IE from scrolling, and most browsers (except FF) from sending keypress\r\n\t\t\t\tthis._keyboardSearch(evt, ' ');\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_onContainerKeypress: function(evt){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tWhen a printable key is pressed, it's handled here, searching by letter.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\r\n\t\t\t// Ignore:\r\n\t\t\t// \t\t- duplicate events on firefox (ex: arrow key that will be handled by keydown handler)\r\n\t\t\t//\t\t- control sequences like CMD-Q.\r\n\t\t\t//\t\t- the SPACE key (only occurs on FF)\r\n\t\t\t//\r\n\t\t\t// Note: if there's no search in progress, then SPACE should be ignored.   If there is a search\r\n\t\t\t// in progress, then SPACE is handled in _onContainerKeyDown.\r\n\t\t\tif(evt.charCode <= keys.SPACE || evt.ctrlKey || evt.altKey || evt.metaKey){\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tevt.preventDefault();\r\n\t\t\tevt.stopPropagation();\r\n\r\n\t\t\tthis._keyboardSearch(evt, String.fromCharCode(evt.charCode).toLowerCase());\r\n\t\t},\r\n\r\n\t\t_keyboardSearch: function(/*Event*/ evt, /*String*/ keyChar){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tPerform a search of the widget's options based on the user's keyboard activity\r\n\t\t\t// description:\r\n\t\t\t//\t\tCalled on keypress (and sometimes keydown), searches through this widget's children\r\n\t\t\t//\t\tlooking for items that match the user's typed search string.  Multiple characters\r\n\t\t\t//\t\ttyped within 1 sec of each other are combined for multicharacter searching.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\tvar\r\n\t\t\t\tmatchedItem = null,\r\n\t\t\t\tsearchString,\r\n\t\t\t\tnumMatches = 0,\r\n\t\t\t\tsearch = lang.hitch(this, function(){\r\n\t\t\t\t\tif(this._searchTimer){\r\n\t\t\t\t\t\tthis._searchTimer.remove();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis._searchString += keyChar;\r\n\t\t\t\t\tvar allSameLetter = /^(.)\\1*$/.test(this._searchString);\r\n\t\t\t\t\tvar searchLen = allSameLetter ? 1 : this._searchString.length;\r\n\t\t\t\t\tsearchString = this._searchString.substr(0, searchLen);\r\n\t\t\t\t\t// commented out code block to search again if the multichar search fails after a smaller timeout\r\n\t\t\t\t\t//this._searchTimer = this.defer(function(){ // this is the \"failure\" timeout\r\n\t\t\t\t\t//\tthis._typingSlowly = true; // if the search fails, then treat as a full timeout\r\n\t\t\t\t\t//\tthis._searchTimer = this.defer(function(){ // this is the \"success\" timeout\r\n\t\t\t\t\t//\t\tthis._searchTimer = null;\r\n\t\t\t\t\t//\t\tthis._searchString = '';\r\n\t\t\t\t\t//\t}, this.multiCharSearchDuration >> 1);\r\n\t\t\t\t\t//}, this.multiCharSearchDuration >> 1);\r\n\t\t\t\t\tthis._searchTimer = this.defer(function(){ // this is the \"success\" timeout\r\n\t\t\t\t\t\tthis._searchTimer = null;\r\n\t\t\t\t\t\tthis._searchString = '';\r\n\t\t\t\t\t}, this.multiCharSearchDuration);\r\n\t\t\t\t\tvar currentItem = this.focusedChild || null;\r\n\t\t\t\t\tif(searchLen == 1 || !currentItem){\r\n\t\t\t\t\t\tcurrentItem = this._getNextFocusableChild(currentItem, 1); // skip current\r\n\t\t\t\t\t\tif(!currentItem){\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t} // no items\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar stop = currentItem;\r\n\t\t\t\t\tdo{\r\n\t\t\t\t\t\tvar rc = this._keyboardSearchCompare(currentItem, searchString);\r\n\t\t\t\t\t\tif(!!rc && numMatches++ == 0){\r\n\t\t\t\t\t\t\tmatchedItem = currentItem;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(rc == -1){ // priority match\r\n\t\t\t\t\t\t\tnumMatches = -1;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcurrentItem = this._getNextFocusableChild(currentItem, 1);\r\n\t\t\t\t\t}while(currentItem != stop);\r\n\t\t\t\t\t// commented out code block to search again if the multichar search fails after a smaller timeout\r\n\t\t\t\t\t//if(!numMatches && (this._typingSlowly || searchLen == 1)){\r\n\t\t\t\t\t//\tthis._searchString = '';\r\n\t\t\t\t\t//\tif(searchLen > 1){\r\n\t\t\t\t\t//\t\t// if no matches and they're typing slowly, then go back to first letter searching\r\n\t\t\t\t\t//\t\tsearch();\r\n\t\t\t\t\t//\t}\r\n\t\t\t\t\t//}\r\n\t\t\t\t});\r\n\r\n\t\t\tsearch();\r\n\t\t\t// commented out code block to search again if the multichar search fails after a smaller timeout\r\n\t\t\t//this._typingSlowly = false;\r\n\t\t\tthis.onKeyboardSearch(matchedItem, evt, searchString, numMatches);\r\n\t\t},\r\n\r\n\t\t_onChildBlur: function(/*dijit/_WidgetBase*/ /*===== widget =====*/){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCalled when focus leaves a child widget to go\r\n\t\t\t//\t\tto a sibling widget.\r\n\t\t\t//\t\tUsed to be used by MenuBase.js (remove for 2.0)\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\t\t},\r\n\r\n\t\t_getNextFocusableChild: function(child, dir){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns the next or previous focusable descendant, compared to \"child\".\r\n\t\t\t//\t\tImplements and extends _KeyNavMixin._getNextFocusableChild() for a _Container.\r\n\t\t\t// child: Widget\r\n\t\t\t//\t\tThe current widget\r\n\t\t\t// dir: Integer\r\n\t\t\t//\t\t- 1 = after\r\n\t\t\t//\t\t- -1 = before\r\n\t\t\t// tags:\r\n\t\t\t//\t\tabstract extension\r\n\r\n\t\t\tvar wrappedValue = child;\r\n\t\t\tdo{\r\n\t\t\t\tif(!child){\r\n\t\t\t\t\tchild = this[dir > 0 ? \"_getFirst\" : \"_getLast\"]();\r\n\t\t\t\t\tif(!child){ break; }\r\n\t\t\t\t}else{\r\n\t\t\t\t\tchild = this._getNext(child, dir);\r\n\t\t\t\t}\r\n\t\t\t\tif(child != null && child != wrappedValue && child.isFocusable()){\r\n\t\t\t\t\treturn child;\t// dijit/_WidgetBase\r\n\t\t\t\t}\r\n\t\t\t}while(child != wrappedValue);\r\n\t\t\t// no focusable child found\r\n\t\t\treturn null;\t// dijit/_WidgetBase\r\n\t\t},\r\n\r\n\t\t_getFirst: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns the first child.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tabstract extension\r\n\r\n\t\t\treturn null;\t// dijit/_WidgetBase\r\n\t\t},\r\n\r\n\t\t_getLast: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns the last descendant.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tabstract extension\r\n\r\n\t\t\treturn null;\t// dijit/_WidgetBase\r\n\t\t},\r\n\r\n\t\t_getNext: function(child, dir){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns the next descendant, compared to \"child\".\r\n\t\t\t// child: Widget\r\n\t\t\t//\t\tThe current widget\r\n\t\t\t// dir: Integer\r\n\t\t\t//\t\t- 1 = after\r\n\t\t\t//\t\t- -1 = before\r\n\t\t\t// tags:\r\n\t\t\t//\t\tabstract extension\r\n\r\n\t\t\tif(child){\r\n\t\t\t\tchild = child.domNode;\r\n\t\t\t\twhile(child){\r\n\t\t\t\t\tchild = child[dir < 0 ? \"previousSibling\" : \"nextSibling\"];\r\n\t\t\t\t\tif(child  && \"getAttribute\" in child){\r\n\t\t\t\t\t\tvar w = registry.byNode(child);\r\n\t\t\t\t\t\tif(w){\r\n\t\t\t\t\t\t\treturn w; // dijit/_WidgetBase\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn null;\t// dijit/_WidgetBase\r\n\t\t}\r\n\t});\r\n});\r\n"]}